(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["app"],{

/***/ "./assets/js/app.js":
/*!**************************!*\
  !*** ./assets/js/app.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// const $ = require('jquery/dist/jquery.min.js');
// const jQuery = $.noConflict(true);
__webpack_require__(/*! ./lib/bootstrap/js/bootstrap.min.js */ "./assets/js/lib/bootstrap/js/bootstrap.min.js");

__webpack_require__(/*! ./lib/bootstrap/js/bootstrap.bundle.min.js */ "./assets/js/lib/bootstrap/js/bootstrap.bundle.min.js");

__webpack_require__(/*! ./lib/counterup/counterup.min */ "./assets/js/lib/counterup/counterup.min.js");

__webpack_require__(/*! ./lib/easing/easing.min */ "./assets/js/lib/easing/easing.min.js"); // require('./lib/isotope/isotope.pkgd.min.js');


__webpack_require__(/*! ./lib/lightbox/js/lightbox.min */ "./assets/js/lib/lightbox/js/lightbox.min.js");

__webpack_require__(/*! ./lib/superfish/hoverIntent.js */ "./assets/js/lib/superfish/hoverIntent.js");

__webpack_require__(/*! ./lib/superfish/superfish.min */ "./assets/js/lib/superfish/superfish.min.js");

__webpack_require__(/*! ./lib/touchSwipe/jquery.touchSwipe.min */ "./assets/js/lib/touchSwipe/jquery.touchSwipe.min.js");

__webpack_require__(/*! ./lib/waypoints/waypoints.min */ "./assets/js/lib/waypoints/waypoints.min.js");

__webpack_require__(/*! ./main.js */ "./assets/js/main.js"); // import './lib/bootstrap/js/bootstrap.min.js';
// import './lib/bootstrap/js/bootstrap.bundle.min.js';
// import './lib/counterup/counterup.min';
// import './lib/easing/easing.min';
// import './lib/isotope/isotope.pkgd.min';
// import './lib/lightbox/js/lightbox.min';
// import './lib/superfish/hoverIntent.js';
// import './lib/superfish/superfish.min';
// import './lib/touchSwipe/jquery.touchSwipe.min';
// import './lib/waypoints/waypoints.min';
//
// import './main.js';

/***/ }),

/***/ "./assets/js/lib/bootstrap/js/bootstrap.bundle.min.js":
/*!************************************************************!*\
  !*** ./assets/js/lib/bootstrap/js/bootstrap.bundle.min.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap v4.2.1 (https://getbootstrap.com/)
  * Copyright 2011-2018 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
!function (t, e) {
  "object" == ( false ? undefined : _typeof(exports)) && "undefined" != typeof module ? e(exports, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
}(this, function (t, p) {
  "use strict";

  function i(t, e) {
    for (var n = 0; n < e.length; n++) {
      var i = e[n];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
    }
  }

  function s(t, e, n) {
    return e && i(t.prototype, e), n && i(t, n), t;
  }

  function l(o) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {},
          e = Object.keys(r);
      "function" == typeof Object.getOwnPropertySymbols && (e = e.concat(Object.getOwnPropertySymbols(r).filter(function (t) {
        return Object.getOwnPropertyDescriptor(r, t).enumerable;
      }))), e.forEach(function (t) {
        var e, n, i;
        e = o, i = r[n = t], n in e ? Object.defineProperty(e, n, {
          value: i,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[n] = i;
      });
    }

    return o;
  }

  p = p && p.hasOwnProperty("default") ? p.default : p;
  var e = "transitionend";

  function n(t) {
    var e = this,
        n = !1;
    return p(this).one(m.TRANSITION_END, function () {
      n = !0;
    }), setTimeout(function () {
      n || m.triggerTransitionEnd(e);
    }, t), this;
  }

  var m = {
    TRANSITION_END: "bsTransitionEnd",
    getUID: function getUID(t) {
      for (; t += ~~(1e6 * Math.random()), document.getElementById(t);) {
        ;
      }

      return t;
    },
    getSelectorFromElement: function getSelectorFromElement(t) {
      var e = t.getAttribute("data-target");

      if (!e || "#" === e) {
        var n = t.getAttribute("href");
        e = n && "#" !== n ? n.trim() : "";
      }

      return e && document.querySelector(e) ? e : null;
    },
    getTransitionDurationFromElement: function getTransitionDurationFromElement(t) {
      if (!t) return 0;
      var e = p(t).css("transition-duration"),
          n = p(t).css("transition-delay"),
          i = parseFloat(e),
          o = parseFloat(n);
      return i || o ? (e = e.split(",")[0], n = n.split(",")[0], 1e3 * (parseFloat(e) + parseFloat(n))) : 0;
    },
    reflow: function reflow(t) {
      return t.offsetHeight;
    },
    triggerTransitionEnd: function triggerTransitionEnd(t) {
      p(t).trigger(e);
    },
    supportsTransitionEnd: function supportsTransitionEnd() {
      return Boolean(e);
    },
    isElement: function isElement(t) {
      return (t[0] || t).nodeType;
    },
    typeCheckConfig: function typeCheckConfig(t, e, n) {
      for (var i in n) {
        if (Object.prototype.hasOwnProperty.call(n, i)) {
          var o = n[i],
              r = e[i],
              s = r && m.isElement(r) ? "element" : (a = r, {}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase());
          if (!new RegExp(o).test(s)) throw new Error(t.toUpperCase() + ': Option "' + i + '" provided type "' + s + '" but expected type "' + o + '".');
        }
      }

      var a;
    },
    findShadowRoot: function findShadowRoot(t) {
      if (!document.documentElement.attachShadow) return null;
      if ("function" != typeof t.getRootNode) return t instanceof ShadowRoot ? t : t.parentNode ? m.findShadowRoot(t.parentNode) : null;
      var e = t.getRootNode();
      return e instanceof ShadowRoot ? e : null;
    }
  };
  p.fn.emulateTransitionEnd = n, p.event.special[m.TRANSITION_END] = {
    bindType: e,
    delegateType: e,
    handle: function handle(t) {
      if (p(t.target).is(this)) return t.handleObj.handler.apply(this, arguments);
    }
  };

  var o = "alert",
      r = "bs.alert",
      a = "." + r,
      c = p.fn[o],
      h = {
    CLOSE: "close" + a,
    CLOSED: "closed" + a,
    CLICK_DATA_API: "click" + a + ".data-api"
  },
      u = "alert",
      f = "fade",
      d = "show",
      g = function () {
    function i(t) {
      this._element = t;
    }

    var t = i.prototype;
    return t.close = function (t) {
      var e = this._element;
      t && (e = this._getRootElement(t)), this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e);
    }, t.dispose = function () {
      p.removeData(this._element, r), this._element = null;
    }, t._getRootElement = function (t) {
      var e = m.getSelectorFromElement(t),
          n = !1;
      return e && (n = document.querySelector(e)), n || (n = p(t).closest("." + u)[0]), n;
    }, t._triggerCloseEvent = function (t) {
      var e = p.Event(h.CLOSE);
      return p(t).trigger(e), e;
    }, t._removeElement = function (e) {
      var n = this;

      if (p(e).removeClass(d), p(e).hasClass(f)) {
        var t = m.getTransitionDurationFromElement(e);
        p(e).one(m.TRANSITION_END, function (t) {
          return n._destroyElement(e, t);
        }).emulateTransitionEnd(t);
      } else this._destroyElement(e);
    }, t._destroyElement = function (t) {
      p(t).detach().trigger(h.CLOSED).remove();
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = p(this),
            e = t.data(r);
        e || (e = new i(this), t.data(r, e)), "close" === n && e[n](this);
      });
    }, i._handleDismiss = function (e) {
      return function (t) {
        t && t.preventDefault(), e.close(this);
      };
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }]), i;
  }();

  p(document).on(h.CLICK_DATA_API, '[data-dismiss="alert"]', g._handleDismiss(new g())), p.fn[o] = g._jQueryInterface, p.fn[o].Constructor = g, p.fn[o].noConflict = function () {
    return p.fn[o] = c, g._jQueryInterface;
  };

  var _ = "button",
      v = "bs.button",
      y = "." + v,
      E = ".data-api",
      b = p.fn[_],
      w = "active",
      T = "btn",
      C = "focus",
      S = '[data-toggle^="button"]',
      D = '[data-toggle="buttons"]',
      I = 'input:not([type="hidden"])',
      A = ".active",
      O = ".btn",
      N = {
    CLICK_DATA_API: "click" + y + E,
    FOCUS_BLUR_DATA_API: "focus" + y + E + " blur" + y + E
  },
      k = function () {
    function n(t) {
      this._element = t;
    }

    var t = n.prototype;
    return t.toggle = function () {
      var t = !0,
          e = !0,
          n = p(this._element).closest(D)[0];

      if (n) {
        var i = this._element.querySelector(I);

        if (i) {
          if ("radio" === i.type) if (i.checked && this._element.classList.contains(w)) t = !1;else {
            var o = n.querySelector(A);
            o && p(o).removeClass(w);
          }

          if (t) {
            if (i.hasAttribute("disabled") || n.hasAttribute("disabled") || i.classList.contains("disabled") || n.classList.contains("disabled")) return;
            i.checked = !this._element.classList.contains(w), p(i).trigger("change");
          }

          i.focus(), e = !1;
        }
      }

      e && this._element.setAttribute("aria-pressed", !this._element.classList.contains(w)), t && p(this._element).toggleClass(w);
    }, t.dispose = function () {
      p.removeData(this._element, v), this._element = null;
    }, n._jQueryInterface = function (e) {
      return this.each(function () {
        var t = p(this).data(v);
        t || (t = new n(this), p(this).data(v, t)), "toggle" === e && t[e]();
      });
    }, s(n, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }]), n;
  }();

  p(document).on(N.CLICK_DATA_API, S, function (t) {
    t.preventDefault();
    var e = t.target;
    p(e).hasClass(T) || (e = p(e).closest(O)), k._jQueryInterface.call(p(e), "toggle");
  }).on(N.FOCUS_BLUR_DATA_API, S, function (t) {
    var e = p(t.target).closest(O)[0];
    p(e).toggleClass(C, /^focus(in)?$/.test(t.type));
  }), p.fn[_] = k._jQueryInterface, p.fn[_].Constructor = k, p.fn[_].noConflict = function () {
    return p.fn[_] = b, k._jQueryInterface;
  };

  var L = "carousel",
      P = "bs.carousel",
      x = "." + P,
      H = ".data-api",
      j = p.fn[L],
      R = {
    interval: 5e3,
    keyboard: !0,
    slide: !1,
    pause: "hover",
    wrap: !0,
    touch: !0
  },
      F = {
    interval: "(number|boolean)",
    keyboard: "boolean",
    slide: "(boolean|string)",
    pause: "(string|boolean)",
    wrap: "boolean",
    touch: "boolean"
  },
      M = "next",
      W = "prev",
      U = "left",
      B = "right",
      q = {
    SLIDE: "slide" + x,
    SLID: "slid" + x,
    KEYDOWN: "keydown" + x,
    MOUSEENTER: "mouseenter" + x,
    MOUSELEAVE: "mouseleave" + x,
    TOUCHSTART: "touchstart" + x,
    TOUCHMOVE: "touchmove" + x,
    TOUCHEND: "touchend" + x,
    POINTERDOWN: "pointerdown" + x,
    POINTERUP: "pointerup" + x,
    DRAG_START: "dragstart" + x,
    LOAD_DATA_API: "load" + x + H,
    CLICK_DATA_API: "click" + x + H
  },
      K = "carousel",
      Q = "active",
      Y = "slide",
      V = "carousel-item-right",
      X = "carousel-item-left",
      z = "carousel-item-next",
      G = "carousel-item-prev",
      J = "pointer-event",
      Z = ".active",
      $ = ".active.carousel-item",
      tt = ".carousel-item",
      et = ".carousel-item img",
      nt = ".carousel-item-next, .carousel-item-prev",
      it = ".carousel-indicators",
      ot = "[data-slide], [data-slide-to]",
      rt = '[data-ride="carousel"]',
      st = {
    TOUCH: "touch",
    PEN: "pen"
  },
      at = function () {
    function r(t, e) {
      this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._element = t, this._indicatorsElement = this._element.querySelector(it), this._touchSupported = "ontouchstart" in document.documentElement || 0 < navigator.maxTouchPoints, this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent), this._addEventListeners();
    }

    var t = r.prototype;
    return t.next = function () {
      this._isSliding || this._slide(M);
    }, t.nextWhenVisible = function () {
      !document.hidden && p(this._element).is(":visible") && "hidden" !== p(this._element).css("visibility") && this.next();
    }, t.prev = function () {
      this._isSliding || this._slide(W);
    }, t.pause = function (t) {
      t || (this._isPaused = !0), this._element.querySelector(nt) && (m.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;
    }, t.cycle = function (t) {
      t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));
    }, t.to = function (t) {
      var e = this;
      this._activeElement = this._element.querySelector($);

      var n = this._getItemIndex(this._activeElement);

      if (!(t > this._items.length - 1 || t < 0)) if (this._isSliding) p(this._element).one(q.SLID, function () {
        return e.to(t);
      });else {
        if (n === t) return this.pause(), void this.cycle();
        var i = n < t ? M : W;

        this._slide(i, this._items[t]);
      }
    }, t.dispose = function () {
      p(this._element).off(x), p.removeData(this._element, P), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null;
    }, t._getConfig = function (t) {
      return t = l({}, R, t), m.typeCheckConfig(L, t, F), t;
    }, t._handleSwipe = function () {
      var t = Math.abs(this.touchDeltaX);

      if (!(t <= 40)) {
        var e = t / this.touchDeltaX;
        0 < e && this.prev(), e < 0 && this.next();
      }
    }, t._addEventListeners = function () {
      var e = this;
      this._config.keyboard && p(this._element).on(q.KEYDOWN, function (t) {
        return e._keydown(t);
      }), "hover" === this._config.pause && p(this._element).on(q.MOUSEENTER, function (t) {
        return e.pause(t);
      }).on(q.MOUSELEAVE, function (t) {
        return e.cycle(t);
      }), this._addTouchEventListeners();
    }, t._addTouchEventListeners = function () {
      var n = this;

      if (this._touchSupported) {
        var e = function e(t) {
          n._pointerEvent && st[t.originalEvent.pointerType.toUpperCase()] ? n.touchStartX = t.originalEvent.clientX : n._pointerEvent || (n.touchStartX = t.originalEvent.touches[0].clientX);
        },
            i = function i(t) {
          n._pointerEvent && st[t.originalEvent.pointerType.toUpperCase()] && (n.touchDeltaX = t.originalEvent.clientX - n.touchStartX), n._handleSwipe(), "hover" === n._config.pause && (n.pause(), n.touchTimeout && clearTimeout(n.touchTimeout), n.touchTimeout = setTimeout(function (t) {
            return n.cycle(t);
          }, 500 + n._config.interval));
        };

        p(this._element.querySelectorAll(et)).on(q.DRAG_START, function (t) {
          return t.preventDefault();
        }), this._pointerEvent ? (p(this._element).on(q.POINTERDOWN, function (t) {
          return e(t);
        }), p(this._element).on(q.POINTERUP, function (t) {
          return i(t);
        }), this._element.classList.add(J)) : (p(this._element).on(q.TOUCHSTART, function (t) {
          return e(t);
        }), p(this._element).on(q.TOUCHMOVE, function (t) {
          var e;
          (e = t).originalEvent.touches && 1 < e.originalEvent.touches.length ? n.touchDeltaX = 0 : n.touchDeltaX = e.originalEvent.touches[0].clientX - n.touchStartX;
        }), p(this._element).on(q.TOUCHEND, function (t) {
          return i(t);
        }));
      }
    }, t._keydown = function (t) {
      if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) {
        case 37:
          t.preventDefault(), this.prev();
          break;

        case 39:
          t.preventDefault(), this.next();
      }
    }, t._getItemIndex = function (t) {
      return this._items = t && t.parentNode ? [].slice.call(t.parentNode.querySelectorAll(tt)) : [], this._items.indexOf(t);
    }, t._getItemByDirection = function (t, e) {
      var n = t === M,
          i = t === W,
          o = this._getItemIndex(e),
          r = this._items.length - 1;

      if ((i && 0 === o || n && o === r) && !this._config.wrap) return e;
      var s = (o + (t === W ? -1 : 1)) % this._items.length;
      return -1 === s ? this._items[this._items.length - 1] : this._items[s];
    }, t._triggerSlideEvent = function (t, e) {
      var n = this._getItemIndex(t),
          i = this._getItemIndex(this._element.querySelector($)),
          o = p.Event(q.SLIDE, {
        relatedTarget: t,
        direction: e,
        from: i,
        to: n
      });

      return p(this._element).trigger(o), o;
    }, t._setActiveIndicatorElement = function (t) {
      if (this._indicatorsElement) {
        var e = [].slice.call(this._indicatorsElement.querySelectorAll(Z));
        p(e).removeClass(Q);

        var n = this._indicatorsElement.children[this._getItemIndex(t)];

        n && p(n).addClass(Q);
      }
    }, t._slide = function (t, e) {
      var n,
          i,
          o,
          r = this,
          s = this._element.querySelector($),
          a = this._getItemIndex(s),
          l = e || s && this._getItemByDirection(t, s),
          c = this._getItemIndex(l),
          h = Boolean(this._interval);

      if (o = t === M ? (n = X, i = z, U) : (n = V, i = G, B), l && p(l).hasClass(Q)) this._isSliding = !1;else if (!this._triggerSlideEvent(l, o).isDefaultPrevented() && s && l) {
        this._isSliding = !0, h && this.pause(), this._setActiveIndicatorElement(l);
        var u = p.Event(q.SLID, {
          relatedTarget: l,
          direction: o,
          from: a,
          to: c
        });

        if (p(this._element).hasClass(Y)) {
          p(l).addClass(i), m.reflow(l), p(s).addClass(n), p(l).addClass(n);
          var f = parseInt(l.getAttribute("data-interval"), 10);
          this._config.interval = f ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, f) : this._config.defaultInterval || this._config.interval;
          var d = m.getTransitionDurationFromElement(s);
          p(s).one(m.TRANSITION_END, function () {
            p(l).removeClass(n + " " + i).addClass(Q), p(s).removeClass(Q + " " + i + " " + n), r._isSliding = !1, setTimeout(function () {
              return p(r._element).trigger(u);
            }, 0);
          }).emulateTransitionEnd(d);
        } else p(s).removeClass(Q), p(l).addClass(Q), this._isSliding = !1, p(this._element).trigger(u);

        h && this.cycle();
      }
    }, r._jQueryInterface = function (i) {
      return this.each(function () {
        var t = p(this).data(P),
            e = l({}, R, p(this).data());
        "object" == _typeof(i) && (e = l({}, e, i));
        var n = "string" == typeof i ? i : e.slide;
        if (t || (t = new r(this, e), p(this).data(P, t)), "number" == typeof i) t.to(i);else if ("string" == typeof n) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n]();
        } else e.interval && (t.pause(), t.cycle());
      });
    }, r._dataApiClickHandler = function (t) {
      var e = m.getSelectorFromElement(this);

      if (e) {
        var n = p(e)[0];

        if (n && p(n).hasClass(K)) {
          var i = l({}, p(n).data(), p(this).data()),
              o = this.getAttribute("data-slide-to");
          o && (i.interval = !1), r._jQueryInterface.call(p(n), i), o && p(n).data(P).to(o), t.preventDefault();
        }
      }
    }, s(r, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return R;
      }
    }]), r;
  }();

  p(document).on(q.CLICK_DATA_API, ot, at._dataApiClickHandler), p(window).on(q.LOAD_DATA_API, function () {
    for (var t = [].slice.call(document.querySelectorAll(rt)), e = 0, n = t.length; e < n; e++) {
      var i = p(t[e]);

      at._jQueryInterface.call(i, i.data());
    }
  }), p.fn[L] = at._jQueryInterface, p.fn[L].Constructor = at, p.fn[L].noConflict = function () {
    return p.fn[L] = j, at._jQueryInterface;
  };

  var lt = "collapse",
      ct = "bs.collapse",
      ht = "." + ct,
      ut = p.fn[lt],
      ft = {
    toggle: !0,
    parent: ""
  },
      dt = {
    toggle: "boolean",
    parent: "(string|element)"
  },
      pt = {
    SHOW: "show" + ht,
    SHOWN: "shown" + ht,
    HIDE: "hide" + ht,
    HIDDEN: "hidden" + ht,
    CLICK_DATA_API: "click" + ht + ".data-api"
  },
      mt = "show",
      gt = "collapse",
      _t = "collapsing",
      vt = "collapsed",
      yt = "width",
      Et = "height",
      bt = ".show, .collapsing",
      wt = '[data-toggle="collapse"]',
      Tt = function () {
    function a(e, t) {
      this._isTransitioning = !1, this._element = e, this._config = this._getConfig(t), this._triggerArray = [].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#' + e.id + '"],[data-toggle="collapse"][data-target="#' + e.id + '"]'));

      for (var n = [].slice.call(document.querySelectorAll(wt)), i = 0, o = n.length; i < o; i++) {
        var r = n[i],
            s = m.getSelectorFromElement(r),
            a = [].slice.call(document.querySelectorAll(s)).filter(function (t) {
          return t === e;
        });
        null !== s && 0 < a.length && (this._selector = s, this._triggerArray.push(r));
      }

      this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle();
    }

    var t = a.prototype;
    return t.toggle = function () {
      p(this._element).hasClass(mt) ? this.hide() : this.show();
    }, t.show = function () {
      var t,
          e,
          n = this;

      if (!this._isTransitioning && !p(this._element).hasClass(mt) && (this._parent && 0 === (t = [].slice.call(this._parent.querySelectorAll(bt)).filter(function (t) {
        return "string" == typeof n._config.parent ? t.getAttribute("data-parent") === n._config.parent : t.classList.contains(gt);
      })).length && (t = null), !(t && (e = p(t).not(this._selector).data(ct)) && e._isTransitioning))) {
        var i = p.Event(pt.SHOW);

        if (p(this._element).trigger(i), !i.isDefaultPrevented()) {
          t && (a._jQueryInterface.call(p(t).not(this._selector), "hide"), e || p(t).data(ct, null));

          var o = this._getDimension();

          p(this._element).removeClass(gt).addClass(_t), this._element.style[o] = 0, this._triggerArray.length && p(this._triggerArray).removeClass(vt).attr("aria-expanded", !0), this.setTransitioning(!0);
          var r = "scroll" + (o[0].toUpperCase() + o.slice(1)),
              s = m.getTransitionDurationFromElement(this._element);
          p(this._element).one(m.TRANSITION_END, function () {
            p(n._element).removeClass(_t).addClass(gt).addClass(mt), n._element.style[o] = "", n.setTransitioning(!1), p(n._element).trigger(pt.SHOWN);
          }).emulateTransitionEnd(s), this._element.style[o] = this._element[r] + "px";
        }
      }
    }, t.hide = function () {
      var t = this;

      if (!this._isTransitioning && p(this._element).hasClass(mt)) {
        var e = p.Event(pt.HIDE);

        if (p(this._element).trigger(e), !e.isDefaultPrevented()) {
          var n = this._getDimension();

          this._element.style[n] = this._element.getBoundingClientRect()[n] + "px", m.reflow(this._element), p(this._element).addClass(_t).removeClass(gt).removeClass(mt);
          var i = this._triggerArray.length;
          if (0 < i) for (var o = 0; o < i; o++) {
            var r = this._triggerArray[o],
                s = m.getSelectorFromElement(r);
            if (null !== s) p([].slice.call(document.querySelectorAll(s))).hasClass(mt) || p(r).addClass(vt).attr("aria-expanded", !1);
          }
          this.setTransitioning(!0);
          this._element.style[n] = "";
          var a = m.getTransitionDurationFromElement(this._element);
          p(this._element).one(m.TRANSITION_END, function () {
            t.setTransitioning(!1), p(t._element).removeClass(_t).addClass(gt).trigger(pt.HIDDEN);
          }).emulateTransitionEnd(a);
        }
      }
    }, t.setTransitioning = function (t) {
      this._isTransitioning = t;
    }, t.dispose = function () {
      p.removeData(this._element, ct), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null;
    }, t._getConfig = function (t) {
      return (t = l({}, ft, t)).toggle = Boolean(t.toggle), m.typeCheckConfig(lt, t, dt), t;
    }, t._getDimension = function () {
      return p(this._element).hasClass(yt) ? yt : Et;
    }, t._getParent = function () {
      var t,
          n = this;
      m.isElement(this._config.parent) ? (t = this._config.parent, "undefined" != typeof this._config.parent.jquery && (t = this._config.parent[0])) : t = document.querySelector(this._config.parent);
      var e = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]',
          i = [].slice.call(t.querySelectorAll(e));
      return p(i).each(function (t, e) {
        n._addAriaAndCollapsedClass(a._getTargetFromElement(e), [e]);
      }), t;
    }, t._addAriaAndCollapsedClass = function (t, e) {
      var n = p(t).hasClass(mt);
      e.length && p(e).toggleClass(vt, !n).attr("aria-expanded", n);
    }, a._getTargetFromElement = function (t) {
      var e = m.getSelectorFromElement(t);
      return e ? document.querySelector(e) : null;
    }, a._jQueryInterface = function (i) {
      return this.each(function () {
        var t = p(this),
            e = t.data(ct),
            n = l({}, ft, t.data(), "object" == _typeof(i) && i ? i : {});

        if (!e && n.toggle && /show|hide/.test(i) && (n.toggle = !1), e || (e = new a(this, n), t.data(ct, e)), "string" == typeof i) {
          if ("undefined" == typeof e[i]) throw new TypeError('No method named "' + i + '"');
          e[i]();
        }
      });
    }, s(a, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return ft;
      }
    }]), a;
  }();

  p(document).on(pt.CLICK_DATA_API, wt, function (t) {
    "A" === t.currentTarget.tagName && t.preventDefault();
    var n = p(this),
        e = m.getSelectorFromElement(this),
        i = [].slice.call(document.querySelectorAll(e));
    p(i).each(function () {
      var t = p(this),
          e = t.data(ct) ? "toggle" : n.data();

      Tt._jQueryInterface.call(t, e);
    });
  }), p.fn[lt] = Tt._jQueryInterface, p.fn[lt].Constructor = Tt, p.fn[lt].noConflict = function () {
    return p.fn[lt] = ut, Tt._jQueryInterface;
  };

  for (var Ct = "undefined" != typeof window && "undefined" != typeof document, St = ["Edge", "Trident", "Firefox"], Dt = 0, It = 0; It < St.length; It += 1) {
    if (Ct && 0 <= navigator.userAgent.indexOf(St[It])) {
      Dt = 1;
      break;
    }
  }

  var At = Ct && window.Promise ? function (t) {
    var e = !1;
    return function () {
      e || (e = !0, window.Promise.resolve().then(function () {
        e = !1, t();
      }));
    };
  } : function (t) {
    var e = !1;
    return function () {
      e || (e = !0, setTimeout(function () {
        e = !1, t();
      }, Dt));
    };
  };

  function Ot(t) {
    return t && "[object Function]" === {}.toString.call(t);
  }

  function Nt(t, e) {
    if (1 !== t.nodeType) return [];
    var n = t.ownerDocument.defaultView.getComputedStyle(t, null);
    return e ? n[e] : n;
  }

  function kt(t) {
    return "HTML" === t.nodeName ? t : t.parentNode || t.host;
  }

  function Lt(t) {
    if (!t) return document.body;

    switch (t.nodeName) {
      case "HTML":
      case "BODY":
        return t.ownerDocument.body;

      case "#document":
        return t.body;
    }

    var e = Nt(t),
        n = e.overflow,
        i = e.overflowX,
        o = e.overflowY;
    return /(auto|scroll|overlay)/.test(n + o + i) ? t : Lt(kt(t));
  }

  var Pt = Ct && !(!window.MSInputMethodContext || !document.documentMode),
      xt = Ct && /MSIE 10/.test(navigator.userAgent);

  function Ht(t) {
    return 11 === t ? Pt : 10 === t ? xt : Pt || xt;
  }

  function jt(t) {
    if (!t) return document.documentElement;

    for (var e = Ht(10) ? document.body : null, n = t.offsetParent || null; n === e && t.nextElementSibling;) {
      n = (t = t.nextElementSibling).offsetParent;
    }

    var i = n && n.nodeName;
    return i && "BODY" !== i && "HTML" !== i ? -1 !== ["TH", "TD", "TABLE"].indexOf(n.nodeName) && "static" === Nt(n, "position") ? jt(n) : n : t ? t.ownerDocument.documentElement : document.documentElement;
  }

  function Rt(t) {
    return null !== t.parentNode ? Rt(t.parentNode) : t;
  }

  function Ft(t, e) {
    if (!(t && t.nodeType && e && e.nodeType)) return document.documentElement;
    var n = t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING,
        i = n ? t : e,
        o = n ? e : t,
        r = document.createRange();
    r.setStart(i, 0), r.setEnd(o, 0);
    var s,
        a,
        l = r.commonAncestorContainer;
    if (t !== l && e !== l || i.contains(o)) return "BODY" === (a = (s = l).nodeName) || "HTML" !== a && jt(s.firstElementChild) !== s ? jt(l) : l;
    var c = Rt(t);
    return c.host ? Ft(c.host, e) : Ft(t, Rt(e).host);
  }

  function Mt(t) {
    var e = "top" === (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "top") ? "scrollTop" : "scrollLeft",
        n = t.nodeName;
    if ("BODY" !== n && "HTML" !== n) return t[e];
    var i = t.ownerDocument.documentElement;
    return (t.ownerDocument.scrollingElement || i)[e];
  }

  function Wt(t, e) {
    var n = "x" === e ? "Left" : "Top",
        i = "Left" === n ? "Right" : "Bottom";
    return parseFloat(t["border" + n + "Width"], 10) + parseFloat(t["border" + i + "Width"], 10);
  }

  function Ut(t, e, n, i) {
    return Math.max(e["offset" + t], e["scroll" + t], n["client" + t], n["offset" + t], n["scroll" + t], Ht(10) ? parseInt(n["offset" + t]) + parseInt(i["margin" + ("Height" === t ? "Top" : "Left")]) + parseInt(i["margin" + ("Height" === t ? "Bottom" : "Right")]) : 0);
  }

  function Bt(t) {
    var e = t.body,
        n = t.documentElement,
        i = Ht(10) && getComputedStyle(n);
    return {
      height: Ut("Height", e, n, i),
      width: Ut("Width", e, n, i)
    };
  }

  var qt = function () {
    function i(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
      }
    }

    return function (t, e, n) {
      return e && i(t.prototype, e), n && i(t, n), t;
    };
  }(),
      Kt = function Kt(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : t[e] = n, t;
  },
      Qt = Object.assign || function (t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];

      for (var i in n) {
        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
      }
    }

    return t;
  };

  function Yt(t) {
    return Qt({}, t, {
      right: t.left + t.width,
      bottom: t.top + t.height
    });
  }

  function Vt(t) {
    var e = {};

    try {
      if (Ht(10)) {
        e = t.getBoundingClientRect();
        var n = Mt(t, "top"),
            i = Mt(t, "left");
        e.top += n, e.left += i, e.bottom += n, e.right += i;
      } else e = t.getBoundingClientRect();
    } catch (t) {}

    var o = {
      left: e.left,
      top: e.top,
      width: e.right - e.left,
      height: e.bottom - e.top
    },
        r = "HTML" === t.nodeName ? Bt(t.ownerDocument) : {},
        s = r.width || t.clientWidth || o.right - o.left,
        a = r.height || t.clientHeight || o.bottom - o.top,
        l = t.offsetWidth - s,
        c = t.offsetHeight - a;

    if (l || c) {
      var h = Nt(t);
      l -= Wt(h, "x"), c -= Wt(h, "y"), o.width -= l, o.height -= c;
    }

    return Yt(o);
  }

  function Xt(t, e) {
    var n = 2 < arguments.length && void 0 !== arguments[2] && arguments[2],
        i = Ht(10),
        o = "HTML" === e.nodeName,
        r = Vt(t),
        s = Vt(e),
        a = Lt(t),
        l = Nt(e),
        c = parseFloat(l.borderTopWidth, 10),
        h = parseFloat(l.borderLeftWidth, 10);
    n && o && (s.top = Math.max(s.top, 0), s.left = Math.max(s.left, 0));
    var u = Yt({
      top: r.top - s.top - c,
      left: r.left - s.left - h,
      width: r.width,
      height: r.height
    });

    if (u.marginTop = 0, u.marginLeft = 0, !i && o) {
      var f = parseFloat(l.marginTop, 10),
          d = parseFloat(l.marginLeft, 10);
      u.top -= c - f, u.bottom -= c - f, u.left -= h - d, u.right -= h - d, u.marginTop = f, u.marginLeft = d;
    }

    return (i && !n ? e.contains(a) : e === a && "BODY" !== a.nodeName) && (u = function (t, e) {
      var n = 2 < arguments.length && void 0 !== arguments[2] && arguments[2],
          i = Mt(e, "top"),
          o = Mt(e, "left"),
          r = n ? -1 : 1;
      return t.top += i * r, t.bottom += i * r, t.left += o * r, t.right += o * r, t;
    }(u, e)), u;
  }

  function zt(t) {
    if (!t || !t.parentElement || Ht()) return document.documentElement;

    for (var e = t.parentElement; e && "none" === Nt(e, "transform");) {
      e = e.parentElement;
    }

    return e || document.documentElement;
  }

  function Gt(t, e, n, i) {
    var o = 4 < arguments.length && void 0 !== arguments[4] && arguments[4],
        r = {
      top: 0,
      left: 0
    },
        s = o ? zt(t) : Ft(t, e);
    if ("viewport" === i) r = function (t) {
      var e = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
          n = t.ownerDocument.documentElement,
          i = Xt(t, n),
          o = Math.max(n.clientWidth, window.innerWidth || 0),
          r = Math.max(n.clientHeight, window.innerHeight || 0),
          s = e ? 0 : Mt(n),
          a = e ? 0 : Mt(n, "left");
      return Yt({
        top: s - i.top + i.marginTop,
        left: a - i.left + i.marginLeft,
        width: o,
        height: r
      });
    }(s, o);else {
      var a = void 0;
      "scrollParent" === i ? "BODY" === (a = Lt(kt(e))).nodeName && (a = t.ownerDocument.documentElement) : a = "window" === i ? t.ownerDocument.documentElement : i;
      var l = Xt(a, s, o);
      if ("HTML" !== a.nodeName || function t(e) {
        var n = e.nodeName;
        return "BODY" !== n && "HTML" !== n && ("fixed" === Nt(e, "position") || t(kt(e)));
      }(s)) r = l;else {
        var c = Bt(t.ownerDocument),
            h = c.height,
            u = c.width;
        r.top += l.top - l.marginTop, r.bottom = h + l.top, r.left += l.left - l.marginLeft, r.right = u + l.left;
      }
    }
    var f = "number" == typeof (n = n || 0);
    return r.left += f ? n : n.left || 0, r.top += f ? n : n.top || 0, r.right -= f ? n : n.right || 0, r.bottom -= f ? n : n.bottom || 0, r;
  }

  function Jt(t, e, i, n, o) {
    var r = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0;
    if (-1 === t.indexOf("auto")) return t;
    var s = Gt(i, n, r, o),
        a = {
      top: {
        width: s.width,
        height: e.top - s.top
      },
      right: {
        width: s.right - e.right,
        height: s.height
      },
      bottom: {
        width: s.width,
        height: s.bottom - e.bottom
      },
      left: {
        width: e.left - s.left,
        height: s.height
      }
    },
        l = Object.keys(a).map(function (t) {
      return Qt({
        key: t
      }, a[t], {
        area: (e = a[t], e.width * e.height)
      });
      var e;
    }).sort(function (t, e) {
      return e.area - t.area;
    }),
        c = l.filter(function (t) {
      var e = t.width,
          n = t.height;
      return e >= i.clientWidth && n >= i.clientHeight;
    }),
        h = 0 < c.length ? c[0].key : l[0].key,
        u = t.split("-")[1];
    return h + (u ? "-" + u : "");
  }

  function Zt(t, e, n) {
    var i = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return Xt(n, i ? zt(e) : Ft(e, n), i);
  }

  function $t(t) {
    var e = t.ownerDocument.defaultView.getComputedStyle(t),
        n = parseFloat(e.marginTop || 0) + parseFloat(e.marginBottom || 0),
        i = parseFloat(e.marginLeft || 0) + parseFloat(e.marginRight || 0);
    return {
      width: t.offsetWidth + i,
      height: t.offsetHeight + n
    };
  }

  function te(t) {
    var e = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    return t.replace(/left|right|bottom|top/g, function (t) {
      return e[t];
    });
  }

  function ee(t, e, n) {
    n = n.split("-")[0];
    var i = $t(t),
        o = {
      width: i.width,
      height: i.height
    },
        r = -1 !== ["right", "left"].indexOf(n),
        s = r ? "top" : "left",
        a = r ? "left" : "top",
        l = r ? "height" : "width",
        c = r ? "width" : "height";
    return o[s] = e[s] + e[l] / 2 - i[l] / 2, o[a] = n === a ? e[a] - i[c] : e[te(a)], o;
  }

  function ne(t, e) {
    return Array.prototype.find ? t.find(e) : t.filter(e)[0];
  }

  function ie(t, n, e) {
    return (void 0 === e ? t : t.slice(0, function (t, e, n) {
      if (Array.prototype.findIndex) return t.findIndex(function (t) {
        return t[e] === n;
      });
      var i = ne(t, function (t) {
        return t[e] === n;
      });
      return t.indexOf(i);
    }(t, "name", e))).forEach(function (t) {
      t.function && console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
      var e = t.function || t.fn;
      t.enabled && Ot(e) && (n.offsets.popper = Yt(n.offsets.popper), n.offsets.reference = Yt(n.offsets.reference), n = e(n, t));
    }), n;
  }

  function oe(t, n) {
    return t.some(function (t) {
      var e = t.name;
      return t.enabled && e === n;
    });
  }

  function re(t) {
    for (var e = [!1, "ms", "Webkit", "Moz", "O"], n = t.charAt(0).toUpperCase() + t.slice(1), i = 0; i < e.length; i++) {
      var o = e[i],
          r = o ? "" + o + n : t;
      if ("undefined" != typeof document.body.style[r]) return r;
    }

    return null;
  }

  function se(t) {
    var e = t.ownerDocument;
    return e ? e.defaultView : window;
  }

  function ae(t, e, n, i) {
    n.updateBound = i, se(t).addEventListener("resize", n.updateBound, {
      passive: !0
    });
    var o = Lt(t);
    return function t(e, n, i, o) {
      var r = "BODY" === e.nodeName,
          s = r ? e.ownerDocument.defaultView : e;
      s.addEventListener(n, i, {
        passive: !0
      }), r || t(Lt(s.parentNode), n, i, o), o.push(s);
    }(o, "scroll", n.updateBound, n.scrollParents), n.scrollElement = o, n.eventsEnabled = !0, n;
  }

  function le() {
    var t, e;
    this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = (t = this.reference, e = this.state, se(t).removeEventListener("resize", e.updateBound), e.scrollParents.forEach(function (t) {
      t.removeEventListener("scroll", e.updateBound);
    }), e.updateBound = null, e.scrollParents = [], e.scrollElement = null, e.eventsEnabled = !1, e));
  }

  function ce(t) {
    return "" !== t && !isNaN(parseFloat(t)) && isFinite(t);
  }

  function he(n, i) {
    Object.keys(i).forEach(function (t) {
      var e = "";
      -1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(t) && ce(i[t]) && (e = "px"), n.style[t] = i[t] + e;
    });
  }

  var ue = Ct && /Firefox/i.test(navigator.userAgent);

  function fe(t, e, n) {
    var i = ne(t, function (t) {
      return t.name === e;
    }),
        o = !!i && t.some(function (t) {
      return t.name === n && t.enabled && t.order < i.order;
    });

    if (!o) {
      var r = "`" + e + "`",
          s = "`" + n + "`";
      console.warn(s + " modifier is required by " + r + " modifier in order to work, be sure to include it before " + r + "!");
    }

    return o;
  }

  var de = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"],
      pe = de.slice(3);

  function me(t) {
    var e = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
        n = pe.indexOf(t),
        i = pe.slice(n + 1).concat(pe.slice(0, n));
    return e ? i.reverse() : i;
  }

  var ge = "flip",
      _e = "clockwise",
      ve = "counterclockwise";

  function ye(t, o, r, e) {
    var s = [0, 0],
        a = -1 !== ["right", "left"].indexOf(e),
        n = t.split(/(\+|\-)/).map(function (t) {
      return t.trim();
    }),
        i = n.indexOf(ne(n, function (t) {
      return -1 !== t.search(/,|\s/);
    }));
    n[i] && -1 === n[i].indexOf(",") && console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
    var l = /\s*,\s*|\s+/,
        c = -1 !== i ? [n.slice(0, i).concat([n[i].split(l)[0]]), [n[i].split(l)[1]].concat(n.slice(i + 1))] : [n];
    return (c = c.map(function (t, e) {
      var n = (1 === e ? !a : a) ? "height" : "width",
          i = !1;
      return t.reduce(function (t, e) {
        return "" === t[t.length - 1] && -1 !== ["+", "-"].indexOf(e) ? (t[t.length - 1] = e, i = !0, t) : i ? (t[t.length - 1] += e, i = !1, t) : t.concat(e);
      }, []).map(function (t) {
        return function (t, e, n, i) {
          var o = t.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),
              r = +o[1],
              s = o[2];
          if (!r) return t;
          if (0 !== s.indexOf("%")) return "vh" !== s && "vw" !== s ? r : ("vh" === s ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * r;
          var a = void 0;

          switch (s) {
            case "%p":
              a = n;
              break;

            case "%":
            case "%r":
            default:
              a = i;
          }

          return Yt(a)[e] / 100 * r;
        }(t, n, o, r);
      });
    })).forEach(function (n, i) {
      n.forEach(function (t, e) {
        ce(t) && (s[i] += t * ("-" === n[e - 1] ? -1 : 1));
      });
    }), s;
  }

  var Ee = {
    placement: "bottom",
    positionFixed: !1,
    eventsEnabled: !0,
    removeOnDestroy: !1,
    onCreate: function onCreate() {},
    onUpdate: function onUpdate() {},
    modifiers: {
      shift: {
        order: 100,
        enabled: !0,
        fn: function fn(t) {
          var e = t.placement,
              n = e.split("-")[0],
              i = e.split("-")[1];

          if (i) {
            var o = t.offsets,
                r = o.reference,
                s = o.popper,
                a = -1 !== ["bottom", "top"].indexOf(n),
                l = a ? "left" : "top",
                c = a ? "width" : "height",
                h = {
              start: Kt({}, l, r[l]),
              end: Kt({}, l, r[l] + r[c] - s[c])
            };
            t.offsets.popper = Qt({}, s, h[i]);
          }

          return t;
        }
      },
      offset: {
        order: 200,
        enabled: !0,
        fn: function fn(t, e) {
          var n = e.offset,
              i = t.placement,
              o = t.offsets,
              r = o.popper,
              s = o.reference,
              a = i.split("-")[0],
              l = void 0;
          return l = ce(+n) ? [+n, 0] : ye(n, r, s, a), "left" === a ? (r.top += l[0], r.left -= l[1]) : "right" === a ? (r.top += l[0], r.left += l[1]) : "top" === a ? (r.left += l[0], r.top -= l[1]) : "bottom" === a && (r.left += l[0], r.top += l[1]), t.popper = r, t;
        },
        offset: 0
      },
      preventOverflow: {
        order: 300,
        enabled: !0,
        fn: function fn(t, i) {
          var e = i.boundariesElement || jt(t.instance.popper);
          t.instance.reference === e && (e = jt(e));
          var n = re("transform"),
              o = t.instance.popper.style,
              r = o.top,
              s = o.left,
              a = o[n];
          o.top = "", o.left = "", o[n] = "";
          var l = Gt(t.instance.popper, t.instance.reference, i.padding, e, t.positionFixed);
          o.top = r, o.left = s, o[n] = a, i.boundaries = l;
          var c = i.priority,
              h = t.offsets.popper,
              u = {
            primary: function primary(t) {
              var e = h[t];
              return h[t] < l[t] && !i.escapeWithReference && (e = Math.max(h[t], l[t])), Kt({}, t, e);
            },
            secondary: function secondary(t) {
              var e = "right" === t ? "left" : "top",
                  n = h[e];
              return h[t] > l[t] && !i.escapeWithReference && (n = Math.min(h[e], l[t] - ("right" === t ? h.width : h.height))), Kt({}, e, n);
            }
          };
          return c.forEach(function (t) {
            var e = -1 !== ["left", "top"].indexOf(t) ? "primary" : "secondary";
            h = Qt({}, h, u[e](t));
          }), t.offsets.popper = h, t;
        },
        priority: ["left", "right", "top", "bottom"],
        padding: 5,
        boundariesElement: "scrollParent"
      },
      keepTogether: {
        order: 400,
        enabled: !0,
        fn: function fn(t) {
          var e = t.offsets,
              n = e.popper,
              i = e.reference,
              o = t.placement.split("-")[0],
              r = Math.floor,
              s = -1 !== ["top", "bottom"].indexOf(o),
              a = s ? "right" : "bottom",
              l = s ? "left" : "top",
              c = s ? "width" : "height";
          return n[a] < r(i[l]) && (t.offsets.popper[l] = r(i[l]) - n[c]), n[l] > r(i[a]) && (t.offsets.popper[l] = r(i[a])), t;
        }
      },
      arrow: {
        order: 500,
        enabled: !0,
        fn: function fn(t, e) {
          var n;
          if (!fe(t.instance.modifiers, "arrow", "keepTogether")) return t;
          var i = e.element;

          if ("string" == typeof i) {
            if (!(i = t.instance.popper.querySelector(i))) return t;
          } else if (!t.instance.popper.contains(i)) return console.warn("WARNING: `arrow.element` must be child of its popper element!"), t;

          var o = t.placement.split("-")[0],
              r = t.offsets,
              s = r.popper,
              a = r.reference,
              l = -1 !== ["left", "right"].indexOf(o),
              c = l ? "height" : "width",
              h = l ? "Top" : "Left",
              u = h.toLowerCase(),
              f = l ? "left" : "top",
              d = l ? "bottom" : "right",
              p = $t(i)[c];
          a[d] - p < s[u] && (t.offsets.popper[u] -= s[u] - (a[d] - p)), a[u] + p > s[d] && (t.offsets.popper[u] += a[u] + p - s[d]), t.offsets.popper = Yt(t.offsets.popper);

          var m = a[u] + a[c] / 2 - p / 2,
              g = Nt(t.instance.popper),
              _ = parseFloat(g["margin" + h], 10),
              v = parseFloat(g["border" + h + "Width"], 10),
              y = m - t.offsets.popper[u] - _ - v;

          return y = Math.max(Math.min(s[c] - p, y), 0), t.arrowElement = i, t.offsets.arrow = (Kt(n = {}, u, Math.round(y)), Kt(n, f, ""), n), t;
        },
        element: "[x-arrow]"
      },
      flip: {
        order: 600,
        enabled: !0,
        fn: function fn(p, m) {
          if (oe(p.instance.modifiers, "inner")) return p;
          if (p.flipped && p.placement === p.originalPlacement) return p;
          var g = Gt(p.instance.popper, p.instance.reference, m.padding, m.boundariesElement, p.positionFixed),
              _ = p.placement.split("-")[0],
              v = te(_),
              y = p.placement.split("-")[1] || "",
              E = [];

          switch (m.behavior) {
            case ge:
              E = [_, v];
              break;

            case _e:
              E = me(_);
              break;

            case ve:
              E = me(_, !0);
              break;

            default:
              E = m.behavior;
          }

          return E.forEach(function (t, e) {
            if (_ !== t || E.length === e + 1) return p;
            _ = p.placement.split("-")[0], v = te(_);
            var n,
                i = p.offsets.popper,
                o = p.offsets.reference,
                r = Math.floor,
                s = "left" === _ && r(i.right) > r(o.left) || "right" === _ && r(i.left) < r(o.right) || "top" === _ && r(i.bottom) > r(o.top) || "bottom" === _ && r(i.top) < r(o.bottom),
                a = r(i.left) < r(g.left),
                l = r(i.right) > r(g.right),
                c = r(i.top) < r(g.top),
                h = r(i.bottom) > r(g.bottom),
                u = "left" === _ && a || "right" === _ && l || "top" === _ && c || "bottom" === _ && h,
                f = -1 !== ["top", "bottom"].indexOf(_),
                d = !!m.flipVariations && (f && "start" === y && a || f && "end" === y && l || !f && "start" === y && c || !f && "end" === y && h);
            (s || u || d) && (p.flipped = !0, (s || u) && (_ = E[e + 1]), d && (y = "end" === (n = y) ? "start" : "start" === n ? "end" : n), p.placement = _ + (y ? "-" + y : ""), p.offsets.popper = Qt({}, p.offsets.popper, ee(p.instance.popper, p.offsets.reference, p.placement)), p = ie(p.instance.modifiers, p, "flip"));
          }), p;
        },
        behavior: "flip",
        padding: 5,
        boundariesElement: "viewport"
      },
      inner: {
        order: 700,
        enabled: !1,
        fn: function fn(t) {
          var e = t.placement,
              n = e.split("-")[0],
              i = t.offsets,
              o = i.popper,
              r = i.reference,
              s = -1 !== ["left", "right"].indexOf(n),
              a = -1 === ["top", "left"].indexOf(n);
          return o[s ? "left" : "top"] = r[n] - (a ? o[s ? "width" : "height"] : 0), t.placement = te(e), t.offsets.popper = Yt(o), t;
        }
      },
      hide: {
        order: 800,
        enabled: !0,
        fn: function fn(t) {
          if (!fe(t.instance.modifiers, "hide", "preventOverflow")) return t;
          var e = t.offsets.reference,
              n = ne(t.instance.modifiers, function (t) {
            return "preventOverflow" === t.name;
          }).boundaries;

          if (e.bottom < n.top || e.left > n.right || e.top > n.bottom || e.right < n.left) {
            if (!0 === t.hide) return t;
            t.hide = !0, t.attributes["x-out-of-boundaries"] = "";
          } else {
            if (!1 === t.hide) return t;
            t.hide = !1, t.attributes["x-out-of-boundaries"] = !1;
          }

          return t;
        }
      },
      computeStyle: {
        order: 850,
        enabled: !0,
        fn: function fn(t, e) {
          var n = e.x,
              i = e.y,
              o = t.offsets.popper,
              r = ne(t.instance.modifiers, function (t) {
            return "applyStyle" === t.name;
          }).gpuAcceleration;
          void 0 !== r && console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");

          var s,
              a,
              l,
              c,
              h,
              u,
              f,
              d,
              p,
              m,
              g,
              _,
              v = void 0 !== r ? r : e.gpuAcceleration,
              y = jt(t.instance.popper),
              E = Vt(y),
              b = {
            position: o.position
          },
              w = (s = t, a = window.devicePixelRatio < 2 || !ue, l = s.offsets, c = l.popper, h = l.reference, u = -1 !== ["left", "right"].indexOf(s.placement), f = -1 !== s.placement.indexOf("-"), d = h.width % 2 == c.width % 2, p = h.width % 2 == 1 && c.width % 2 == 1, m = function m(t) {
            return t;
          }, g = a ? u || f || d ? Math.round : Math.floor : m, _ = a ? Math.round : m, {
            left: g(p && !f && a ? c.left - 1 : c.left),
            top: _(c.top),
            bottom: _(c.bottom),
            right: g(c.right)
          }),
              T = "bottom" === n ? "top" : "bottom",
              C = "right" === i ? "left" : "right",
              S = re("transform"),
              D = void 0,
              I = void 0;

          if (I = "bottom" === T ? "HTML" === y.nodeName ? -y.clientHeight + w.bottom : -E.height + w.bottom : w.top, D = "right" === C ? "HTML" === y.nodeName ? -y.clientWidth + w.right : -E.width + w.right : w.left, v && S) b[S] = "translate3d(" + D + "px, " + I + "px, 0)", b[T] = 0, b[C] = 0, b.willChange = "transform";else {
            var A = "bottom" === T ? -1 : 1,
                O = "right" === C ? -1 : 1;
            b[T] = I * A, b[C] = D * O, b.willChange = T + ", " + C;
          }
          var N = {
            "x-placement": t.placement
          };
          return t.attributes = Qt({}, N, t.attributes), t.styles = Qt({}, b, t.styles), t.arrowStyles = Qt({}, t.offsets.arrow, t.arrowStyles), t;
        },
        gpuAcceleration: !0,
        x: "bottom",
        y: "right"
      },
      applyStyle: {
        order: 900,
        enabled: !0,
        fn: function fn(t) {
          var e, n;
          return he(t.instance.popper, t.styles), e = t.instance.popper, n = t.attributes, Object.keys(n).forEach(function (t) {
            !1 !== n[t] ? e.setAttribute(t, n[t]) : e.removeAttribute(t);
          }), t.arrowElement && Object.keys(t.arrowStyles).length && he(t.arrowElement, t.arrowStyles), t;
        },
        onLoad: function onLoad(t, e, n, i, o) {
          var r = Zt(o, e, t, n.positionFixed),
              s = Jt(n.placement, r, e, t, n.modifiers.flip.boundariesElement, n.modifiers.flip.padding);
          return e.setAttribute("x-placement", s), he(e, {
            position: n.positionFixed ? "fixed" : "absolute"
          }), n;
        },
        gpuAcceleration: void 0
      }
    }
  },
      be = function () {
    function r(t, e) {
      var n = this,
          i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
      !function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
      }(this, r), this.scheduleUpdate = function () {
        return requestAnimationFrame(n.update);
      }, this.update = At(this.update.bind(this)), this.options = Qt({}, r.Defaults, i), this.state = {
        isDestroyed: !1,
        isCreated: !1,
        scrollParents: []
      }, this.reference = t && t.jquery ? t[0] : t, this.popper = e && e.jquery ? e[0] : e, this.options.modifiers = {}, Object.keys(Qt({}, r.Defaults.modifiers, i.modifiers)).forEach(function (t) {
        n.options.modifiers[t] = Qt({}, r.Defaults.modifiers[t] || {}, i.modifiers ? i.modifiers[t] : {});
      }), this.modifiers = Object.keys(this.options.modifiers).map(function (t) {
        return Qt({
          name: t
        }, n.options.modifiers[t]);
      }).sort(function (t, e) {
        return t.order - e.order;
      }), this.modifiers.forEach(function (t) {
        t.enabled && Ot(t.onLoad) && t.onLoad(n.reference, n.popper, n.options, t, n.state);
      }), this.update();
      var o = this.options.eventsEnabled;
      o && this.enableEventListeners(), this.state.eventsEnabled = o;
    }

    return qt(r, [{
      key: "update",
      value: function value() {
        return function () {
          if (!this.state.isDestroyed) {
            var t = {
              instance: this,
              styles: {},
              arrowStyles: {},
              attributes: {},
              flipped: !1,
              offsets: {}
            };
            t.offsets.reference = Zt(this.state, this.popper, this.reference, this.options.positionFixed), t.placement = Jt(this.options.placement, t.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), t.originalPlacement = t.placement, t.positionFixed = this.options.positionFixed, t.offsets.popper = ee(this.popper, t.offsets.reference, t.placement), t.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute", t = ie(this.modifiers, t), this.state.isCreated ? this.options.onUpdate(t) : (this.state.isCreated = !0, this.options.onCreate(t));
          }
        }.call(this);
      }
    }, {
      key: "destroy",
      value: function value() {
        return function () {
          return this.state.isDestroyed = !0, oe(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"), this.popper.style.position = "", this.popper.style.top = "", this.popper.style.left = "", this.popper.style.right = "", this.popper.style.bottom = "", this.popper.style.willChange = "", this.popper.style[re("transform")] = ""), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this;
        }.call(this);
      }
    }, {
      key: "enableEventListeners",
      value: function value() {
        return function () {
          this.state.eventsEnabled || (this.state = ae(this.reference, this.options, this.state, this.scheduleUpdate));
        }.call(this);
      }
    }, {
      key: "disableEventListeners",
      value: function value() {
        return le.call(this);
      }
    }]), r;
  }();

  be.Utils = ("undefined" != typeof window ? window : global).PopperUtils, be.placements = de, be.Defaults = Ee;

  var we = "dropdown",
      Te = "bs.dropdown",
      Ce = "." + Te,
      Se = ".data-api",
      De = p.fn[we],
      Ie = new RegExp("38|40|27"),
      Ae = {
    HIDE: "hide" + Ce,
    HIDDEN: "hidden" + Ce,
    SHOW: "show" + Ce,
    SHOWN: "shown" + Ce,
    CLICK: "click" + Ce,
    CLICK_DATA_API: "click" + Ce + Se,
    KEYDOWN_DATA_API: "keydown" + Ce + Se,
    KEYUP_DATA_API: "keyup" + Ce + Se
  },
      Oe = "disabled",
      Ne = "show",
      ke = "dropup",
      Le = "dropright",
      Pe = "dropleft",
      xe = "dropdown-menu-right",
      He = "position-static",
      je = '[data-toggle="dropdown"]',
      Re = ".dropdown form",
      Fe = ".dropdown-menu",
      Me = ".navbar-nav",
      We = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",
      Ue = "top-start",
      Be = "top-end",
      qe = "bottom-start",
      Ke = "bottom-end",
      Qe = "right-start",
      Ye = "left-start",
      Ve = {
    offset: 0,
    flip: !0,
    boundary: "scrollParent",
    reference: "toggle",
    display: "dynamic"
  },
      Xe = {
    offset: "(number|string|function)",
    flip: "boolean",
    boundary: "(string|element)",
    reference: "(string|element)",
    display: "string"
  },
      ze = function () {
    function c(t, e) {
      this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners();
    }

    var t = c.prototype;
    return t.toggle = function () {
      if (!this._element.disabled && !p(this._element).hasClass(Oe)) {
        var t = c._getParentFromElement(this._element),
            e = p(this._menu).hasClass(Ne);

        if (c._clearMenus(), !e) {
          var n = {
            relatedTarget: this._element
          },
              i = p.Event(Ae.SHOW, n);

          if (p(t).trigger(i), !i.isDefaultPrevented()) {
            if (!this._inNavbar) {
              if ("undefined" == typeof be) throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)");
              var o = this._element;
              "parent" === this._config.reference ? o = t : m.isElement(this._config.reference) && (o = this._config.reference, "undefined" != typeof this._config.reference.jquery && (o = this._config.reference[0])), "scrollParent" !== this._config.boundary && p(t).addClass(He), this._popper = new be(o, this._menu, this._getPopperConfig());
            }

            "ontouchstart" in document.documentElement && 0 === p(t).closest(Me).length && p(document.body).children().on("mouseover", null, p.noop), this._element.focus(), this._element.setAttribute("aria-expanded", !0), p(this._menu).toggleClass(Ne), p(t).toggleClass(Ne).trigger(p.Event(Ae.SHOWN, n));
          }
        }
      }
    }, t.show = function () {
      if (!(this._element.disabled || p(this._element).hasClass(Oe) || p(this._menu).hasClass(Ne))) {
        var t = {
          relatedTarget: this._element
        },
            e = p.Event(Ae.SHOW, t),
            n = c._getParentFromElement(this._element);

        p(n).trigger(e), e.isDefaultPrevented() || (p(this._menu).toggleClass(Ne), p(n).toggleClass(Ne).trigger(p.Event(Ae.SHOWN, t)));
      }
    }, t.hide = function () {
      if (!this._element.disabled && !p(this._element).hasClass(Oe) && p(this._menu).hasClass(Ne)) {
        var t = {
          relatedTarget: this._element
        },
            e = p.Event(Ae.HIDE, t),
            n = c._getParentFromElement(this._element);

        p(n).trigger(e), e.isDefaultPrevented() || (p(this._menu).toggleClass(Ne), p(n).toggleClass(Ne).trigger(p.Event(Ae.HIDDEN, t)));
      }
    }, t.dispose = function () {
      p.removeData(this._element, Te), p(this._element).off(Ce), this._element = null, (this._menu = null) !== this._popper && (this._popper.destroy(), this._popper = null);
    }, t.update = function () {
      this._inNavbar = this._detectNavbar(), null !== this._popper && this._popper.scheduleUpdate();
    }, t._addEventListeners = function () {
      var e = this;
      p(this._element).on(Ae.CLICK, function (t) {
        t.preventDefault(), t.stopPropagation(), e.toggle();
      });
    }, t._getConfig = function (t) {
      return t = l({}, this.constructor.Default, p(this._element).data(), t), m.typeCheckConfig(we, t, this.constructor.DefaultType), t;
    }, t._getMenuElement = function () {
      if (!this._menu) {
        var t = c._getParentFromElement(this._element);

        t && (this._menu = t.querySelector(Fe));
      }

      return this._menu;
    }, t._getPlacement = function () {
      var t = p(this._element.parentNode),
          e = qe;
      return t.hasClass(ke) ? (e = Ue, p(this._menu).hasClass(xe) && (e = Be)) : t.hasClass(Le) ? e = Qe : t.hasClass(Pe) ? e = Ye : p(this._menu).hasClass(xe) && (e = Ke), e;
    }, t._detectNavbar = function () {
      return 0 < p(this._element).closest(".navbar").length;
    }, t._getPopperConfig = function () {
      var e = this,
          t = {};
      "function" == typeof this._config.offset ? t.fn = function (t) {
        return t.offsets = l({}, t.offsets, e._config.offset(t.offsets) || {}), t;
      } : t.offset = this._config.offset;
      var n = {
        placement: this._getPlacement(),
        modifiers: {
          offset: t,
          flip: {
            enabled: this._config.flip
          },
          preventOverflow: {
            boundariesElement: this._config.boundary
          }
        }
      };
      return "static" === this._config.display && (n.modifiers.applyStyle = {
        enabled: !1
      }), n;
    }, c._jQueryInterface = function (e) {
      return this.each(function () {
        var t = p(this).data(Te);

        if (t || (t = new c(this, "object" == _typeof(e) ? e : null), p(this).data(Te, t)), "string" == typeof e) {
          if ("undefined" == typeof t[e]) throw new TypeError('No method named "' + e + '"');
          t[e]();
        }
      });
    }, c._clearMenus = function (t) {
      if (!t || 3 !== t.which && ("keyup" !== t.type || 9 === t.which)) for (var e = [].slice.call(document.querySelectorAll(je)), n = 0, i = e.length; n < i; n++) {
        var o = c._getParentFromElement(e[n]),
            r = p(e[n]).data(Te),
            s = {
          relatedTarget: e[n]
        };

        if (t && "click" === t.type && (s.clickEvent = t), r) {
          var a = r._menu;

          if (p(o).hasClass(Ne) && !(t && ("click" === t.type && /input|textarea/i.test(t.target.tagName) || "keyup" === t.type && 9 === t.which) && p.contains(o, t.target))) {
            var l = p.Event(Ae.HIDE, s);
            p(o).trigger(l), l.isDefaultPrevented() || ("ontouchstart" in document.documentElement && p(document.body).children().off("mouseover", null, p.noop), e[n].setAttribute("aria-expanded", "false"), p(a).removeClass(Ne), p(o).removeClass(Ne).trigger(p.Event(Ae.HIDDEN, s)));
          }
        }
      }
    }, c._getParentFromElement = function (t) {
      var e,
          n = m.getSelectorFromElement(t);
      return n && (e = document.querySelector(n)), e || t.parentNode;
    }, c._dataApiKeydownHandler = function (t) {
      if ((/input|textarea/i.test(t.target.tagName) ? !(32 === t.which || 27 !== t.which && (40 !== t.which && 38 !== t.which || p(t.target).closest(Fe).length)) : Ie.test(t.which)) && (t.preventDefault(), t.stopPropagation(), !this.disabled && !p(this).hasClass(Oe))) {
        var e = c._getParentFromElement(this),
            n = p(e).hasClass(Ne);

        if (n && (!n || 27 !== t.which && 32 !== t.which)) {
          var i = [].slice.call(e.querySelectorAll(We));

          if (0 !== i.length) {
            var o = i.indexOf(t.target);
            38 === t.which && 0 < o && o--, 40 === t.which && o < i.length - 1 && o++, o < 0 && (o = 0), i[o].focus();
          }
        } else {
          if (27 === t.which) {
            var r = e.querySelector(je);
            p(r).trigger("focus");
          }

          p(this).trigger("click");
        }
      }
    }, s(c, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return Ve;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return Xe;
      }
    }]), c;
  }();

  p(document).on(Ae.KEYDOWN_DATA_API, je, ze._dataApiKeydownHandler).on(Ae.KEYDOWN_DATA_API, Fe, ze._dataApiKeydownHandler).on(Ae.CLICK_DATA_API + " " + Ae.KEYUP_DATA_API, ze._clearMenus).on(Ae.CLICK_DATA_API, je, function (t) {
    t.preventDefault(), t.stopPropagation(), ze._jQueryInterface.call(p(this), "toggle");
  }).on(Ae.CLICK_DATA_API, Re, function (t) {
    t.stopPropagation();
  }), p.fn[we] = ze._jQueryInterface, p.fn[we].Constructor = ze, p.fn[we].noConflict = function () {
    return p.fn[we] = De, ze._jQueryInterface;
  };

  var Ge = "modal",
      Je = "bs.modal",
      Ze = "." + Je,
      $e = p.fn[Ge],
      tn = {
    backdrop: !0,
    keyboard: !0,
    focus: !0,
    show: !0
  },
      en = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    focus: "boolean",
    show: "boolean"
  },
      nn = {
    HIDE: "hide" + Ze,
    HIDDEN: "hidden" + Ze,
    SHOW: "show" + Ze,
    SHOWN: "shown" + Ze,
    FOCUSIN: "focusin" + Ze,
    RESIZE: "resize" + Ze,
    CLICK_DISMISS: "click.dismiss" + Ze,
    KEYDOWN_DISMISS: "keydown.dismiss" + Ze,
    MOUSEUP_DISMISS: "mouseup.dismiss" + Ze,
    MOUSEDOWN_DISMISS: "mousedown.dismiss" + Ze,
    CLICK_DATA_API: "click" + Ze + ".data-api"
  },
      on = "modal-scrollbar-measure",
      rn = "modal-backdrop",
      sn = "modal-open",
      an = "fade",
      ln = "show",
      cn = ".modal-dialog",
      hn = '[data-toggle="modal"]',
      un = '[data-dismiss="modal"]',
      fn = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
      dn = ".sticky-top",
      pn = function () {
    function o(t, e) {
      this._config = this._getConfig(e), this._element = t, this._dialog = t.querySelector(cn), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollbarWidth = 0;
    }

    var t = o.prototype;
    return t.toggle = function (t) {
      return this._isShown ? this.hide() : this.show(t);
    }, t.show = function (t) {
      var e = this;

      if (!this._isShown && !this._isTransitioning) {
        p(this._element).hasClass(an) && (this._isTransitioning = !0);
        var n = p.Event(nn.SHOW, {
          relatedTarget: t
        });
        p(this._element).trigger(n), this._isShown || n.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), p(this._element).on(nn.CLICK_DISMISS, un, function (t) {
          return e.hide(t);
        }), p(this._dialog).on(nn.MOUSEDOWN_DISMISS, function () {
          p(e._element).one(nn.MOUSEUP_DISMISS, function (t) {
            p(t.target).is(e._element) && (e._ignoreBackdropClick = !0);
          });
        }), this._showBackdrop(function () {
          return e._showElement(t);
        }));
      }
    }, t.hide = function (t) {
      var e = this;

      if (t && t.preventDefault(), this._isShown && !this._isTransitioning) {
        var n = p.Event(nn.HIDE);

        if (p(this._element).trigger(n), this._isShown && !n.isDefaultPrevented()) {
          this._isShown = !1;
          var i = p(this._element).hasClass(an);

          if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), p(document).off(nn.FOCUSIN), p(this._element).removeClass(ln), p(this._element).off(nn.CLICK_DISMISS), p(this._dialog).off(nn.MOUSEDOWN_DISMISS), i) {
            var o = m.getTransitionDurationFromElement(this._element);
            p(this._element).one(m.TRANSITION_END, function (t) {
              return e._hideModal(t);
            }).emulateTransitionEnd(o);
          } else this._hideModal();
        }
      }
    }, t.dispose = function () {
      [window, this._element, this._dialog].forEach(function (t) {
        return p(t).off(Ze);
      }), p(document).off(nn.FOCUSIN), p.removeData(this._element, Je), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null;
    }, t.handleUpdate = function () {
      this._adjustDialog();
    }, t._getConfig = function (t) {
      return t = l({}, tn, t), m.typeCheckConfig(Ge, t, en), t;
    }, t._showElement = function (t) {
      var e = this,
          n = p(this._element).hasClass(an);
      this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.scrollTop = 0, n && m.reflow(this._element), p(this._element).addClass(ln), this._config.focus && this._enforceFocus();

      var i = p.Event(nn.SHOWN, {
        relatedTarget: t
      }),
          o = function o() {
        e._config.focus && e._element.focus(), e._isTransitioning = !1, p(e._element).trigger(i);
      };

      if (n) {
        var r = m.getTransitionDurationFromElement(this._dialog);
        p(this._dialog).one(m.TRANSITION_END, o).emulateTransitionEnd(r);
      } else o();
    }, t._enforceFocus = function () {
      var e = this;
      p(document).off(nn.FOCUSIN).on(nn.FOCUSIN, function (t) {
        document !== t.target && e._element !== t.target && 0 === p(e._element).has(t.target).length && e._element.focus();
      });
    }, t._setEscapeEvent = function () {
      var e = this;
      this._isShown && this._config.keyboard ? p(this._element).on(nn.KEYDOWN_DISMISS, function (t) {
        27 === t.which && (t.preventDefault(), e.hide());
      }) : this._isShown || p(this._element).off(nn.KEYDOWN_DISMISS);
    }, t._setResizeEvent = function () {
      var e = this;
      this._isShown ? p(window).on(nn.RESIZE, function (t) {
        return e.handleUpdate(t);
      }) : p(window).off(nn.RESIZE);
    }, t._hideModal = function () {
      var t = this;
      this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._isTransitioning = !1, this._showBackdrop(function () {
        p(document.body).removeClass(sn), t._resetAdjustments(), t._resetScrollbar(), p(t._element).trigger(nn.HIDDEN);
      });
    }, t._removeBackdrop = function () {
      this._backdrop && (p(this._backdrop).remove(), this._backdrop = null);
    }, t._showBackdrop = function (t) {
      var e = this,
          n = p(this._element).hasClass(an) ? an : "";

      if (this._isShown && this._config.backdrop) {
        if (this._backdrop = document.createElement("div"), this._backdrop.className = rn, n && this._backdrop.classList.add(n), p(this._backdrop).appendTo(document.body), p(this._element).on(nn.CLICK_DISMISS, function (t) {
          e._ignoreBackdropClick ? e._ignoreBackdropClick = !1 : t.target === t.currentTarget && ("static" === e._config.backdrop ? e._element.focus() : e.hide());
        }), n && m.reflow(this._backdrop), p(this._backdrop).addClass(ln), !t) return;
        if (!n) return void t();
        var i = m.getTransitionDurationFromElement(this._backdrop);
        p(this._backdrop).one(m.TRANSITION_END, t).emulateTransitionEnd(i);
      } else if (!this._isShown && this._backdrop) {
        p(this._backdrop).removeClass(ln);

        var o = function o() {
          e._removeBackdrop(), t && t();
        };

        if (p(this._element).hasClass(an)) {
          var r = m.getTransitionDurationFromElement(this._backdrop);
          p(this._backdrop).one(m.TRANSITION_END, o).emulateTransitionEnd(r);
        } else o();
      } else t && t();
    }, t._adjustDialog = function () {
      var t = this._element.scrollHeight > document.documentElement.clientHeight;
      !this._isBodyOverflowing && t && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), this._isBodyOverflowing && !t && (this._element.style.paddingRight = this._scrollbarWidth + "px");
    }, t._resetAdjustments = function () {
      this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
    }, t._checkScrollbar = function () {
      var t = document.body.getBoundingClientRect();
      this._isBodyOverflowing = t.left + t.right < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth();
    }, t._setScrollbar = function () {
      var o = this;

      if (this._isBodyOverflowing) {
        var t = [].slice.call(document.querySelectorAll(fn)),
            e = [].slice.call(document.querySelectorAll(dn));
        p(t).each(function (t, e) {
          var n = e.style.paddingRight,
              i = p(e).css("padding-right");
          p(e).data("padding-right", n).css("padding-right", parseFloat(i) + o._scrollbarWidth + "px");
        }), p(e).each(function (t, e) {
          var n = e.style.marginRight,
              i = p(e).css("margin-right");
          p(e).data("margin-right", n).css("margin-right", parseFloat(i) - o._scrollbarWidth + "px");
        });
        var n = document.body.style.paddingRight,
            i = p(document.body).css("padding-right");
        p(document.body).data("padding-right", n).css("padding-right", parseFloat(i) + this._scrollbarWidth + "px");
      }

      p(document.body).addClass(sn);
    }, t._resetScrollbar = function () {
      var t = [].slice.call(document.querySelectorAll(fn));
      p(t).each(function (t, e) {
        var n = p(e).data("padding-right");
        p(e).removeData("padding-right"), e.style.paddingRight = n || "";
      });
      var e = [].slice.call(document.querySelectorAll("" + dn));
      p(e).each(function (t, e) {
        var n = p(e).data("margin-right");
        "undefined" != typeof n && p(e).css("margin-right", n).removeData("margin-right");
      });
      var n = p(document.body).data("padding-right");
      p(document.body).removeData("padding-right"), document.body.style.paddingRight = n || "";
    }, t._getScrollbarWidth = function () {
      var t = document.createElement("div");
      t.className = on, document.body.appendChild(t);
      var e = t.getBoundingClientRect().width - t.clientWidth;
      return document.body.removeChild(t), e;
    }, o._jQueryInterface = function (n, i) {
      return this.each(function () {
        var t = p(this).data(Je),
            e = l({}, tn, p(this).data(), "object" == _typeof(n) && n ? n : {});

        if (t || (t = new o(this, e), p(this).data(Je, t)), "string" == typeof n) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n](i);
        } else e.show && t.show(i);
      });
    }, s(o, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return tn;
      }
    }]), o;
  }();

  p(document).on(nn.CLICK_DATA_API, hn, function (t) {
    var e,
        n = this,
        i = m.getSelectorFromElement(this);
    i && (e = document.querySelector(i));
    var o = p(e).data(Je) ? "toggle" : l({}, p(e).data(), p(this).data());
    "A" !== this.tagName && "AREA" !== this.tagName || t.preventDefault();
    var r = p(e).one(nn.SHOW, function (t) {
      t.isDefaultPrevented() || r.one(nn.HIDDEN, function () {
        p(n).is(":visible") && n.focus();
      });
    });

    pn._jQueryInterface.call(p(e), o, this);
  }), p.fn[Ge] = pn._jQueryInterface, p.fn[Ge].Constructor = pn, p.fn[Ge].noConflict = function () {
    return p.fn[Ge] = $e, pn._jQueryInterface;
  };

  var mn = "tooltip",
      gn = "bs.tooltip",
      _n = "." + gn,
      vn = p.fn[mn],
      yn = "bs-tooltip",
      En = new RegExp("(^|\\s)" + yn + "\\S+", "g"),
      bn = {
    animation: "boolean",
    template: "string",
    title: "(string|element|function)",
    trigger: "string",
    delay: "(number|object)",
    html: "boolean",
    selector: "(string|boolean)",
    placement: "(string|function)",
    offset: "(number|string)",
    container: "(string|element|boolean)",
    fallbackPlacement: "(string|array)",
    boundary: "(string|element)"
  },
      wn = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: "right",
    BOTTOM: "bottom",
    LEFT: "left"
  },
      Tn = {
    animation: !0,
    template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: "hover focus",
    title: "",
    delay: 0,
    html: !1,
    selector: !1,
    placement: "top",
    offset: 0,
    container: !1,
    fallbackPlacement: "flip",
    boundary: "scrollParent"
  },
      Cn = "show",
      Sn = "out",
      Dn = {
    HIDE: "hide" + _n,
    HIDDEN: "hidden" + _n,
    SHOW: "show" + _n,
    SHOWN: "shown" + _n,
    INSERTED: "inserted" + _n,
    CLICK: "click" + _n,
    FOCUSIN: "focusin" + _n,
    FOCUSOUT: "focusout" + _n,
    MOUSEENTER: "mouseenter" + _n,
    MOUSELEAVE: "mouseleave" + _n
  },
      In = "fade",
      An = "show",
      On = ".tooltip-inner",
      Nn = ".arrow",
      kn = "hover",
      Ln = "focus",
      Pn = "click",
      xn = "manual",
      Hn = function () {
    function i(t, e) {
      if ("undefined" == typeof be) throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)");
      this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners();
    }

    var t = i.prototype;
    return t.enable = function () {
      this._isEnabled = !0;
    }, t.disable = function () {
      this._isEnabled = !1;
    }, t.toggleEnabled = function () {
      this._isEnabled = !this._isEnabled;
    }, t.toggle = function (t) {
      if (this._isEnabled) if (t) {
        var e = this.constructor.DATA_KEY,
            n = p(t.currentTarget).data(e);
        n || (n = new this.constructor(t.currentTarget, this._getDelegateConfig()), p(t.currentTarget).data(e, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n);
      } else {
        if (p(this.getTipElement()).hasClass(An)) return void this._leave(null, this);

        this._enter(null, this);
      }
    }, t.dispose = function () {
      clearTimeout(this._timeout), p.removeData(this.element, this.constructor.DATA_KEY), p(this.element).off(this.constructor.EVENT_KEY), p(this.element).closest(".modal").off("hide.bs.modal"), this.tip && p(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, (this._activeTrigger = null) !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null;
    }, t.show = function () {
      var e = this;
      if ("none" === p(this.element).css("display")) throw new Error("Please use show on visible elements");
      var t = p.Event(this.constructor.Event.SHOW);

      if (this.isWithContent() && this._isEnabled) {
        p(this.element).trigger(t);
        var n = m.findShadowRoot(this.element),
            i = p.contains(null !== n ? n : this.element.ownerDocument.documentElement, this.element);
        if (t.isDefaultPrevented() || !i) return;
        var o = this.getTipElement(),
            r = m.getUID(this.constructor.NAME);
        o.setAttribute("id", r), this.element.setAttribute("aria-describedby", r), this.setContent(), this.config.animation && p(o).addClass(In);

        var s = "function" == typeof this.config.placement ? this.config.placement.call(this, o, this.element) : this.config.placement,
            a = this._getAttachment(s);

        this.addAttachmentClass(a);

        var l = this._getContainer();

        p(o).data(this.constructor.DATA_KEY, this), p.contains(this.element.ownerDocument.documentElement, this.tip) || p(o).appendTo(l), p(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new be(this.element, o, {
          placement: a,
          modifiers: {
            offset: {
              offset: this.config.offset
            },
            flip: {
              behavior: this.config.fallbackPlacement
            },
            arrow: {
              element: Nn
            },
            preventOverflow: {
              boundariesElement: this.config.boundary
            }
          },
          onCreate: function onCreate(t) {
            t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t);
          },
          onUpdate: function onUpdate(t) {
            return e._handlePopperPlacementChange(t);
          }
        }), p(o).addClass(An), "ontouchstart" in document.documentElement && p(document.body).children().on("mouseover", null, p.noop);

        var c = function c() {
          e.config.animation && e._fixTransition();
          var t = e._hoverState;
          e._hoverState = null, p(e.element).trigger(e.constructor.Event.SHOWN), t === Sn && e._leave(null, e);
        };

        if (p(this.tip).hasClass(In)) {
          var h = m.getTransitionDurationFromElement(this.tip);
          p(this.tip).one(m.TRANSITION_END, c).emulateTransitionEnd(h);
        } else c();
      }
    }, t.hide = function (t) {
      var e = this,
          n = this.getTipElement(),
          i = p.Event(this.constructor.Event.HIDE),
          o = function o() {
        e._hoverState !== Cn && n.parentNode && n.parentNode.removeChild(n), e._cleanTipClass(), e.element.removeAttribute("aria-describedby"), p(e.element).trigger(e.constructor.Event.HIDDEN), null !== e._popper && e._popper.destroy(), t && t();
      };

      if (p(this.element).trigger(i), !i.isDefaultPrevented()) {
        if (p(n).removeClass(An), "ontouchstart" in document.documentElement && p(document.body).children().off("mouseover", null, p.noop), this._activeTrigger[Pn] = !1, this._activeTrigger[Ln] = !1, this._activeTrigger[kn] = !1, p(this.tip).hasClass(In)) {
          var r = m.getTransitionDurationFromElement(n);
          p(n).one(m.TRANSITION_END, o).emulateTransitionEnd(r);
        } else o();

        this._hoverState = "";
      }
    }, t.update = function () {
      null !== this._popper && this._popper.scheduleUpdate();
    }, t.isWithContent = function () {
      return Boolean(this.getTitle());
    }, t.addAttachmentClass = function (t) {
      p(this.getTipElement()).addClass(yn + "-" + t);
    }, t.getTipElement = function () {
      return this.tip = this.tip || p(this.config.template)[0], this.tip;
    }, t.setContent = function () {
      var t = this.getTipElement();
      this.setElementContent(p(t.querySelectorAll(On)), this.getTitle()), p(t).removeClass(In + " " + An);
    }, t.setElementContent = function (t, e) {
      var n = this.config.html;
      "object" == _typeof(e) && (e.nodeType || e.jquery) ? n ? p(e).parent().is(t) || t.empty().append(e) : t.text(p(e).text()) : t[n ? "html" : "text"](e);
    }, t.getTitle = function () {
      var t = this.element.getAttribute("data-original-title");
      return t || (t = "function" == typeof this.config.title ? this.config.title.call(this.element) : this.config.title), t;
    }, t._getContainer = function () {
      return !1 === this.config.container ? document.body : m.isElement(this.config.container) ? p(this.config.container) : p(document).find(this.config.container);
    }, t._getAttachment = function (t) {
      return wn[t.toUpperCase()];
    }, t._setListeners = function () {
      var i = this;
      this.config.trigger.split(" ").forEach(function (t) {
        if ("click" === t) p(i.element).on(i.constructor.Event.CLICK, i.config.selector, function (t) {
          return i.toggle(t);
        });else if (t !== xn) {
          var e = t === kn ? i.constructor.Event.MOUSEENTER : i.constructor.Event.FOCUSIN,
              n = t === kn ? i.constructor.Event.MOUSELEAVE : i.constructor.Event.FOCUSOUT;
          p(i.element).on(e, i.config.selector, function (t) {
            return i._enter(t);
          }).on(n, i.config.selector, function (t) {
            return i._leave(t);
          });
        }
      }), p(this.element).closest(".modal").on("hide.bs.modal", function () {
        i.element && i.hide();
      }), this.config.selector ? this.config = l({}, this.config, {
        trigger: "manual",
        selector: ""
      }) : this._fixTitle();
    }, t._fixTitle = function () {
      var t = _typeof(this.element.getAttribute("data-original-title"));

      (this.element.getAttribute("title") || "string" !== t) && (this.element.setAttribute("data-original-title", this.element.getAttribute("title") || ""), this.element.setAttribute("title", ""));
    }, t._enter = function (t, e) {
      var n = this.constructor.DATA_KEY;
      (e = e || p(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), p(t.currentTarget).data(n, e)), t && (e._activeTrigger["focusin" === t.type ? Ln : kn] = !0), p(e.getTipElement()).hasClass(An) || e._hoverState === Cn ? e._hoverState = Cn : (clearTimeout(e._timeout), e._hoverState = Cn, e.config.delay && e.config.delay.show ? e._timeout = setTimeout(function () {
        e._hoverState === Cn && e.show();
      }, e.config.delay.show) : e.show());
    }, t._leave = function (t, e) {
      var n = this.constructor.DATA_KEY;
      (e = e || p(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), p(t.currentTarget).data(n, e)), t && (e._activeTrigger["focusout" === t.type ? Ln : kn] = !1), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = Sn, e.config.delay && e.config.delay.hide ? e._timeout = setTimeout(function () {
        e._hoverState === Sn && e.hide();
      }, e.config.delay.hide) : e.hide());
    }, t._isWithActiveTrigger = function () {
      for (var t in this._activeTrigger) {
        if (this._activeTrigger[t]) return !0;
      }

      return !1;
    }, t._getConfig = function (t) {
      return "number" == typeof (t = l({}, this.constructor.Default, p(this.element).data(), "object" == _typeof(t) && t ? t : {})).delay && (t.delay = {
        show: t.delay,
        hide: t.delay
      }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), m.typeCheckConfig(mn, t, this.constructor.DefaultType), t;
    }, t._getDelegateConfig = function () {
      var t = {};
      if (this.config) for (var e in this.config) {
        this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]);
      }
      return t;
    }, t._cleanTipClass = function () {
      var t = p(this.getTipElement()),
          e = t.attr("class").match(En);
      null !== e && e.length && t.removeClass(e.join(""));
    }, t._handlePopperPlacementChange = function (t) {
      var e = t.instance;
      this.tip = e.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement));
    }, t._fixTransition = function () {
      var t = this.getTipElement(),
          e = this.config.animation;
      null === t.getAttribute("x-placement") && (p(t).removeClass(In), this.config.animation = !1, this.hide(), this.show(), this.config.animation = e);
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = p(this).data(gn),
            e = "object" == _typeof(n) && n;

        if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), p(this).data(gn, t)), "string" == typeof n)) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n]();
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return Tn;
      }
    }, {
      key: "NAME",
      get: function get() {
        return mn;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return gn;
      }
    }, {
      key: "Event",
      get: function get() {
        return Dn;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return _n;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return bn;
      }
    }]), i;
  }();

  p.fn[mn] = Hn._jQueryInterface, p.fn[mn].Constructor = Hn, p.fn[mn].noConflict = function () {
    return p.fn[mn] = vn, Hn._jQueryInterface;
  };

  var jn = "popover",
      Rn = "bs.popover",
      Fn = "." + Rn,
      Mn = p.fn[jn],
      Wn = "bs-popover",
      Un = new RegExp("(^|\\s)" + Wn + "\\S+", "g"),
      Bn = l({}, Hn.Default, {
    placement: "right",
    trigger: "click",
    content: "",
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
  }),
      qn = l({}, Hn.DefaultType, {
    content: "(string|element|function)"
  }),
      Kn = "fade",
      Qn = "show",
      Yn = ".popover-header",
      Vn = ".popover-body",
      Xn = {
    HIDE: "hide" + Fn,
    HIDDEN: "hidden" + Fn,
    SHOW: "show" + Fn,
    SHOWN: "shown" + Fn,
    INSERTED: "inserted" + Fn,
    CLICK: "click" + Fn,
    FOCUSIN: "focusin" + Fn,
    FOCUSOUT: "focusout" + Fn,
    MOUSEENTER: "mouseenter" + Fn,
    MOUSELEAVE: "mouseleave" + Fn
  },
      zn = function (t) {
    var e, n;

    function i() {
      return t.apply(this, arguments) || this;
    }

    n = t, (e = i).prototype = Object.create(n.prototype), (e.prototype.constructor = e).__proto__ = n;
    var o = i.prototype;
    return o.isWithContent = function () {
      return this.getTitle() || this._getContent();
    }, o.addAttachmentClass = function (t) {
      p(this.getTipElement()).addClass(Wn + "-" + t);
    }, o.getTipElement = function () {
      return this.tip = this.tip || p(this.config.template)[0], this.tip;
    }, o.setContent = function () {
      var t = p(this.getTipElement());
      this.setElementContent(t.find(Yn), this.getTitle());

      var e = this._getContent();

      "function" == typeof e && (e = e.call(this.element)), this.setElementContent(t.find(Vn), e), t.removeClass(Kn + " " + Qn);
    }, o._getContent = function () {
      return this.element.getAttribute("data-content") || this.config.content;
    }, o._cleanTipClass = function () {
      var t = p(this.getTipElement()),
          e = t.attr("class").match(Un);
      null !== e && 0 < e.length && t.removeClass(e.join(""));
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = p(this).data(Rn),
            e = "object" == _typeof(n) ? n : null;

        if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), p(this).data(Rn, t)), "string" == typeof n)) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n]();
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return Bn;
      }
    }, {
      key: "NAME",
      get: function get() {
        return jn;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return Rn;
      }
    }, {
      key: "Event",
      get: function get() {
        return Xn;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return Fn;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return qn;
      }
    }]), i;
  }(Hn);

  p.fn[jn] = zn._jQueryInterface, p.fn[jn].Constructor = zn, p.fn[jn].noConflict = function () {
    return p.fn[jn] = Mn, zn._jQueryInterface;
  };

  var Gn = "scrollspy",
      Jn = "bs.scrollspy",
      Zn = "." + Jn,
      $n = p.fn[Gn],
      ti = {
    offset: 10,
    method: "auto",
    target: ""
  },
      ei = {
    offset: "number",
    method: "string",
    target: "(string|element)"
  },
      ni = {
    ACTIVATE: "activate" + Zn,
    SCROLL: "scroll" + Zn,
    LOAD_DATA_API: "load" + Zn + ".data-api"
  },
      ii = "dropdown-item",
      oi = "active",
      ri = '[data-spy="scroll"]',
      si = ".nav, .list-group",
      ai = ".nav-link",
      li = ".nav-item",
      ci = ".list-group-item",
      hi = ".dropdown",
      ui = ".dropdown-item",
      fi = ".dropdown-toggle",
      di = "offset",
      pi = "position",
      mi = function () {
    function n(t, e) {
      var n = this;
      this._element = t, this._scrollElement = "BODY" === t.tagName ? window : t, this._config = this._getConfig(e), this._selector = this._config.target + " " + ai + "," + this._config.target + " " + ci + "," + this._config.target + " " + ui, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, p(this._scrollElement).on(ni.SCROLL, function (t) {
        return n._process(t);
      }), this.refresh(), this._process();
    }

    var t = n.prototype;
    return t.refresh = function () {
      var e = this,
          t = this._scrollElement === this._scrollElement.window ? di : pi,
          o = "auto" === this._config.method ? t : this._config.method,
          r = o === pi ? this._getScrollTop() : 0;
      this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map(function (t) {
        var e,
            n = m.getSelectorFromElement(t);

        if (n && (e = document.querySelector(n)), e) {
          var i = e.getBoundingClientRect();
          if (i.width || i.height) return [p(e)[o]().top + r, n];
        }

        return null;
      }).filter(function (t) {
        return t;
      }).sort(function (t, e) {
        return t[0] - e[0];
      }).forEach(function (t) {
        e._offsets.push(t[0]), e._targets.push(t[1]);
      });
    }, t.dispose = function () {
      p.removeData(this._element, Jn), p(this._scrollElement).off(Zn), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null;
    }, t._getConfig = function (t) {
      if ("string" != typeof (t = l({}, ti, "object" == _typeof(t) && t ? t : {})).target) {
        var e = p(t.target).attr("id");
        e || (e = m.getUID(Gn), p(t.target).attr("id", e)), t.target = "#" + e;
      }

      return m.typeCheckConfig(Gn, t, ei), t;
    }, t._getScrollTop = function () {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    }, t._getScrollHeight = function () {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }, t._getOffsetHeight = function () {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    }, t._process = function () {
      var t = this._getScrollTop() + this._config.offset,
          e = this._getScrollHeight(),
          n = this._config.offset + e - this._getOffsetHeight();

      if (this._scrollHeight !== e && this.refresh(), n <= t) {
        var i = this._targets[this._targets.length - 1];
        this._activeTarget !== i && this._activate(i);
      } else {
        if (this._activeTarget && t < this._offsets[0] && 0 < this._offsets[0]) return this._activeTarget = null, void this._clear();

        for (var o = this._offsets.length; o--;) {
          this._activeTarget !== this._targets[o] && t >= this._offsets[o] && ("undefined" == typeof this._offsets[o + 1] || t < this._offsets[o + 1]) && this._activate(this._targets[o]);
        }
      }
    }, t._activate = function (e) {
      this._activeTarget = e, this._clear();

      var t = this._selector.split(",").map(function (t) {
        return t + '[data-target="' + e + '"],' + t + '[href="' + e + '"]';
      }),
          n = p([].slice.call(document.querySelectorAll(t.join(","))));

      n.hasClass(ii) ? (n.closest(hi).find(fi).addClass(oi), n.addClass(oi)) : (n.addClass(oi), n.parents(si).prev(ai + ", " + ci).addClass(oi), n.parents(si).prev(li).children(ai).addClass(oi)), p(this._scrollElement).trigger(ni.ACTIVATE, {
        relatedTarget: e
      });
    }, t._clear = function () {
      [].slice.call(document.querySelectorAll(this._selector)).filter(function (t) {
        return t.classList.contains(oi);
      }).forEach(function (t) {
        return t.classList.remove(oi);
      });
    }, n._jQueryInterface = function (e) {
      return this.each(function () {
        var t = p(this).data(Jn);

        if (t || (t = new n(this, "object" == _typeof(e) && e), p(this).data(Jn, t)), "string" == typeof e) {
          if ("undefined" == typeof t[e]) throw new TypeError('No method named "' + e + '"');
          t[e]();
        }
      });
    }, s(n, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return ti;
      }
    }]), n;
  }();

  p(window).on(ni.LOAD_DATA_API, function () {
    for (var t = [].slice.call(document.querySelectorAll(ri)), e = t.length; e--;) {
      var n = p(t[e]);

      mi._jQueryInterface.call(n, n.data());
    }
  }), p.fn[Gn] = mi._jQueryInterface, p.fn[Gn].Constructor = mi, p.fn[Gn].noConflict = function () {
    return p.fn[Gn] = $n, mi._jQueryInterface;
  };

  var gi = "bs.tab",
      _i = "." + gi,
      vi = p.fn.tab,
      yi = {
    HIDE: "hide" + _i,
    HIDDEN: "hidden" + _i,
    SHOW: "show" + _i,
    SHOWN: "shown" + _i,
    CLICK_DATA_API: "click" + _i + ".data-api"
  },
      Ei = "dropdown-menu",
      bi = "active",
      wi = "disabled",
      Ti = "fade",
      Ci = "show",
      Si = ".dropdown",
      Di = ".nav, .list-group",
      Ii = ".active",
      Ai = "> li > .active",
      Oi = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
      Ni = ".dropdown-toggle",
      ki = "> .dropdown-menu .active",
      Li = function () {
    function i(t) {
      this._element = t;
    }

    var t = i.prototype;
    return t.show = function () {
      var n = this;

      if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && p(this._element).hasClass(bi) || p(this._element).hasClass(wi))) {
        var t,
            i,
            e = p(this._element).closest(Di)[0],
            o = m.getSelectorFromElement(this._element);

        if (e) {
          var r = "UL" === e.nodeName || "OL" === e.nodeName ? Ai : Ii;
          i = (i = p.makeArray(p(e).find(r)))[i.length - 1];
        }

        var s = p.Event(yi.HIDE, {
          relatedTarget: this._element
        }),
            a = p.Event(yi.SHOW, {
          relatedTarget: i
        });

        if (i && p(i).trigger(s), p(this._element).trigger(a), !a.isDefaultPrevented() && !s.isDefaultPrevented()) {
          o && (t = document.querySelector(o)), this._activate(this._element, e);

          var l = function l() {
            var t = p.Event(yi.HIDDEN, {
              relatedTarget: n._element
            }),
                e = p.Event(yi.SHOWN, {
              relatedTarget: i
            });
            p(i).trigger(t), p(n._element).trigger(e);
          };

          t ? this._activate(t, t.parentNode, l) : l();
        }
      }
    }, t.dispose = function () {
      p.removeData(this._element, gi), this._element = null;
    }, t._activate = function (t, e, n) {
      var i = this,
          o = (!e || "UL" !== e.nodeName && "OL" !== e.nodeName ? p(e).children(Ii) : p(e).find(Ai))[0],
          r = n && o && p(o).hasClass(Ti),
          s = function s() {
        return i._transitionComplete(t, o, n);
      };

      if (o && r) {
        var a = m.getTransitionDurationFromElement(o);
        p(o).removeClass(Ci).one(m.TRANSITION_END, s).emulateTransitionEnd(a);
      } else s();
    }, t._transitionComplete = function (t, e, n) {
      if (e) {
        p(e).removeClass(bi);
        var i = p(e.parentNode).find(ki)[0];
        i && p(i).removeClass(bi), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !1);
      }

      if (p(t).addClass(bi), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0), m.reflow(t), p(t).addClass(Ci), t.parentNode && p(t.parentNode).hasClass(Ei)) {
        var o = p(t).closest(Si)[0];

        if (o) {
          var r = [].slice.call(o.querySelectorAll(Ni));
          p(r).addClass(bi);
        }

        t.setAttribute("aria-expanded", !0);
      }

      n && n();
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = p(this),
            e = t.data(gi);

        if (e || (e = new i(this), t.data(gi, e)), "string" == typeof n) {
          if ("undefined" == typeof e[n]) throw new TypeError('No method named "' + n + '"');
          e[n]();
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }]), i;
  }();

  p(document).on(yi.CLICK_DATA_API, Oi, function (t) {
    t.preventDefault(), Li._jQueryInterface.call(p(this), "show");
  }), p.fn.tab = Li._jQueryInterface, p.fn.tab.Constructor = Li, p.fn.tab.noConflict = function () {
    return p.fn.tab = vi, Li._jQueryInterface;
  };

  var Pi = "toast",
      xi = "bs.toast",
      Hi = "." + xi,
      ji = p.fn[Pi],
      Ri = {
    CLICK_DISMISS: "click.dismiss" + Hi,
    HIDE: "hide" + Hi,
    HIDDEN: "hidden" + Hi,
    SHOW: "show" + Hi,
    SHOWN: "shown" + Hi
  },
      Fi = "fade",
      Mi = "hide",
      Wi = "show",
      Ui = "showing",
      Bi = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
  },
      qi = {
    animation: !0,
    autohide: !0,
    delay: 500
  },
      Ki = '[data-dismiss="toast"]',
      Qi = function () {
    function i(t, e) {
      this._element = t, this._config = this._getConfig(e), this._timeout = null, this._setListeners();
    }

    var t = i.prototype;
    return t.show = function () {
      var t = this;
      p(this._element).trigger(Ri.SHOW), this._config.animation && this._element.classList.add(Fi);

      var e = function e() {
        t._element.classList.remove(Ui), t._element.classList.add(Wi), p(t._element).trigger(Ri.SHOWN), t._config.autohide && t.hide();
      };

      if (this._element.classList.remove(Mi), this._element.classList.add(Ui), this._config.animation) {
        var n = m.getTransitionDurationFromElement(this._element);
        p(this._element).one(m.TRANSITION_END, e).emulateTransitionEnd(n);
      } else e();
    }, t.hide = function (t) {
      var e = this;
      this._element.classList.contains(Wi) && (p(this._element).trigger(Ri.HIDE), t ? this._close() : this._timeout = setTimeout(function () {
        e._close();
      }, this._config.delay));
    }, t.dispose = function () {
      clearTimeout(this._timeout), this._timeout = null, this._element.classList.contains(Wi) && this._element.classList.remove(Wi), p(this._element).off(Ri.CLICK_DISMISS), p.removeData(this._element, xi), this._element = null, this._config = null;
    }, t._getConfig = function (t) {
      return t = l({}, qi, p(this._element).data(), "object" == _typeof(t) && t ? t : {}), m.typeCheckConfig(Pi, t, this.constructor.DefaultType), t;
    }, t._setListeners = function () {
      var t = this;
      p(this._element).on(Ri.CLICK_DISMISS, Ki, function () {
        return t.hide(!0);
      });
    }, t._close = function () {
      var t = this,
          e = function e() {
        t._element.classList.add(Mi), p(t._element).trigger(Ri.HIDDEN);
      };

      if (this._element.classList.remove(Wi), this._config.animation) {
        var n = m.getTransitionDurationFromElement(this._element);
        p(this._element).one(m.TRANSITION_END, e).emulateTransitionEnd(n);
      } else e();
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = p(this),
            e = t.data(xi);

        if (e || (e = new i(this, "object" == _typeof(n) && n), t.data(xi, e)), "string" == typeof n) {
          if ("undefined" == typeof e[n]) throw new TypeError('No method named "' + n + '"');
          e[n](this);
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return Bi;
      }
    }]), i;
  }();

  p.fn[Pi] = Qi._jQueryInterface, p.fn[Pi].Constructor = Qi, p.fn[Pi].noConflict = function () {
    return p.fn[Pi] = ji, Qi._jQueryInterface;
  }, function () {
    if ("undefined" == typeof p) throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
    var t = p.fn.jquery.split(" ")[0].split(".");
    if (t[0] < 2 && t[1] < 9 || 1 === t[0] && 9 === t[1] && t[2] < 1 || 4 <= t[0]) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0");
  }(), t.Util = m, t.Alert = g, t.Button = k, t.Carousel = at, t.Collapse = Tt, t.Dropdown = ze, t.Modal = pn, t.Popover = zn, t.Scrollspy = mi, t.Tab = Li, t.Toast = Qi, t.Tooltip = Hn, Object.defineProperty(t, "__esModule", {
    value: !0
  });
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./assets/js/lib/bootstrap/js/bootstrap.min.js":
/*!*****************************************************!*\
  !*** ./assets/js/lib/bootstrap/js/bootstrap.min.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap v4.2.1 (https://getbootstrap.com/)
  * Copyright 2011-2018 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
!function (t, e) {
  "object" == ( false ? undefined : _typeof(exports)) && "undefined" != typeof module ? e(exports, __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
}(this, function (t, u, g) {
  "use strict";

  function i(t, e) {
    for (var n = 0; n < e.length; n++) {
      var i = e[n];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
    }
  }

  function s(t, e, n) {
    return e && i(t.prototype, e), n && i(t, n), t;
  }

  function l(o) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {},
          e = Object.keys(r);
      "function" == typeof Object.getOwnPropertySymbols && (e = e.concat(Object.getOwnPropertySymbols(r).filter(function (t) {
        return Object.getOwnPropertyDescriptor(r, t).enumerable;
      }))), e.forEach(function (t) {
        var e, n, i;
        e = o, i = r[n = t], n in e ? Object.defineProperty(e, n, {
          value: i,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[n] = i;
      });
    }

    return o;
  }

  u = u && u.hasOwnProperty("default") ? u.default : u, g = g && g.hasOwnProperty("default") ? g.default : g;
  var e = "transitionend";

  function n(t) {
    var e = this,
        n = !1;
    return g(this).one(_.TRANSITION_END, function () {
      n = !0;
    }), setTimeout(function () {
      n || _.triggerTransitionEnd(e);
    }, t), this;
  }

  var _ = {
    TRANSITION_END: "bsTransitionEnd",
    getUID: function getUID(t) {
      for (; t += ~~(1e6 * Math.random()), document.getElementById(t);) {
        ;
      }

      return t;
    },
    getSelectorFromElement: function getSelectorFromElement(t) {
      var e = t.getAttribute("data-target");

      if (!e || "#" === e) {
        var n = t.getAttribute("href");
        e = n && "#" !== n ? n.trim() : "";
      }

      return e && document.querySelector(e) ? e : null;
    },
    getTransitionDurationFromElement: function getTransitionDurationFromElement(t) {
      if (!t) return 0;
      var e = g(t).css("transition-duration"),
          n = g(t).css("transition-delay"),
          i = parseFloat(e),
          o = parseFloat(n);
      return i || o ? (e = e.split(",")[0], n = n.split(",")[0], 1e3 * (parseFloat(e) + parseFloat(n))) : 0;
    },
    reflow: function reflow(t) {
      return t.offsetHeight;
    },
    triggerTransitionEnd: function triggerTransitionEnd(t) {
      g(t).trigger(e);
    },
    supportsTransitionEnd: function supportsTransitionEnd() {
      return Boolean(e);
    },
    isElement: function isElement(t) {
      return (t[0] || t).nodeType;
    },
    typeCheckConfig: function typeCheckConfig(t, e, n) {
      for (var i in n) {
        if (Object.prototype.hasOwnProperty.call(n, i)) {
          var o = n[i],
              r = e[i],
              s = r && _.isElement(r) ? "element" : (a = r, {}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase());
          if (!new RegExp(o).test(s)) throw new Error(t.toUpperCase() + ': Option "' + i + '" provided type "' + s + '" but expected type "' + o + '".');
        }
      }

      var a;
    },
    findShadowRoot: function findShadowRoot(t) {
      if (!document.documentElement.attachShadow) return null;
      if ("function" != typeof t.getRootNode) return t instanceof ShadowRoot ? t : t.parentNode ? _.findShadowRoot(t.parentNode) : null;
      var e = t.getRootNode();
      return e instanceof ShadowRoot ? e : null;
    }
  };
  g.fn.emulateTransitionEnd = n, g.event.special[_.TRANSITION_END] = {
    bindType: e,
    delegateType: e,
    handle: function handle(t) {
      if (g(t.target).is(this)) return t.handleObj.handler.apply(this, arguments);
    }
  };

  var o = "alert",
      r = "bs.alert",
      a = "." + r,
      c = g.fn[o],
      h = {
    CLOSE: "close" + a,
    CLOSED: "closed" + a,
    CLICK_DATA_API: "click" + a + ".data-api"
  },
      f = "alert",
      d = "fade",
      m = "show",
      p = function () {
    function i(t) {
      this._element = t;
    }

    var t = i.prototype;
    return t.close = function (t) {
      var e = this._element;
      t && (e = this._getRootElement(t)), this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e);
    }, t.dispose = function () {
      g.removeData(this._element, r), this._element = null;
    }, t._getRootElement = function (t) {
      var e = _.getSelectorFromElement(t),
          n = !1;

      return e && (n = document.querySelector(e)), n || (n = g(t).closest("." + f)[0]), n;
    }, t._triggerCloseEvent = function (t) {
      var e = g.Event(h.CLOSE);
      return g(t).trigger(e), e;
    }, t._removeElement = function (e) {
      var n = this;

      if (g(e).removeClass(m), g(e).hasClass(d)) {
        var t = _.getTransitionDurationFromElement(e);

        g(e).one(_.TRANSITION_END, function (t) {
          return n._destroyElement(e, t);
        }).emulateTransitionEnd(t);
      } else this._destroyElement(e);
    }, t._destroyElement = function (t) {
      g(t).detach().trigger(h.CLOSED).remove();
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = g(this),
            e = t.data(r);
        e || (e = new i(this), t.data(r, e)), "close" === n && e[n](this);
      });
    }, i._handleDismiss = function (e) {
      return function (t) {
        t && t.preventDefault(), e.close(this);
      };
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }]), i;
  }();

  g(document).on(h.CLICK_DATA_API, '[data-dismiss="alert"]', p._handleDismiss(new p())), g.fn[o] = p._jQueryInterface, g.fn[o].Constructor = p, g.fn[o].noConflict = function () {
    return g.fn[o] = c, p._jQueryInterface;
  };

  var v = "button",
      E = "bs.button",
      y = "." + E,
      C = ".data-api",
      T = g.fn[v],
      S = "active",
      b = "btn",
      I = "focus",
      D = '[data-toggle^="button"]',
      w = '[data-toggle="buttons"]',
      A = 'input:not([type="hidden"])',
      N = ".active",
      O = ".btn",
      k = {
    CLICK_DATA_API: "click" + y + C,
    FOCUS_BLUR_DATA_API: "focus" + y + C + " blur" + y + C
  },
      P = function () {
    function n(t) {
      this._element = t;
    }

    var t = n.prototype;
    return t.toggle = function () {
      var t = !0,
          e = !0,
          n = g(this._element).closest(w)[0];

      if (n) {
        var i = this._element.querySelector(A);

        if (i) {
          if ("radio" === i.type) if (i.checked && this._element.classList.contains(S)) t = !1;else {
            var o = n.querySelector(N);
            o && g(o).removeClass(S);
          }

          if (t) {
            if (i.hasAttribute("disabled") || n.hasAttribute("disabled") || i.classList.contains("disabled") || n.classList.contains("disabled")) return;
            i.checked = !this._element.classList.contains(S), g(i).trigger("change");
          }

          i.focus(), e = !1;
        }
      }

      e && this._element.setAttribute("aria-pressed", !this._element.classList.contains(S)), t && g(this._element).toggleClass(S);
    }, t.dispose = function () {
      g.removeData(this._element, E), this._element = null;
    }, n._jQueryInterface = function (e) {
      return this.each(function () {
        var t = g(this).data(E);
        t || (t = new n(this), g(this).data(E, t)), "toggle" === e && t[e]();
      });
    }, s(n, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }]), n;
  }();

  g(document).on(k.CLICK_DATA_API, D, function (t) {
    t.preventDefault();
    var e = t.target;
    g(e).hasClass(b) || (e = g(e).closest(O)), P._jQueryInterface.call(g(e), "toggle");
  }).on(k.FOCUS_BLUR_DATA_API, D, function (t) {
    var e = g(t.target).closest(O)[0];
    g(e).toggleClass(I, /^focus(in)?$/.test(t.type));
  }), g.fn[v] = P._jQueryInterface, g.fn[v].Constructor = P, g.fn[v].noConflict = function () {
    return g.fn[v] = T, P._jQueryInterface;
  };

  var L = "carousel",
      j = "bs.carousel",
      H = "." + j,
      R = ".data-api",
      U = g.fn[L],
      W = {
    interval: 5e3,
    keyboard: !0,
    slide: !1,
    pause: "hover",
    wrap: !0,
    touch: !0
  },
      x = {
    interval: "(number|boolean)",
    keyboard: "boolean",
    slide: "(boolean|string)",
    pause: "(string|boolean)",
    wrap: "boolean",
    touch: "boolean"
  },
      F = "next",
      q = "prev",
      M = "left",
      K = "right",
      Q = {
    SLIDE: "slide" + H,
    SLID: "slid" + H,
    KEYDOWN: "keydown" + H,
    MOUSEENTER: "mouseenter" + H,
    MOUSELEAVE: "mouseleave" + H,
    TOUCHSTART: "touchstart" + H,
    TOUCHMOVE: "touchmove" + H,
    TOUCHEND: "touchend" + H,
    POINTERDOWN: "pointerdown" + H,
    POINTERUP: "pointerup" + H,
    DRAG_START: "dragstart" + H,
    LOAD_DATA_API: "load" + H + R,
    CLICK_DATA_API: "click" + H + R
  },
      B = "carousel",
      V = "active",
      Y = "slide",
      X = "carousel-item-right",
      z = "carousel-item-left",
      G = "carousel-item-next",
      J = "carousel-item-prev",
      Z = "pointer-event",
      $ = ".active",
      tt = ".active.carousel-item",
      et = ".carousel-item",
      nt = ".carousel-item img",
      it = ".carousel-item-next, .carousel-item-prev",
      ot = ".carousel-indicators",
      rt = "[data-slide], [data-slide-to]",
      st = '[data-ride="carousel"]',
      at = {
    TOUCH: "touch",
    PEN: "pen"
  },
      lt = function () {
    function r(t, e) {
      this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._element = t, this._indicatorsElement = this._element.querySelector(ot), this._touchSupported = "ontouchstart" in document.documentElement || 0 < navigator.maxTouchPoints, this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent), this._addEventListeners();
    }

    var t = r.prototype;
    return t.next = function () {
      this._isSliding || this._slide(F);
    }, t.nextWhenVisible = function () {
      !document.hidden && g(this._element).is(":visible") && "hidden" !== g(this._element).css("visibility") && this.next();
    }, t.prev = function () {
      this._isSliding || this._slide(q);
    }, t.pause = function (t) {
      t || (this._isPaused = !0), this._element.querySelector(it) && (_.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;
    }, t.cycle = function (t) {
      t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));
    }, t.to = function (t) {
      var e = this;
      this._activeElement = this._element.querySelector(tt);

      var n = this._getItemIndex(this._activeElement);

      if (!(t > this._items.length - 1 || t < 0)) if (this._isSliding) g(this._element).one(Q.SLID, function () {
        return e.to(t);
      });else {
        if (n === t) return this.pause(), void this.cycle();
        var i = n < t ? F : q;

        this._slide(i, this._items[t]);
      }
    }, t.dispose = function () {
      g(this._element).off(H), g.removeData(this._element, j), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null;
    }, t._getConfig = function (t) {
      return t = l({}, W, t), _.typeCheckConfig(L, t, x), t;
    }, t._handleSwipe = function () {
      var t = Math.abs(this.touchDeltaX);

      if (!(t <= 40)) {
        var e = t / this.touchDeltaX;
        0 < e && this.prev(), e < 0 && this.next();
      }
    }, t._addEventListeners = function () {
      var e = this;
      this._config.keyboard && g(this._element).on(Q.KEYDOWN, function (t) {
        return e._keydown(t);
      }), "hover" === this._config.pause && g(this._element).on(Q.MOUSEENTER, function (t) {
        return e.pause(t);
      }).on(Q.MOUSELEAVE, function (t) {
        return e.cycle(t);
      }), this._addTouchEventListeners();
    }, t._addTouchEventListeners = function () {
      var n = this;

      if (this._touchSupported) {
        var e = function e(t) {
          n._pointerEvent && at[t.originalEvent.pointerType.toUpperCase()] ? n.touchStartX = t.originalEvent.clientX : n._pointerEvent || (n.touchStartX = t.originalEvent.touches[0].clientX);
        },
            i = function i(t) {
          n._pointerEvent && at[t.originalEvent.pointerType.toUpperCase()] && (n.touchDeltaX = t.originalEvent.clientX - n.touchStartX), n._handleSwipe(), "hover" === n._config.pause && (n.pause(), n.touchTimeout && clearTimeout(n.touchTimeout), n.touchTimeout = setTimeout(function (t) {
            return n.cycle(t);
          }, 500 + n._config.interval));
        };

        g(this._element.querySelectorAll(nt)).on(Q.DRAG_START, function (t) {
          return t.preventDefault();
        }), this._pointerEvent ? (g(this._element).on(Q.POINTERDOWN, function (t) {
          return e(t);
        }), g(this._element).on(Q.POINTERUP, function (t) {
          return i(t);
        }), this._element.classList.add(Z)) : (g(this._element).on(Q.TOUCHSTART, function (t) {
          return e(t);
        }), g(this._element).on(Q.TOUCHMOVE, function (t) {
          var e;
          (e = t).originalEvent.touches && 1 < e.originalEvent.touches.length ? n.touchDeltaX = 0 : n.touchDeltaX = e.originalEvent.touches[0].clientX - n.touchStartX;
        }), g(this._element).on(Q.TOUCHEND, function (t) {
          return i(t);
        }));
      }
    }, t._keydown = function (t) {
      if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) {
        case 37:
          t.preventDefault(), this.prev();
          break;

        case 39:
          t.preventDefault(), this.next();
      }
    }, t._getItemIndex = function (t) {
      return this._items = t && t.parentNode ? [].slice.call(t.parentNode.querySelectorAll(et)) : [], this._items.indexOf(t);
    }, t._getItemByDirection = function (t, e) {
      var n = t === F,
          i = t === q,
          o = this._getItemIndex(e),
          r = this._items.length - 1;

      if ((i && 0 === o || n && o === r) && !this._config.wrap) return e;
      var s = (o + (t === q ? -1 : 1)) % this._items.length;
      return -1 === s ? this._items[this._items.length - 1] : this._items[s];
    }, t._triggerSlideEvent = function (t, e) {
      var n = this._getItemIndex(t),
          i = this._getItemIndex(this._element.querySelector(tt)),
          o = g.Event(Q.SLIDE, {
        relatedTarget: t,
        direction: e,
        from: i,
        to: n
      });

      return g(this._element).trigger(o), o;
    }, t._setActiveIndicatorElement = function (t) {
      if (this._indicatorsElement) {
        var e = [].slice.call(this._indicatorsElement.querySelectorAll($));
        g(e).removeClass(V);

        var n = this._indicatorsElement.children[this._getItemIndex(t)];

        n && g(n).addClass(V);
      }
    }, t._slide = function (t, e) {
      var n,
          i,
          o,
          r = this,
          s = this._element.querySelector(tt),
          a = this._getItemIndex(s),
          l = e || s && this._getItemByDirection(t, s),
          c = this._getItemIndex(l),
          h = Boolean(this._interval);

      if (o = t === F ? (n = z, i = G, M) : (n = X, i = J, K), l && g(l).hasClass(V)) this._isSliding = !1;else if (!this._triggerSlideEvent(l, o).isDefaultPrevented() && s && l) {
        this._isSliding = !0, h && this.pause(), this._setActiveIndicatorElement(l);
        var u = g.Event(Q.SLID, {
          relatedTarget: l,
          direction: o,
          from: a,
          to: c
        });

        if (g(this._element).hasClass(Y)) {
          g(l).addClass(i), _.reflow(l), g(s).addClass(n), g(l).addClass(n);
          var f = parseInt(l.getAttribute("data-interval"), 10);
          this._config.interval = f ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, f) : this._config.defaultInterval || this._config.interval;

          var d = _.getTransitionDurationFromElement(s);

          g(s).one(_.TRANSITION_END, function () {
            g(l).removeClass(n + " " + i).addClass(V), g(s).removeClass(V + " " + i + " " + n), r._isSliding = !1, setTimeout(function () {
              return g(r._element).trigger(u);
            }, 0);
          }).emulateTransitionEnd(d);
        } else g(s).removeClass(V), g(l).addClass(V), this._isSliding = !1, g(this._element).trigger(u);

        h && this.cycle();
      }
    }, r._jQueryInterface = function (i) {
      return this.each(function () {
        var t = g(this).data(j),
            e = l({}, W, g(this).data());
        "object" == _typeof(i) && (e = l({}, e, i));
        var n = "string" == typeof i ? i : e.slide;
        if (t || (t = new r(this, e), g(this).data(j, t)), "number" == typeof i) t.to(i);else if ("string" == typeof n) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n]();
        } else e.interval && (t.pause(), t.cycle());
      });
    }, r._dataApiClickHandler = function (t) {
      var e = _.getSelectorFromElement(this);

      if (e) {
        var n = g(e)[0];

        if (n && g(n).hasClass(B)) {
          var i = l({}, g(n).data(), g(this).data()),
              o = this.getAttribute("data-slide-to");
          o && (i.interval = !1), r._jQueryInterface.call(g(n), i), o && g(n).data(j).to(o), t.preventDefault();
        }
      }
    }, s(r, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return W;
      }
    }]), r;
  }();

  g(document).on(Q.CLICK_DATA_API, rt, lt._dataApiClickHandler), g(window).on(Q.LOAD_DATA_API, function () {
    for (var t = [].slice.call(document.querySelectorAll(st)), e = 0, n = t.length; e < n; e++) {
      var i = g(t[e]);

      lt._jQueryInterface.call(i, i.data());
    }
  }), g.fn[L] = lt._jQueryInterface, g.fn[L].Constructor = lt, g.fn[L].noConflict = function () {
    return g.fn[L] = U, lt._jQueryInterface;
  };

  var ct = "collapse",
      ht = "bs.collapse",
      ut = "." + ht,
      ft = g.fn[ct],
      dt = {
    toggle: !0,
    parent: ""
  },
      gt = {
    toggle: "boolean",
    parent: "(string|element)"
  },
      _t = {
    SHOW: "show" + ut,
    SHOWN: "shown" + ut,
    HIDE: "hide" + ut,
    HIDDEN: "hidden" + ut,
    CLICK_DATA_API: "click" + ut + ".data-api"
  },
      mt = "show",
      pt = "collapse",
      vt = "collapsing",
      Et = "collapsed",
      yt = "width",
      Ct = "height",
      Tt = ".show, .collapsing",
      St = '[data-toggle="collapse"]',
      bt = function () {
    function a(e, t) {
      this._isTransitioning = !1, this._element = e, this._config = this._getConfig(t), this._triggerArray = [].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#' + e.id + '"],[data-toggle="collapse"][data-target="#' + e.id + '"]'));

      for (var n = [].slice.call(document.querySelectorAll(St)), i = 0, o = n.length; i < o; i++) {
        var r = n[i],
            s = _.getSelectorFromElement(r),
            a = [].slice.call(document.querySelectorAll(s)).filter(function (t) {
          return t === e;
        });

        null !== s && 0 < a.length && (this._selector = s, this._triggerArray.push(r));
      }

      this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle();
    }

    var t = a.prototype;
    return t.toggle = function () {
      g(this._element).hasClass(mt) ? this.hide() : this.show();
    }, t.show = function () {
      var t,
          e,
          n = this;

      if (!this._isTransitioning && !g(this._element).hasClass(mt) && (this._parent && 0 === (t = [].slice.call(this._parent.querySelectorAll(Tt)).filter(function (t) {
        return "string" == typeof n._config.parent ? t.getAttribute("data-parent") === n._config.parent : t.classList.contains(pt);
      })).length && (t = null), !(t && (e = g(t).not(this._selector).data(ht)) && e._isTransitioning))) {
        var i = g.Event(_t.SHOW);

        if (g(this._element).trigger(i), !i.isDefaultPrevented()) {
          t && (a._jQueryInterface.call(g(t).not(this._selector), "hide"), e || g(t).data(ht, null));

          var o = this._getDimension();

          g(this._element).removeClass(pt).addClass(vt), this._element.style[o] = 0, this._triggerArray.length && g(this._triggerArray).removeClass(Et).attr("aria-expanded", !0), this.setTransitioning(!0);

          var r = "scroll" + (o[0].toUpperCase() + o.slice(1)),
              s = _.getTransitionDurationFromElement(this._element);

          g(this._element).one(_.TRANSITION_END, function () {
            g(n._element).removeClass(vt).addClass(pt).addClass(mt), n._element.style[o] = "", n.setTransitioning(!1), g(n._element).trigger(_t.SHOWN);
          }).emulateTransitionEnd(s), this._element.style[o] = this._element[r] + "px";
        }
      }
    }, t.hide = function () {
      var t = this;

      if (!this._isTransitioning && g(this._element).hasClass(mt)) {
        var e = g.Event(_t.HIDE);

        if (g(this._element).trigger(e), !e.isDefaultPrevented()) {
          var n = this._getDimension();

          this._element.style[n] = this._element.getBoundingClientRect()[n] + "px", _.reflow(this._element), g(this._element).addClass(vt).removeClass(pt).removeClass(mt);
          var i = this._triggerArray.length;
          if (0 < i) for (var o = 0; o < i; o++) {
            var r = this._triggerArray[o],
                s = _.getSelectorFromElement(r);

            if (null !== s) g([].slice.call(document.querySelectorAll(s))).hasClass(mt) || g(r).addClass(Et).attr("aria-expanded", !1);
          }
          this.setTransitioning(!0);
          this._element.style[n] = "";

          var a = _.getTransitionDurationFromElement(this._element);

          g(this._element).one(_.TRANSITION_END, function () {
            t.setTransitioning(!1), g(t._element).removeClass(vt).addClass(pt).trigger(_t.HIDDEN);
          }).emulateTransitionEnd(a);
        }
      }
    }, t.setTransitioning = function (t) {
      this._isTransitioning = t;
    }, t.dispose = function () {
      g.removeData(this._element, ht), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null;
    }, t._getConfig = function (t) {
      return (t = l({}, dt, t)).toggle = Boolean(t.toggle), _.typeCheckConfig(ct, t, gt), t;
    }, t._getDimension = function () {
      return g(this._element).hasClass(yt) ? yt : Ct;
    }, t._getParent = function () {
      var t,
          n = this;
      _.isElement(this._config.parent) ? (t = this._config.parent, "undefined" != typeof this._config.parent.jquery && (t = this._config.parent[0])) : t = document.querySelector(this._config.parent);
      var e = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]',
          i = [].slice.call(t.querySelectorAll(e));
      return g(i).each(function (t, e) {
        n._addAriaAndCollapsedClass(a._getTargetFromElement(e), [e]);
      }), t;
    }, t._addAriaAndCollapsedClass = function (t, e) {
      var n = g(t).hasClass(mt);
      e.length && g(e).toggleClass(Et, !n).attr("aria-expanded", n);
    }, a._getTargetFromElement = function (t) {
      var e = _.getSelectorFromElement(t);

      return e ? document.querySelector(e) : null;
    }, a._jQueryInterface = function (i) {
      return this.each(function () {
        var t = g(this),
            e = t.data(ht),
            n = l({}, dt, t.data(), "object" == _typeof(i) && i ? i : {});

        if (!e && n.toggle && /show|hide/.test(i) && (n.toggle = !1), e || (e = new a(this, n), t.data(ht, e)), "string" == typeof i) {
          if ("undefined" == typeof e[i]) throw new TypeError('No method named "' + i + '"');
          e[i]();
        }
      });
    }, s(a, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return dt;
      }
    }]), a;
  }();

  g(document).on(_t.CLICK_DATA_API, St, function (t) {
    "A" === t.currentTarget.tagName && t.preventDefault();

    var n = g(this),
        e = _.getSelectorFromElement(this),
        i = [].slice.call(document.querySelectorAll(e));

    g(i).each(function () {
      var t = g(this),
          e = t.data(ht) ? "toggle" : n.data();

      bt._jQueryInterface.call(t, e);
    });
  }), g.fn[ct] = bt._jQueryInterface, g.fn[ct].Constructor = bt, g.fn[ct].noConflict = function () {
    return g.fn[ct] = ft, bt._jQueryInterface;
  };

  var It = "dropdown",
      Dt = "bs.dropdown",
      wt = "." + Dt,
      At = ".data-api",
      Nt = g.fn[It],
      Ot = new RegExp("38|40|27"),
      kt = {
    HIDE: "hide" + wt,
    HIDDEN: "hidden" + wt,
    SHOW: "show" + wt,
    SHOWN: "shown" + wt,
    CLICK: "click" + wt,
    CLICK_DATA_API: "click" + wt + At,
    KEYDOWN_DATA_API: "keydown" + wt + At,
    KEYUP_DATA_API: "keyup" + wt + At
  },
      Pt = "disabled",
      Lt = "show",
      jt = "dropup",
      Ht = "dropright",
      Rt = "dropleft",
      Ut = "dropdown-menu-right",
      Wt = "position-static",
      xt = '[data-toggle="dropdown"]',
      Ft = ".dropdown form",
      qt = ".dropdown-menu",
      Mt = ".navbar-nav",
      Kt = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",
      Qt = "top-start",
      Bt = "top-end",
      Vt = "bottom-start",
      Yt = "bottom-end",
      Xt = "right-start",
      zt = "left-start",
      Gt = {
    offset: 0,
    flip: !0,
    boundary: "scrollParent",
    reference: "toggle",
    display: "dynamic"
  },
      Jt = {
    offset: "(number|string|function)",
    flip: "boolean",
    boundary: "(string|element)",
    reference: "(string|element)",
    display: "string"
  },
      Zt = function () {
    function c(t, e) {
      this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners();
    }

    var t = c.prototype;
    return t.toggle = function () {
      if (!this._element.disabled && !g(this._element).hasClass(Pt)) {
        var t = c._getParentFromElement(this._element),
            e = g(this._menu).hasClass(Lt);

        if (c._clearMenus(), !e) {
          var n = {
            relatedTarget: this._element
          },
              i = g.Event(kt.SHOW, n);

          if (g(t).trigger(i), !i.isDefaultPrevented()) {
            if (!this._inNavbar) {
              if ("undefined" == typeof u) throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)");
              var o = this._element;
              "parent" === this._config.reference ? o = t : _.isElement(this._config.reference) && (o = this._config.reference, "undefined" != typeof this._config.reference.jquery && (o = this._config.reference[0])), "scrollParent" !== this._config.boundary && g(t).addClass(Wt), this._popper = new u(o, this._menu, this._getPopperConfig());
            }

            "ontouchstart" in document.documentElement && 0 === g(t).closest(Mt).length && g(document.body).children().on("mouseover", null, g.noop), this._element.focus(), this._element.setAttribute("aria-expanded", !0), g(this._menu).toggleClass(Lt), g(t).toggleClass(Lt).trigger(g.Event(kt.SHOWN, n));
          }
        }
      }
    }, t.show = function () {
      if (!(this._element.disabled || g(this._element).hasClass(Pt) || g(this._menu).hasClass(Lt))) {
        var t = {
          relatedTarget: this._element
        },
            e = g.Event(kt.SHOW, t),
            n = c._getParentFromElement(this._element);

        g(n).trigger(e), e.isDefaultPrevented() || (g(this._menu).toggleClass(Lt), g(n).toggleClass(Lt).trigger(g.Event(kt.SHOWN, t)));
      }
    }, t.hide = function () {
      if (!this._element.disabled && !g(this._element).hasClass(Pt) && g(this._menu).hasClass(Lt)) {
        var t = {
          relatedTarget: this._element
        },
            e = g.Event(kt.HIDE, t),
            n = c._getParentFromElement(this._element);

        g(n).trigger(e), e.isDefaultPrevented() || (g(this._menu).toggleClass(Lt), g(n).toggleClass(Lt).trigger(g.Event(kt.HIDDEN, t)));
      }
    }, t.dispose = function () {
      g.removeData(this._element, Dt), g(this._element).off(wt), this._element = null, (this._menu = null) !== this._popper && (this._popper.destroy(), this._popper = null);
    }, t.update = function () {
      this._inNavbar = this._detectNavbar(), null !== this._popper && this._popper.scheduleUpdate();
    }, t._addEventListeners = function () {
      var e = this;
      g(this._element).on(kt.CLICK, function (t) {
        t.preventDefault(), t.stopPropagation(), e.toggle();
      });
    }, t._getConfig = function (t) {
      return t = l({}, this.constructor.Default, g(this._element).data(), t), _.typeCheckConfig(It, t, this.constructor.DefaultType), t;
    }, t._getMenuElement = function () {
      if (!this._menu) {
        var t = c._getParentFromElement(this._element);

        t && (this._menu = t.querySelector(qt));
      }

      return this._menu;
    }, t._getPlacement = function () {
      var t = g(this._element.parentNode),
          e = Vt;
      return t.hasClass(jt) ? (e = Qt, g(this._menu).hasClass(Ut) && (e = Bt)) : t.hasClass(Ht) ? e = Xt : t.hasClass(Rt) ? e = zt : g(this._menu).hasClass(Ut) && (e = Yt), e;
    }, t._detectNavbar = function () {
      return 0 < g(this._element).closest(".navbar").length;
    }, t._getPopperConfig = function () {
      var e = this,
          t = {};
      "function" == typeof this._config.offset ? t.fn = function (t) {
        return t.offsets = l({}, t.offsets, e._config.offset(t.offsets) || {}), t;
      } : t.offset = this._config.offset;
      var n = {
        placement: this._getPlacement(),
        modifiers: {
          offset: t,
          flip: {
            enabled: this._config.flip
          },
          preventOverflow: {
            boundariesElement: this._config.boundary
          }
        }
      };
      return "static" === this._config.display && (n.modifiers.applyStyle = {
        enabled: !1
      }), n;
    }, c._jQueryInterface = function (e) {
      return this.each(function () {
        var t = g(this).data(Dt);

        if (t || (t = new c(this, "object" == _typeof(e) ? e : null), g(this).data(Dt, t)), "string" == typeof e) {
          if ("undefined" == typeof t[e]) throw new TypeError('No method named "' + e + '"');
          t[e]();
        }
      });
    }, c._clearMenus = function (t) {
      if (!t || 3 !== t.which && ("keyup" !== t.type || 9 === t.which)) for (var e = [].slice.call(document.querySelectorAll(xt)), n = 0, i = e.length; n < i; n++) {
        var o = c._getParentFromElement(e[n]),
            r = g(e[n]).data(Dt),
            s = {
          relatedTarget: e[n]
        };

        if (t && "click" === t.type && (s.clickEvent = t), r) {
          var a = r._menu;

          if (g(o).hasClass(Lt) && !(t && ("click" === t.type && /input|textarea/i.test(t.target.tagName) || "keyup" === t.type && 9 === t.which) && g.contains(o, t.target))) {
            var l = g.Event(kt.HIDE, s);
            g(o).trigger(l), l.isDefaultPrevented() || ("ontouchstart" in document.documentElement && g(document.body).children().off("mouseover", null, g.noop), e[n].setAttribute("aria-expanded", "false"), g(a).removeClass(Lt), g(o).removeClass(Lt).trigger(g.Event(kt.HIDDEN, s)));
          }
        }
      }
    }, c._getParentFromElement = function (t) {
      var e,
          n = _.getSelectorFromElement(t);

      return n && (e = document.querySelector(n)), e || t.parentNode;
    }, c._dataApiKeydownHandler = function (t) {
      if ((/input|textarea/i.test(t.target.tagName) ? !(32 === t.which || 27 !== t.which && (40 !== t.which && 38 !== t.which || g(t.target).closest(qt).length)) : Ot.test(t.which)) && (t.preventDefault(), t.stopPropagation(), !this.disabled && !g(this).hasClass(Pt))) {
        var e = c._getParentFromElement(this),
            n = g(e).hasClass(Lt);

        if (n && (!n || 27 !== t.which && 32 !== t.which)) {
          var i = [].slice.call(e.querySelectorAll(Kt));

          if (0 !== i.length) {
            var o = i.indexOf(t.target);
            38 === t.which && 0 < o && o--, 40 === t.which && o < i.length - 1 && o++, o < 0 && (o = 0), i[o].focus();
          }
        } else {
          if (27 === t.which) {
            var r = e.querySelector(xt);
            g(r).trigger("focus");
          }

          g(this).trigger("click");
        }
      }
    }, s(c, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return Gt;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return Jt;
      }
    }]), c;
  }();

  g(document).on(kt.KEYDOWN_DATA_API, xt, Zt._dataApiKeydownHandler).on(kt.KEYDOWN_DATA_API, qt, Zt._dataApiKeydownHandler).on(kt.CLICK_DATA_API + " " + kt.KEYUP_DATA_API, Zt._clearMenus).on(kt.CLICK_DATA_API, xt, function (t) {
    t.preventDefault(), t.stopPropagation(), Zt._jQueryInterface.call(g(this), "toggle");
  }).on(kt.CLICK_DATA_API, Ft, function (t) {
    t.stopPropagation();
  }), g.fn[It] = Zt._jQueryInterface, g.fn[It].Constructor = Zt, g.fn[It].noConflict = function () {
    return g.fn[It] = Nt, Zt._jQueryInterface;
  };

  var $t = "modal",
      te = "bs.modal",
      ee = "." + te,
      ne = g.fn[$t],
      ie = {
    backdrop: !0,
    keyboard: !0,
    focus: !0,
    show: !0
  },
      oe = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    focus: "boolean",
    show: "boolean"
  },
      re = {
    HIDE: "hide" + ee,
    HIDDEN: "hidden" + ee,
    SHOW: "show" + ee,
    SHOWN: "shown" + ee,
    FOCUSIN: "focusin" + ee,
    RESIZE: "resize" + ee,
    CLICK_DISMISS: "click.dismiss" + ee,
    KEYDOWN_DISMISS: "keydown.dismiss" + ee,
    MOUSEUP_DISMISS: "mouseup.dismiss" + ee,
    MOUSEDOWN_DISMISS: "mousedown.dismiss" + ee,
    CLICK_DATA_API: "click" + ee + ".data-api"
  },
      se = "modal-scrollbar-measure",
      ae = "modal-backdrop",
      le = "modal-open",
      ce = "fade",
      he = "show",
      ue = ".modal-dialog",
      fe = '[data-toggle="modal"]',
      de = '[data-dismiss="modal"]',
      ge = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
      _e = ".sticky-top",
      me = function () {
    function o(t, e) {
      this._config = this._getConfig(e), this._element = t, this._dialog = t.querySelector(ue), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollbarWidth = 0;
    }

    var t = o.prototype;
    return t.toggle = function (t) {
      return this._isShown ? this.hide() : this.show(t);
    }, t.show = function (t) {
      var e = this;

      if (!this._isShown && !this._isTransitioning) {
        g(this._element).hasClass(ce) && (this._isTransitioning = !0);
        var n = g.Event(re.SHOW, {
          relatedTarget: t
        });
        g(this._element).trigger(n), this._isShown || n.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), g(this._element).on(re.CLICK_DISMISS, de, function (t) {
          return e.hide(t);
        }), g(this._dialog).on(re.MOUSEDOWN_DISMISS, function () {
          g(e._element).one(re.MOUSEUP_DISMISS, function (t) {
            g(t.target).is(e._element) && (e._ignoreBackdropClick = !0);
          });
        }), this._showBackdrop(function () {
          return e._showElement(t);
        }));
      }
    }, t.hide = function (t) {
      var e = this;

      if (t && t.preventDefault(), this._isShown && !this._isTransitioning) {
        var n = g.Event(re.HIDE);

        if (g(this._element).trigger(n), this._isShown && !n.isDefaultPrevented()) {
          this._isShown = !1;
          var i = g(this._element).hasClass(ce);

          if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), g(document).off(re.FOCUSIN), g(this._element).removeClass(he), g(this._element).off(re.CLICK_DISMISS), g(this._dialog).off(re.MOUSEDOWN_DISMISS), i) {
            var o = _.getTransitionDurationFromElement(this._element);

            g(this._element).one(_.TRANSITION_END, function (t) {
              return e._hideModal(t);
            }).emulateTransitionEnd(o);
          } else this._hideModal();
        }
      }
    }, t.dispose = function () {
      [window, this._element, this._dialog].forEach(function (t) {
        return g(t).off(ee);
      }), g(document).off(re.FOCUSIN), g.removeData(this._element, te), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null;
    }, t.handleUpdate = function () {
      this._adjustDialog();
    }, t._getConfig = function (t) {
      return t = l({}, ie, t), _.typeCheckConfig($t, t, oe), t;
    }, t._showElement = function (t) {
      var e = this,
          n = g(this._element).hasClass(ce);
      this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.scrollTop = 0, n && _.reflow(this._element), g(this._element).addClass(he), this._config.focus && this._enforceFocus();

      var i = g.Event(re.SHOWN, {
        relatedTarget: t
      }),
          o = function o() {
        e._config.focus && e._element.focus(), e._isTransitioning = !1, g(e._element).trigger(i);
      };

      if (n) {
        var r = _.getTransitionDurationFromElement(this._dialog);

        g(this._dialog).one(_.TRANSITION_END, o).emulateTransitionEnd(r);
      } else o();
    }, t._enforceFocus = function () {
      var e = this;
      g(document).off(re.FOCUSIN).on(re.FOCUSIN, function (t) {
        document !== t.target && e._element !== t.target && 0 === g(e._element).has(t.target).length && e._element.focus();
      });
    }, t._setEscapeEvent = function () {
      var e = this;
      this._isShown && this._config.keyboard ? g(this._element).on(re.KEYDOWN_DISMISS, function (t) {
        27 === t.which && (t.preventDefault(), e.hide());
      }) : this._isShown || g(this._element).off(re.KEYDOWN_DISMISS);
    }, t._setResizeEvent = function () {
      var e = this;
      this._isShown ? g(window).on(re.RESIZE, function (t) {
        return e.handleUpdate(t);
      }) : g(window).off(re.RESIZE);
    }, t._hideModal = function () {
      var t = this;
      this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._isTransitioning = !1, this._showBackdrop(function () {
        g(document.body).removeClass(le), t._resetAdjustments(), t._resetScrollbar(), g(t._element).trigger(re.HIDDEN);
      });
    }, t._removeBackdrop = function () {
      this._backdrop && (g(this._backdrop).remove(), this._backdrop = null);
    }, t._showBackdrop = function (t) {
      var e = this,
          n = g(this._element).hasClass(ce) ? ce : "";

      if (this._isShown && this._config.backdrop) {
        if (this._backdrop = document.createElement("div"), this._backdrop.className = ae, n && this._backdrop.classList.add(n), g(this._backdrop).appendTo(document.body), g(this._element).on(re.CLICK_DISMISS, function (t) {
          e._ignoreBackdropClick ? e._ignoreBackdropClick = !1 : t.target === t.currentTarget && ("static" === e._config.backdrop ? e._element.focus() : e.hide());
        }), n && _.reflow(this._backdrop), g(this._backdrop).addClass(he), !t) return;
        if (!n) return void t();

        var i = _.getTransitionDurationFromElement(this._backdrop);

        g(this._backdrop).one(_.TRANSITION_END, t).emulateTransitionEnd(i);
      } else if (!this._isShown && this._backdrop) {
        g(this._backdrop).removeClass(he);

        var o = function o() {
          e._removeBackdrop(), t && t();
        };

        if (g(this._element).hasClass(ce)) {
          var r = _.getTransitionDurationFromElement(this._backdrop);

          g(this._backdrop).one(_.TRANSITION_END, o).emulateTransitionEnd(r);
        } else o();
      } else t && t();
    }, t._adjustDialog = function () {
      var t = this._element.scrollHeight > document.documentElement.clientHeight;
      !this._isBodyOverflowing && t && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), this._isBodyOverflowing && !t && (this._element.style.paddingRight = this._scrollbarWidth + "px");
    }, t._resetAdjustments = function () {
      this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
    }, t._checkScrollbar = function () {
      var t = document.body.getBoundingClientRect();
      this._isBodyOverflowing = t.left + t.right < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth();
    }, t._setScrollbar = function () {
      var o = this;

      if (this._isBodyOverflowing) {
        var t = [].slice.call(document.querySelectorAll(ge)),
            e = [].slice.call(document.querySelectorAll(_e));
        g(t).each(function (t, e) {
          var n = e.style.paddingRight,
              i = g(e).css("padding-right");
          g(e).data("padding-right", n).css("padding-right", parseFloat(i) + o._scrollbarWidth + "px");
        }), g(e).each(function (t, e) {
          var n = e.style.marginRight,
              i = g(e).css("margin-right");
          g(e).data("margin-right", n).css("margin-right", parseFloat(i) - o._scrollbarWidth + "px");
        });
        var n = document.body.style.paddingRight,
            i = g(document.body).css("padding-right");
        g(document.body).data("padding-right", n).css("padding-right", parseFloat(i) + this._scrollbarWidth + "px");
      }

      g(document.body).addClass(le);
    }, t._resetScrollbar = function () {
      var t = [].slice.call(document.querySelectorAll(ge));
      g(t).each(function (t, e) {
        var n = g(e).data("padding-right");
        g(e).removeData("padding-right"), e.style.paddingRight = n || "";
      });
      var e = [].slice.call(document.querySelectorAll("" + _e));
      g(e).each(function (t, e) {
        var n = g(e).data("margin-right");
        "undefined" != typeof n && g(e).css("margin-right", n).removeData("margin-right");
      });
      var n = g(document.body).data("padding-right");
      g(document.body).removeData("padding-right"), document.body.style.paddingRight = n || "";
    }, t._getScrollbarWidth = function () {
      var t = document.createElement("div");
      t.className = se, document.body.appendChild(t);
      var e = t.getBoundingClientRect().width - t.clientWidth;
      return document.body.removeChild(t), e;
    }, o._jQueryInterface = function (n, i) {
      return this.each(function () {
        var t = g(this).data(te),
            e = l({}, ie, g(this).data(), "object" == _typeof(n) && n ? n : {});

        if (t || (t = new o(this, e), g(this).data(te, t)), "string" == typeof n) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n](i);
        } else e.show && t.show(i);
      });
    }, s(o, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return ie;
      }
    }]), o;
  }();

  g(document).on(re.CLICK_DATA_API, fe, function (t) {
    var e,
        n = this,
        i = _.getSelectorFromElement(this);

    i && (e = document.querySelector(i));
    var o = g(e).data(te) ? "toggle" : l({}, g(e).data(), g(this).data());
    "A" !== this.tagName && "AREA" !== this.tagName || t.preventDefault();
    var r = g(e).one(re.SHOW, function (t) {
      t.isDefaultPrevented() || r.one(re.HIDDEN, function () {
        g(n).is(":visible") && n.focus();
      });
    });

    me._jQueryInterface.call(g(e), o, this);
  }), g.fn[$t] = me._jQueryInterface, g.fn[$t].Constructor = me, g.fn[$t].noConflict = function () {
    return g.fn[$t] = ne, me._jQueryInterface;
  };

  var pe = "tooltip",
      ve = "bs.tooltip",
      Ee = "." + ve,
      ye = g.fn[pe],
      Ce = "bs-tooltip",
      Te = new RegExp("(^|\\s)" + Ce + "\\S+", "g"),
      Se = {
    animation: "boolean",
    template: "string",
    title: "(string|element|function)",
    trigger: "string",
    delay: "(number|object)",
    html: "boolean",
    selector: "(string|boolean)",
    placement: "(string|function)",
    offset: "(number|string)",
    container: "(string|element|boolean)",
    fallbackPlacement: "(string|array)",
    boundary: "(string|element)"
  },
      be = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: "right",
    BOTTOM: "bottom",
    LEFT: "left"
  },
      Ie = {
    animation: !0,
    template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: "hover focus",
    title: "",
    delay: 0,
    html: !1,
    selector: !1,
    placement: "top",
    offset: 0,
    container: !1,
    fallbackPlacement: "flip",
    boundary: "scrollParent"
  },
      De = "show",
      we = "out",
      Ae = {
    HIDE: "hide" + Ee,
    HIDDEN: "hidden" + Ee,
    SHOW: "show" + Ee,
    SHOWN: "shown" + Ee,
    INSERTED: "inserted" + Ee,
    CLICK: "click" + Ee,
    FOCUSIN: "focusin" + Ee,
    FOCUSOUT: "focusout" + Ee,
    MOUSEENTER: "mouseenter" + Ee,
    MOUSELEAVE: "mouseleave" + Ee
  },
      Ne = "fade",
      Oe = "show",
      ke = ".tooltip-inner",
      Pe = ".arrow",
      Le = "hover",
      je = "focus",
      He = "click",
      Re = "manual",
      Ue = function () {
    function i(t, e) {
      if ("undefined" == typeof u) throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)");
      this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners();
    }

    var t = i.prototype;
    return t.enable = function () {
      this._isEnabled = !0;
    }, t.disable = function () {
      this._isEnabled = !1;
    }, t.toggleEnabled = function () {
      this._isEnabled = !this._isEnabled;
    }, t.toggle = function (t) {
      if (this._isEnabled) if (t) {
        var e = this.constructor.DATA_KEY,
            n = g(t.currentTarget).data(e);
        n || (n = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(e, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n);
      } else {
        if (g(this.getTipElement()).hasClass(Oe)) return void this._leave(null, this);

        this._enter(null, this);
      }
    }, t.dispose = function () {
      clearTimeout(this._timeout), g.removeData(this.element, this.constructor.DATA_KEY), g(this.element).off(this.constructor.EVENT_KEY), g(this.element).closest(".modal").off("hide.bs.modal"), this.tip && g(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, (this._activeTrigger = null) !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null;
    }, t.show = function () {
      var e = this;
      if ("none" === g(this.element).css("display")) throw new Error("Please use show on visible elements");
      var t = g.Event(this.constructor.Event.SHOW);

      if (this.isWithContent() && this._isEnabled) {
        g(this.element).trigger(t);

        var n = _.findShadowRoot(this.element),
            i = g.contains(null !== n ? n : this.element.ownerDocument.documentElement, this.element);

        if (t.isDefaultPrevented() || !i) return;

        var o = this.getTipElement(),
            r = _.getUID(this.constructor.NAME);

        o.setAttribute("id", r), this.element.setAttribute("aria-describedby", r), this.setContent(), this.config.animation && g(o).addClass(Ne);

        var s = "function" == typeof this.config.placement ? this.config.placement.call(this, o, this.element) : this.config.placement,
            a = this._getAttachment(s);

        this.addAttachmentClass(a);

        var l = this._getContainer();

        g(o).data(this.constructor.DATA_KEY, this), g.contains(this.element.ownerDocument.documentElement, this.tip) || g(o).appendTo(l), g(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new u(this.element, o, {
          placement: a,
          modifiers: {
            offset: {
              offset: this.config.offset
            },
            flip: {
              behavior: this.config.fallbackPlacement
            },
            arrow: {
              element: Pe
            },
            preventOverflow: {
              boundariesElement: this.config.boundary
            }
          },
          onCreate: function onCreate(t) {
            t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t);
          },
          onUpdate: function onUpdate(t) {
            return e._handlePopperPlacementChange(t);
          }
        }), g(o).addClass(Oe), "ontouchstart" in document.documentElement && g(document.body).children().on("mouseover", null, g.noop);

        var c = function c() {
          e.config.animation && e._fixTransition();
          var t = e._hoverState;
          e._hoverState = null, g(e.element).trigger(e.constructor.Event.SHOWN), t === we && e._leave(null, e);
        };

        if (g(this.tip).hasClass(Ne)) {
          var h = _.getTransitionDurationFromElement(this.tip);

          g(this.tip).one(_.TRANSITION_END, c).emulateTransitionEnd(h);
        } else c();
      }
    }, t.hide = function (t) {
      var e = this,
          n = this.getTipElement(),
          i = g.Event(this.constructor.Event.HIDE),
          o = function o() {
        e._hoverState !== De && n.parentNode && n.parentNode.removeChild(n), e._cleanTipClass(), e.element.removeAttribute("aria-describedby"), g(e.element).trigger(e.constructor.Event.HIDDEN), null !== e._popper && e._popper.destroy(), t && t();
      };

      if (g(this.element).trigger(i), !i.isDefaultPrevented()) {
        if (g(n).removeClass(Oe), "ontouchstart" in document.documentElement && g(document.body).children().off("mouseover", null, g.noop), this._activeTrigger[He] = !1, this._activeTrigger[je] = !1, this._activeTrigger[Le] = !1, g(this.tip).hasClass(Ne)) {
          var r = _.getTransitionDurationFromElement(n);

          g(n).one(_.TRANSITION_END, o).emulateTransitionEnd(r);
        } else o();

        this._hoverState = "";
      }
    }, t.update = function () {
      null !== this._popper && this._popper.scheduleUpdate();
    }, t.isWithContent = function () {
      return Boolean(this.getTitle());
    }, t.addAttachmentClass = function (t) {
      g(this.getTipElement()).addClass(Ce + "-" + t);
    }, t.getTipElement = function () {
      return this.tip = this.tip || g(this.config.template)[0], this.tip;
    }, t.setContent = function () {
      var t = this.getTipElement();
      this.setElementContent(g(t.querySelectorAll(ke)), this.getTitle()), g(t).removeClass(Ne + " " + Oe);
    }, t.setElementContent = function (t, e) {
      var n = this.config.html;
      "object" == _typeof(e) && (e.nodeType || e.jquery) ? n ? g(e).parent().is(t) || t.empty().append(e) : t.text(g(e).text()) : t[n ? "html" : "text"](e);
    }, t.getTitle = function () {
      var t = this.element.getAttribute("data-original-title");
      return t || (t = "function" == typeof this.config.title ? this.config.title.call(this.element) : this.config.title), t;
    }, t._getContainer = function () {
      return !1 === this.config.container ? document.body : _.isElement(this.config.container) ? g(this.config.container) : g(document).find(this.config.container);
    }, t._getAttachment = function (t) {
      return be[t.toUpperCase()];
    }, t._setListeners = function () {
      var i = this;
      this.config.trigger.split(" ").forEach(function (t) {
        if ("click" === t) g(i.element).on(i.constructor.Event.CLICK, i.config.selector, function (t) {
          return i.toggle(t);
        });else if (t !== Re) {
          var e = t === Le ? i.constructor.Event.MOUSEENTER : i.constructor.Event.FOCUSIN,
              n = t === Le ? i.constructor.Event.MOUSELEAVE : i.constructor.Event.FOCUSOUT;
          g(i.element).on(e, i.config.selector, function (t) {
            return i._enter(t);
          }).on(n, i.config.selector, function (t) {
            return i._leave(t);
          });
        }
      }), g(this.element).closest(".modal").on("hide.bs.modal", function () {
        i.element && i.hide();
      }), this.config.selector ? this.config = l({}, this.config, {
        trigger: "manual",
        selector: ""
      }) : this._fixTitle();
    }, t._fixTitle = function () {
      var t = _typeof(this.element.getAttribute("data-original-title"));

      (this.element.getAttribute("title") || "string" !== t) && (this.element.setAttribute("data-original-title", this.element.getAttribute("title") || ""), this.element.setAttribute("title", ""));
    }, t._enter = function (t, e) {
      var n = this.constructor.DATA_KEY;
      (e = e || g(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(n, e)), t && (e._activeTrigger["focusin" === t.type ? je : Le] = !0), g(e.getTipElement()).hasClass(Oe) || e._hoverState === De ? e._hoverState = De : (clearTimeout(e._timeout), e._hoverState = De, e.config.delay && e.config.delay.show ? e._timeout = setTimeout(function () {
        e._hoverState === De && e.show();
      }, e.config.delay.show) : e.show());
    }, t._leave = function (t, e) {
      var n = this.constructor.DATA_KEY;
      (e = e || g(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(n, e)), t && (e._activeTrigger["focusout" === t.type ? je : Le] = !1), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = we, e.config.delay && e.config.delay.hide ? e._timeout = setTimeout(function () {
        e._hoverState === we && e.hide();
      }, e.config.delay.hide) : e.hide());
    }, t._isWithActiveTrigger = function () {
      for (var t in this._activeTrigger) {
        if (this._activeTrigger[t]) return !0;
      }

      return !1;
    }, t._getConfig = function (t) {
      return "number" == typeof (t = l({}, this.constructor.Default, g(this.element).data(), "object" == _typeof(t) && t ? t : {})).delay && (t.delay = {
        show: t.delay,
        hide: t.delay
      }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), _.typeCheckConfig(pe, t, this.constructor.DefaultType), t;
    }, t._getDelegateConfig = function () {
      var t = {};
      if (this.config) for (var e in this.config) {
        this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]);
      }
      return t;
    }, t._cleanTipClass = function () {
      var t = g(this.getTipElement()),
          e = t.attr("class").match(Te);
      null !== e && e.length && t.removeClass(e.join(""));
    }, t._handlePopperPlacementChange = function (t) {
      var e = t.instance;
      this.tip = e.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement));
    }, t._fixTransition = function () {
      var t = this.getTipElement(),
          e = this.config.animation;
      null === t.getAttribute("x-placement") && (g(t).removeClass(Ne), this.config.animation = !1, this.hide(), this.show(), this.config.animation = e);
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = g(this).data(ve),
            e = "object" == _typeof(n) && n;

        if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), g(this).data(ve, t)), "string" == typeof n)) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n]();
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return Ie;
      }
    }, {
      key: "NAME",
      get: function get() {
        return pe;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return ve;
      }
    }, {
      key: "Event",
      get: function get() {
        return Ae;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return Ee;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return Se;
      }
    }]), i;
  }();

  g.fn[pe] = Ue._jQueryInterface, g.fn[pe].Constructor = Ue, g.fn[pe].noConflict = function () {
    return g.fn[pe] = ye, Ue._jQueryInterface;
  };

  var We = "popover",
      xe = "bs.popover",
      Fe = "." + xe,
      qe = g.fn[We],
      Me = "bs-popover",
      Ke = new RegExp("(^|\\s)" + Me + "\\S+", "g"),
      Qe = l({}, Ue.Default, {
    placement: "right",
    trigger: "click",
    content: "",
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
  }),
      Be = l({}, Ue.DefaultType, {
    content: "(string|element|function)"
  }),
      Ve = "fade",
      Ye = "show",
      Xe = ".popover-header",
      ze = ".popover-body",
      Ge = {
    HIDE: "hide" + Fe,
    HIDDEN: "hidden" + Fe,
    SHOW: "show" + Fe,
    SHOWN: "shown" + Fe,
    INSERTED: "inserted" + Fe,
    CLICK: "click" + Fe,
    FOCUSIN: "focusin" + Fe,
    FOCUSOUT: "focusout" + Fe,
    MOUSEENTER: "mouseenter" + Fe,
    MOUSELEAVE: "mouseleave" + Fe
  },
      Je = function (t) {
    var e, n;

    function i() {
      return t.apply(this, arguments) || this;
    }

    n = t, (e = i).prototype = Object.create(n.prototype), (e.prototype.constructor = e).__proto__ = n;
    var o = i.prototype;
    return o.isWithContent = function () {
      return this.getTitle() || this._getContent();
    }, o.addAttachmentClass = function (t) {
      g(this.getTipElement()).addClass(Me + "-" + t);
    }, o.getTipElement = function () {
      return this.tip = this.tip || g(this.config.template)[0], this.tip;
    }, o.setContent = function () {
      var t = g(this.getTipElement());
      this.setElementContent(t.find(Xe), this.getTitle());

      var e = this._getContent();

      "function" == typeof e && (e = e.call(this.element)), this.setElementContent(t.find(ze), e), t.removeClass(Ve + " " + Ye);
    }, o._getContent = function () {
      return this.element.getAttribute("data-content") || this.config.content;
    }, o._cleanTipClass = function () {
      var t = g(this.getTipElement()),
          e = t.attr("class").match(Ke);
      null !== e && 0 < e.length && t.removeClass(e.join(""));
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = g(this).data(xe),
            e = "object" == _typeof(n) ? n : null;

        if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), g(this).data(xe, t)), "string" == typeof n)) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n]();
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return Qe;
      }
    }, {
      key: "NAME",
      get: function get() {
        return We;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return xe;
      }
    }, {
      key: "Event",
      get: function get() {
        return Ge;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return Fe;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return Be;
      }
    }]), i;
  }(Ue);

  g.fn[We] = Je._jQueryInterface, g.fn[We].Constructor = Je, g.fn[We].noConflict = function () {
    return g.fn[We] = qe, Je._jQueryInterface;
  };

  var Ze = "scrollspy",
      $e = "bs.scrollspy",
      tn = "." + $e,
      en = g.fn[Ze],
      nn = {
    offset: 10,
    method: "auto",
    target: ""
  },
      on = {
    offset: "number",
    method: "string",
    target: "(string|element)"
  },
      rn = {
    ACTIVATE: "activate" + tn,
    SCROLL: "scroll" + tn,
    LOAD_DATA_API: "load" + tn + ".data-api"
  },
      sn = "dropdown-item",
      an = "active",
      ln = '[data-spy="scroll"]',
      cn = ".nav, .list-group",
      hn = ".nav-link",
      un = ".nav-item",
      fn = ".list-group-item",
      dn = ".dropdown",
      gn = ".dropdown-item",
      _n = ".dropdown-toggle",
      mn = "offset",
      pn = "position",
      vn = function () {
    function n(t, e) {
      var n = this;
      this._element = t, this._scrollElement = "BODY" === t.tagName ? window : t, this._config = this._getConfig(e), this._selector = this._config.target + " " + hn + "," + this._config.target + " " + fn + "," + this._config.target + " " + gn, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, g(this._scrollElement).on(rn.SCROLL, function (t) {
        return n._process(t);
      }), this.refresh(), this._process();
    }

    var t = n.prototype;
    return t.refresh = function () {
      var e = this,
          t = this._scrollElement === this._scrollElement.window ? mn : pn,
          o = "auto" === this._config.method ? t : this._config.method,
          r = o === pn ? this._getScrollTop() : 0;
      this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map(function (t) {
        var e,
            n = _.getSelectorFromElement(t);

        if (n && (e = document.querySelector(n)), e) {
          var i = e.getBoundingClientRect();
          if (i.width || i.height) return [g(e)[o]().top + r, n];
        }

        return null;
      }).filter(function (t) {
        return t;
      }).sort(function (t, e) {
        return t[0] - e[0];
      }).forEach(function (t) {
        e._offsets.push(t[0]), e._targets.push(t[1]);
      });
    }, t.dispose = function () {
      g.removeData(this._element, $e), g(this._scrollElement).off(tn), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null;
    }, t._getConfig = function (t) {
      if ("string" != typeof (t = l({}, nn, "object" == _typeof(t) && t ? t : {})).target) {
        var e = g(t.target).attr("id");
        e || (e = _.getUID(Ze), g(t.target).attr("id", e)), t.target = "#" + e;
      }

      return _.typeCheckConfig(Ze, t, on), t;
    }, t._getScrollTop = function () {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    }, t._getScrollHeight = function () {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }, t._getOffsetHeight = function () {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    }, t._process = function () {
      var t = this._getScrollTop() + this._config.offset,
          e = this._getScrollHeight(),
          n = this._config.offset + e - this._getOffsetHeight();

      if (this._scrollHeight !== e && this.refresh(), n <= t) {
        var i = this._targets[this._targets.length - 1];
        this._activeTarget !== i && this._activate(i);
      } else {
        if (this._activeTarget && t < this._offsets[0] && 0 < this._offsets[0]) return this._activeTarget = null, void this._clear();

        for (var o = this._offsets.length; o--;) {
          this._activeTarget !== this._targets[o] && t >= this._offsets[o] && ("undefined" == typeof this._offsets[o + 1] || t < this._offsets[o + 1]) && this._activate(this._targets[o]);
        }
      }
    }, t._activate = function (e) {
      this._activeTarget = e, this._clear();

      var t = this._selector.split(",").map(function (t) {
        return t + '[data-target="' + e + '"],' + t + '[href="' + e + '"]';
      }),
          n = g([].slice.call(document.querySelectorAll(t.join(","))));

      n.hasClass(sn) ? (n.closest(dn).find(_n).addClass(an), n.addClass(an)) : (n.addClass(an), n.parents(cn).prev(hn + ", " + fn).addClass(an), n.parents(cn).prev(un).children(hn).addClass(an)), g(this._scrollElement).trigger(rn.ACTIVATE, {
        relatedTarget: e
      });
    }, t._clear = function () {
      [].slice.call(document.querySelectorAll(this._selector)).filter(function (t) {
        return t.classList.contains(an);
      }).forEach(function (t) {
        return t.classList.remove(an);
      });
    }, n._jQueryInterface = function (e) {
      return this.each(function () {
        var t = g(this).data($e);

        if (t || (t = new n(this, "object" == _typeof(e) && e), g(this).data($e, t)), "string" == typeof e) {
          if ("undefined" == typeof t[e]) throw new TypeError('No method named "' + e + '"');
          t[e]();
        }
      });
    }, s(n, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return nn;
      }
    }]), n;
  }();

  g(window).on(rn.LOAD_DATA_API, function () {
    for (var t = [].slice.call(document.querySelectorAll(ln)), e = t.length; e--;) {
      var n = g(t[e]);

      vn._jQueryInterface.call(n, n.data());
    }
  }), g.fn[Ze] = vn._jQueryInterface, g.fn[Ze].Constructor = vn, g.fn[Ze].noConflict = function () {
    return g.fn[Ze] = en, vn._jQueryInterface;
  };

  var En = "bs.tab",
      yn = "." + En,
      Cn = g.fn.tab,
      Tn = {
    HIDE: "hide" + yn,
    HIDDEN: "hidden" + yn,
    SHOW: "show" + yn,
    SHOWN: "shown" + yn,
    CLICK_DATA_API: "click" + yn + ".data-api"
  },
      Sn = "dropdown-menu",
      bn = "active",
      In = "disabled",
      Dn = "fade",
      wn = "show",
      An = ".dropdown",
      Nn = ".nav, .list-group",
      On = ".active",
      kn = "> li > .active",
      Pn = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
      Ln = ".dropdown-toggle",
      jn = "> .dropdown-menu .active",
      Hn = function () {
    function i(t) {
      this._element = t;
    }

    var t = i.prototype;
    return t.show = function () {
      var n = this;

      if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && g(this._element).hasClass(bn) || g(this._element).hasClass(In))) {
        var t,
            i,
            e = g(this._element).closest(Nn)[0],
            o = _.getSelectorFromElement(this._element);

        if (e) {
          var r = "UL" === e.nodeName || "OL" === e.nodeName ? kn : On;
          i = (i = g.makeArray(g(e).find(r)))[i.length - 1];
        }

        var s = g.Event(Tn.HIDE, {
          relatedTarget: this._element
        }),
            a = g.Event(Tn.SHOW, {
          relatedTarget: i
        });

        if (i && g(i).trigger(s), g(this._element).trigger(a), !a.isDefaultPrevented() && !s.isDefaultPrevented()) {
          o && (t = document.querySelector(o)), this._activate(this._element, e);

          var l = function l() {
            var t = g.Event(Tn.HIDDEN, {
              relatedTarget: n._element
            }),
                e = g.Event(Tn.SHOWN, {
              relatedTarget: i
            });
            g(i).trigger(t), g(n._element).trigger(e);
          };

          t ? this._activate(t, t.parentNode, l) : l();
        }
      }
    }, t.dispose = function () {
      g.removeData(this._element, En), this._element = null;
    }, t._activate = function (t, e, n) {
      var i = this,
          o = (!e || "UL" !== e.nodeName && "OL" !== e.nodeName ? g(e).children(On) : g(e).find(kn))[0],
          r = n && o && g(o).hasClass(Dn),
          s = function s() {
        return i._transitionComplete(t, o, n);
      };

      if (o && r) {
        var a = _.getTransitionDurationFromElement(o);

        g(o).removeClass(wn).one(_.TRANSITION_END, s).emulateTransitionEnd(a);
      } else s();
    }, t._transitionComplete = function (t, e, n) {
      if (e) {
        g(e).removeClass(bn);
        var i = g(e.parentNode).find(jn)[0];
        i && g(i).removeClass(bn), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !1);
      }

      if (g(t).addClass(bn), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0), _.reflow(t), g(t).addClass(wn), t.parentNode && g(t.parentNode).hasClass(Sn)) {
        var o = g(t).closest(An)[0];

        if (o) {
          var r = [].slice.call(o.querySelectorAll(Ln));
          g(r).addClass(bn);
        }

        t.setAttribute("aria-expanded", !0);
      }

      n && n();
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = g(this),
            e = t.data(En);

        if (e || (e = new i(this), t.data(En, e)), "string" == typeof n) {
          if ("undefined" == typeof e[n]) throw new TypeError('No method named "' + n + '"');
          e[n]();
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }]), i;
  }();

  g(document).on(Tn.CLICK_DATA_API, Pn, function (t) {
    t.preventDefault(), Hn._jQueryInterface.call(g(this), "show");
  }), g.fn.tab = Hn._jQueryInterface, g.fn.tab.Constructor = Hn, g.fn.tab.noConflict = function () {
    return g.fn.tab = Cn, Hn._jQueryInterface;
  };

  var Rn = "toast",
      Un = "bs.toast",
      Wn = "." + Un,
      xn = g.fn[Rn],
      Fn = {
    CLICK_DISMISS: "click.dismiss" + Wn,
    HIDE: "hide" + Wn,
    HIDDEN: "hidden" + Wn,
    SHOW: "show" + Wn,
    SHOWN: "shown" + Wn
  },
      qn = "fade",
      Mn = "hide",
      Kn = "show",
      Qn = "showing",
      Bn = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
  },
      Vn = {
    animation: !0,
    autohide: !0,
    delay: 500
  },
      Yn = '[data-dismiss="toast"]',
      Xn = function () {
    function i(t, e) {
      this._element = t, this._config = this._getConfig(e), this._timeout = null, this._setListeners();
    }

    var t = i.prototype;
    return t.show = function () {
      var t = this;
      g(this._element).trigger(Fn.SHOW), this._config.animation && this._element.classList.add(qn);

      var e = function e() {
        t._element.classList.remove(Qn), t._element.classList.add(Kn), g(t._element).trigger(Fn.SHOWN), t._config.autohide && t.hide();
      };

      if (this._element.classList.remove(Mn), this._element.classList.add(Qn), this._config.animation) {
        var n = _.getTransitionDurationFromElement(this._element);

        g(this._element).one(_.TRANSITION_END, e).emulateTransitionEnd(n);
      } else e();
    }, t.hide = function (t) {
      var e = this;
      this._element.classList.contains(Kn) && (g(this._element).trigger(Fn.HIDE), t ? this._close() : this._timeout = setTimeout(function () {
        e._close();
      }, this._config.delay));
    }, t.dispose = function () {
      clearTimeout(this._timeout), this._timeout = null, this._element.classList.contains(Kn) && this._element.classList.remove(Kn), g(this._element).off(Fn.CLICK_DISMISS), g.removeData(this._element, Un), this._element = null, this._config = null;
    }, t._getConfig = function (t) {
      return t = l({}, Vn, g(this._element).data(), "object" == _typeof(t) && t ? t : {}), _.typeCheckConfig(Rn, t, this.constructor.DefaultType), t;
    }, t._setListeners = function () {
      var t = this;
      g(this._element).on(Fn.CLICK_DISMISS, Yn, function () {
        return t.hide(!0);
      });
    }, t._close = function () {
      var t = this,
          e = function e() {
        t._element.classList.add(Mn), g(t._element).trigger(Fn.HIDDEN);
      };

      if (this._element.classList.remove(Kn), this._config.animation) {
        var n = _.getTransitionDurationFromElement(this._element);

        g(this._element).one(_.TRANSITION_END, e).emulateTransitionEnd(n);
      } else e();
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = g(this),
            e = t.data(Un);

        if (e || (e = new i(this, "object" == _typeof(n) && n), t.data(Un, e)), "string" == typeof n) {
          if ("undefined" == typeof e[n]) throw new TypeError('No method named "' + n + '"');
          e[n](this);
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.2.1";
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return Bn;
      }
    }]), i;
  }();

  g.fn[Rn] = Xn._jQueryInterface, g.fn[Rn].Constructor = Xn, g.fn[Rn].noConflict = function () {
    return g.fn[Rn] = xn, Xn._jQueryInterface;
  }, function () {
    if ("undefined" == typeof g) throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
    var t = g.fn.jquery.split(" ")[0].split(".");
    if (t[0] < 2 && t[1] < 9 || 1 === t[0] && 9 === t[1] && t[2] < 1 || 4 <= t[0]) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0");
  }(), t.Util = _, t.Alert = p, t.Button = P, t.Carousel = lt, t.Collapse = bt, t.Dropdown = Zt, t.Modal = me, t.Popover = Je, t.Scrollspy = vn, t.Tab = Hn, t.Toast = Xn, t.Tooltip = Ue, Object.defineProperty(t, "__esModule", {
    value: !0
  });
});

/***/ }),

/***/ "./assets/js/lib/counterup/counterup.min.js":
/*!**************************************************!*\
  !*** ./assets/js/lib/counterup/counterup.min.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * jquery.counterup.js 2.1.0
 *
 * Copyright 2013, Benjamin Intal http://gambit.ph @bfintal
 * Released under the GPL v2 License
 *
 * Amended by Jeremy Paris, Ciro Mattia Gonano and others
 *
 * Date: Feb 24, 2017
 */
(function ($) {
  "use strict";

  $.fn.counterUp = function (options) {
    var settings = $.extend({
      time: 400,
      delay: 10,
      offset: 100,
      beginAt: 0,
      formatter: false,
      context: "window",
      callback: function callback() {}
    }, options),
        s;
    return this.each(function () {
      var $this = $(this),
          counter = {
        time: $(this).data("counterup-time") || settings.time,
        delay: $(this).data("counterup-delay") || settings.delay,
        offset: $(this).data("counterup-offset") || settings.offset,
        beginAt: $(this).data("counterup-beginat") || settings.beginAt,
        context: $(this).data("counterup-context") || settings.context
      };

      var counterUpper = function counterUpper() {
        var nums = [];
        var divisions = counter.time / counter.delay;
        var num = $(this).attr("data-num") ? $(this).attr("data-num") : $this.text();
        var isComma = /[0-9]+,[0-9]+/.test(num);
        num = num.replace(/,/g, "");
        var decimalPlaces = (num.split(".")[1] || []).length;
        if (counter.beginAt > num) counter.beginAt = num;
        var isTime = /[0-9]+:[0-9]+:[0-9]+/.test(num);

        if (isTime) {
          var times = num.split(":"),
              m = 1;
          s = 0;

          while (times.length > 0) {
            s += m * parseInt(times.pop(), 10);
            m *= 60;
          }
        }

        for (var i = divisions; i >= counter.beginAt / num * divisions; i--) {
          var newNum = parseFloat(num / divisions * i).toFixed(decimalPlaces);

          if (isTime) {
            newNum = parseInt(s / divisions * i);
            var hours = parseInt(newNum / 3600) % 24;
            var minutes = parseInt(newNum / 60) % 60;
            var seconds = parseInt(newNum % 60, 10);
            newNum = (hours < 10 ? "0" + hours : hours) + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
          }

          if (isComma) {
            while (/(\d+)(\d{3})/.test(newNum.toString())) {
              newNum = newNum.toString().replace(/(\d+)(\d{3})/, "$1" + "," + "$2");
            }
          }

          if (settings.formatter) {
            newNum = settings.formatter.call(this, newNum);
          }

          nums.unshift(newNum);
        }

        $this.data("counterup-nums", nums);
        $this.text(counter.beginAt);

        var f = function f() {
          if (!$this.data("counterup-nums")) {
            settings.callback.call(this);
            return;
          }

          $this.html($this.data("counterup-nums").shift());

          if ($this.data("counterup-nums").length) {
            setTimeout($this.data("counterup-func"), counter.delay);
          } else {
            $this.data("counterup-nums", null);
            $this.data("counterup-func", null);
            settings.callback.call(this);
          }
        };

        $this.data("counterup-func", f);
        setTimeout($this.data("counterup-func"), counter.delay);
      };

      $this.waypoint(function (direction) {
        counterUpper();
        this.destroy();
      }, {
        offset: counter.offset + "%",
        context: counter.context
      });
    });
  };
})(jQuery);

/***/ }),

/***/ "./assets/js/lib/easing/easing.min.js":
/*!********************************************!*\
  !*** ./assets/js/lib/easing/easing.min.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (n) {
   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (e) {
    return n(e);
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
}(function (n) {
  function e(n) {
    var e = 7.5625,
        t = 2.75;
    return n < 1 / t ? e * n * n : n < 2 / t ? e * (n -= 1.5 / t) * n + .75 : n < 2.5 / t ? e * (n -= 2.25 / t) * n + .9375 : e * (n -= 2.625 / t) * n + .984375;
  }

  void 0 !== n.easing && (n.easing.jswing = n.easing.swing);
  var t = Math.pow,
      u = Math.sqrt,
      r = Math.sin,
      i = Math.cos,
      a = Math.PI,
      c = 1.70158,
      o = 1.525 * c,
      s = 2 * a / 3,
      f = 2 * a / 4.5;
  n.extend(n.easing, {
    def: "easeOutQuad",
    swing: function swing(e) {
      return n.easing[n.easing.def](e);
    },
    easeInQuad: function easeInQuad(n) {
      return n * n;
    },
    easeOutQuad: function easeOutQuad(n) {
      return 1 - (1 - n) * (1 - n);
    },
    easeInOutQuad: function easeInOutQuad(n) {
      return n < .5 ? 2 * n * n : 1 - t(-2 * n + 2, 2) / 2;
    },
    easeInCubic: function easeInCubic(n) {
      return n * n * n;
    },
    easeOutCubic: function easeOutCubic(n) {
      return 1 - t(1 - n, 3);
    },
    easeInOutCubic: function easeInOutCubic(n) {
      return n < .5 ? 4 * n * n * n : 1 - t(-2 * n + 2, 3) / 2;
    },
    easeInQuart: function easeInQuart(n) {
      return n * n * n * n;
    },
    easeOutQuart: function easeOutQuart(n) {
      return 1 - t(1 - n, 4);
    },
    easeInOutQuart: function easeInOutQuart(n) {
      return n < .5 ? 8 * n * n * n * n : 1 - t(-2 * n + 2, 4) / 2;
    },
    easeInQuint: function easeInQuint(n) {
      return n * n * n * n * n;
    },
    easeOutQuint: function easeOutQuint(n) {
      return 1 - t(1 - n, 5);
    },
    easeInOutQuint: function easeInOutQuint(n) {
      return n < .5 ? 16 * n * n * n * n * n : 1 - t(-2 * n + 2, 5) / 2;
    },
    easeInSine: function easeInSine(n) {
      return 1 - i(n * a / 2);
    },
    easeOutSine: function easeOutSine(n) {
      return r(n * a / 2);
    },
    easeInOutSine: function easeInOutSine(n) {
      return -(i(a * n) - 1) / 2;
    },
    easeInExpo: function easeInExpo(n) {
      return 0 === n ? 0 : t(2, 10 * n - 10);
    },
    easeOutExpo: function easeOutExpo(n) {
      return 1 === n ? 1 : 1 - t(2, -10 * n);
    },
    easeInOutExpo: function easeInOutExpo(n) {
      return 0 === n ? 0 : 1 === n ? 1 : n < .5 ? t(2, 20 * n - 10) / 2 : (2 - t(2, -20 * n + 10)) / 2;
    },
    easeInCirc: function easeInCirc(n) {
      return 1 - u(1 - t(n, 2));
    },
    easeOutCirc: function easeOutCirc(n) {
      return u(1 - t(n - 1, 2));
    },
    easeInOutCirc: function easeInOutCirc(n) {
      return n < .5 ? (1 - u(1 - t(2 * n, 2))) / 2 : (u(1 - t(-2 * n + 2, 2)) + 1) / 2;
    },
    easeInElastic: function easeInElastic(n) {
      return 0 === n ? 0 : 1 === n ? 1 : -t(2, 10 * n - 10) * r((10 * n - 10.75) * s);
    },
    easeOutElastic: function easeOutElastic(n) {
      return 0 === n ? 0 : 1 === n ? 1 : t(2, -10 * n) * r((10 * n - .75) * s) + 1;
    },
    easeInOutElastic: function easeInOutElastic(n) {
      return 0 === n ? 0 : 1 === n ? 1 : n < .5 ? -(t(2, 20 * n - 10) * r((20 * n - 11.125) * f)) / 2 : t(2, -20 * n + 10) * r((20 * n - 11.125) * f) / 2 + 1;
    },
    easeInBack: function easeInBack(n) {
      return (c + 1) * n * n * n - c * n * n;
    },
    easeOutBack: function easeOutBack(n) {
      return 1 + (c + 1) * t(n - 1, 3) + c * t(n - 1, 2);
    },
    easeInOutBack: function easeInOutBack(n) {
      return n < .5 ? t(2 * n, 2) * (7.189819 * n - o) / 2 : (t(2 * n - 2, 2) * ((o + 1) * (2 * n - 2) + o) + 2) / 2;
    },
    easeInBounce: function easeInBounce(n) {
      return 1 - e(1 - n);
    },
    easeOutBounce: e,
    easeInOutBounce: function easeInOutBounce(n) {
      return n < .5 ? (1 - e(1 - 2 * n)) / 2 : (1 + e(2 * n - 1)) / 2;
    }
  });
});

/***/ }),

/***/ "./assets/js/lib/lightbox/js/lightbox.min.js":
/*!***************************************************!*\
  !*** ./assets/js/lib/lightbox/js/lightbox.min.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * Lightbox v2.10.0
 * by Lokesh Dhakar
 *
 * More info:
 * http://lokeshdhakar.com/projects/lightbox2/
 *
 * Copyright 2007, 2018 Lokesh Dhakar
 * Released under the MIT license
 * https://github.com/lokesh/lightbox2/blob/master/LICENSE
 *
 * @preserve
 */
!function (a, b) {
   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (b),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
}(this, function (a) {
  function b(b) {
    this.album = [], this.currentImageIndex = void 0, this.init(), this.options = a.extend({}, this.constructor.defaults), this.option(b);
  }

  return b.defaults = {
    albumLabel: "Image %1 of %2",
    alwaysShowNavOnTouchDevices: !1,
    fadeDuration: 600,
    fitImagesInViewport: !0,
    imageFadeDuration: 600,
    positionFromTop: 50,
    resizeDuration: 700,
    showImageNumberLabel: !0,
    wrapAround: !1,
    disableScrolling: !1,
    sanitizeTitle: !1
  }, b.prototype.option = function (b) {
    a.extend(this.options, b);
  }, b.prototype.imageCountLabel = function (a, b) {
    return this.options.albumLabel.replace(/%1/g, a).replace(/%2/g, b);
  }, b.prototype.init = function () {
    var b = this;
    a(document).ready(function () {
      b.enable(), b.build();
    });
  }, b.prototype.enable = function () {
    var b = this;
    a("body").on("click", "a[rel^=lightbox], area[rel^=lightbox], a[data-lightbox], area[data-lightbox]", function (c) {
      return b.start(a(c.currentTarget)), !1;
    });
  }, b.prototype.build = function () {
    if (!(a("#lightbox").length > 0)) {
      var b = this;
      a('<div id="lightboxOverlay" class="lightboxOverlay"></div><div id="lightbox" class="lightbox"><div class="lb-outerContainer"><div class="lb-container"><img class="lb-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" /><div class="lb-nav"><a class="lb-prev" href="" ></a><a class="lb-next" href="" ></a></div><div class="lb-loader"><a class="lb-cancel"></a></div></div></div><div class="lb-dataContainer"><div class="lb-data"><div class="lb-details"><span class="lb-caption"></span><span class="lb-number"></span></div><div class="lb-closeContainer"><a class="lb-close"></a></div></div></div></div>').appendTo(a("body")), this.$lightbox = a("#lightbox"), this.$overlay = a("#lightboxOverlay"), this.$outerContainer = this.$lightbox.find(".lb-outerContainer"), this.$container = this.$lightbox.find(".lb-container"), this.$image = this.$lightbox.find(".lb-image"), this.$nav = this.$lightbox.find(".lb-nav"), this.containerPadding = {
        top: parseInt(this.$container.css("padding-top"), 10),
        right: parseInt(this.$container.css("padding-right"), 10),
        bottom: parseInt(this.$container.css("padding-bottom"), 10),
        left: parseInt(this.$container.css("padding-left"), 10)
      }, this.imageBorderWidth = {
        top: parseInt(this.$image.css("border-top-width"), 10),
        right: parseInt(this.$image.css("border-right-width"), 10),
        bottom: parseInt(this.$image.css("border-bottom-width"), 10),
        left: parseInt(this.$image.css("border-left-width"), 10)
      }, this.$overlay.hide().on("click", function () {
        return b.end(), !1;
      }), this.$lightbox.hide().on("click", function (c) {
        return "lightbox" === a(c.target).attr("id") && b.end(), !1;
      }), this.$outerContainer.on("click", function (c) {
        return "lightbox" === a(c.target).attr("id") && b.end(), !1;
      }), this.$lightbox.find(".lb-prev").on("click", function () {
        return 0 === b.currentImageIndex ? b.changeImage(b.album.length - 1) : b.changeImage(b.currentImageIndex - 1), !1;
      }), this.$lightbox.find(".lb-next").on("click", function () {
        return b.currentImageIndex === b.album.length - 1 ? b.changeImage(0) : b.changeImage(b.currentImageIndex + 1), !1;
      }), this.$nav.on("mousedown", function (a) {
        3 === a.which && (b.$nav.css("pointer-events", "none"), b.$lightbox.one("contextmenu", function () {
          setTimeout(function () {
            this.$nav.css("pointer-events", "auto");
          }.bind(b), 0);
        }));
      }), this.$lightbox.find(".lb-loader, .lb-close").on("click", function () {
        return b.end(), !1;
      });
    }
  }, b.prototype.start = function (b) {
    function c(a) {
      d.album.push({
        alt: a.attr("data-alt"),
        link: a.attr("href"),
        title: a.attr("data-title") || a.attr("title")
      });
    }

    var d = this,
        e = a(window);
    e.on("resize", a.proxy(this.sizeOverlay, this)), a("select, object, embed").css({
      visibility: "hidden"
    }), this.sizeOverlay(), this.album = [];
    var f,
        g = 0,
        h = b.attr("data-lightbox");

    if (h) {
      f = a(b.prop("tagName") + '[data-lightbox="' + h + '"]');

      for (var i = 0; i < f.length; i = ++i) {
        c(a(f[i])), f[i] === b[0] && (g = i);
      }
    } else if ("lightbox" === b.attr("rel")) c(b);else {
      f = a(b.prop("tagName") + '[rel="' + b.attr("rel") + '"]');

      for (var j = 0; j < f.length; j = ++j) {
        c(a(f[j])), f[j] === b[0] && (g = j);
      }
    }

    var k = e.scrollTop() + this.options.positionFromTop,
        l = e.scrollLeft();
    this.$lightbox.css({
      top: k + "px",
      left: l + "px"
    }).fadeIn(this.options.fadeDuration), this.options.disableScrolling && a("html").addClass("lb-disable-scrolling"), this.changeImage(g);
  }, b.prototype.changeImage = function (b) {
    var c = this;
    this.disableKeyboardNav();
    var d = this.$lightbox.find(".lb-image");
    this.$overlay.fadeIn(this.options.fadeDuration), a(".lb-loader").fadeIn("slow"), this.$lightbox.find(".lb-image, .lb-nav, .lb-prev, .lb-next, .lb-dataContainer, .lb-numbers, .lb-caption").hide(), this.$outerContainer.addClass("animating");
    var e = new Image();
    e.onload = function () {
      var f, g, h, i, j, k;
      d.attr({
        alt: c.album[b].alt,
        src: c.album[b].link
      }), a(e), d.width(e.width), d.height(e.height), c.options.fitImagesInViewport && (k = a(window).width(), j = a(window).height(), i = k - c.containerPadding.left - c.containerPadding.right - c.imageBorderWidth.left - c.imageBorderWidth.right - 20, h = j - c.containerPadding.top - c.containerPadding.bottom - c.imageBorderWidth.top - c.imageBorderWidth.bottom - 120, c.options.maxWidth && c.options.maxWidth < i && (i = c.options.maxWidth), c.options.maxHeight && c.options.maxHeight < i && (h = c.options.maxHeight), (e.width > i || e.height > h) && (e.width / i > e.height / h ? (g = i, f = parseInt(e.height / (e.width / g), 10), d.width(g), d.height(f)) : (f = h, g = parseInt(e.width / (e.height / f), 10), d.width(g), d.height(f)))), c.sizeContainer(d.width(), d.height());
    }, e.src = this.album[b].link, this.currentImageIndex = b;
  }, b.prototype.sizeOverlay = function () {
    this.$overlay.width(a(document).width()).height(a(document).height());
  }, b.prototype.sizeContainer = function (a, b) {
    function c() {
      d.$lightbox.find(".lb-dataContainer").width(g), d.$lightbox.find(".lb-prevLink").height(h), d.$lightbox.find(".lb-nextLink").height(h), d.showImage();
    }

    var d = this,
        e = this.$outerContainer.outerWidth(),
        f = this.$outerContainer.outerHeight(),
        g = a + this.containerPadding.left + this.containerPadding.right + this.imageBorderWidth.left + this.imageBorderWidth.right,
        h = b + this.containerPadding.top + this.containerPadding.bottom + this.imageBorderWidth.top + this.imageBorderWidth.bottom;
    e !== g || f !== h ? this.$outerContainer.animate({
      width: g,
      height: h
    }, this.options.resizeDuration, "swing", function () {
      c();
    }) : c();
  }, b.prototype.showImage = function () {
    this.$lightbox.find(".lb-loader").stop(!0).hide(), this.$lightbox.find(".lb-image").fadeIn(this.options.imageFadeDuration), this.updateNav(), this.updateDetails(), this.preloadNeighboringImages(), this.enableKeyboardNav();
  }, b.prototype.updateNav = function () {
    var a = !1;

    try {
      document.createEvent("TouchEvent"), a = !!this.options.alwaysShowNavOnTouchDevices;
    } catch (a) {}

    this.$lightbox.find(".lb-nav").show(), this.album.length > 1 && (this.options.wrapAround ? (a && this.$lightbox.find(".lb-prev, .lb-next").css("opacity", "1"), this.$lightbox.find(".lb-prev, .lb-next").show()) : (this.currentImageIndex > 0 && (this.$lightbox.find(".lb-prev").show(), a && this.$lightbox.find(".lb-prev").css("opacity", "1")), this.currentImageIndex < this.album.length - 1 && (this.$lightbox.find(".lb-next").show(), a && this.$lightbox.find(".lb-next").css("opacity", "1"))));
  }, b.prototype.updateDetails = function () {
    var b = this;

    if (void 0 !== this.album[this.currentImageIndex].title && "" !== this.album[this.currentImageIndex].title) {
      var c = this.$lightbox.find(".lb-caption");
      this.options.sanitizeTitle ? c.text(this.album[this.currentImageIndex].title) : c.html(this.album[this.currentImageIndex].title), c.fadeIn("fast").find("a").on("click", function (b) {
        void 0 !== a(this).attr("target") ? window.open(a(this).attr("href"), a(this).attr("target")) : location.href = a(this).attr("href");
      });
    }

    if (this.album.length > 1 && this.options.showImageNumberLabel) {
      var d = this.imageCountLabel(this.currentImageIndex + 1, this.album.length);
      this.$lightbox.find(".lb-number").text(d).fadeIn("fast");
    } else this.$lightbox.find(".lb-number").hide();

    this.$outerContainer.removeClass("animating"), this.$lightbox.find(".lb-dataContainer").fadeIn(this.options.resizeDuration, function () {
      return b.sizeOverlay();
    });
  }, b.prototype.preloadNeighboringImages = function () {
    if (this.album.length > this.currentImageIndex + 1) {
      new Image().src = this.album[this.currentImageIndex + 1].link;
    }

    if (this.currentImageIndex > 0) {
      new Image().src = this.album[this.currentImageIndex - 1].link;
    }
  }, b.prototype.enableKeyboardNav = function () {
    a(document).on("keyup.keyboard", a.proxy(this.keyboardAction, this));
  }, b.prototype.disableKeyboardNav = function () {
    a(document).off(".keyboard");
  }, b.prototype.keyboardAction = function (a) {
    var b = a.keyCode,
        c = String.fromCharCode(b).toLowerCase();
    27 === b || c.match(/x|o|c/) ? this.end() : "p" === c || 37 === b ? 0 !== this.currentImageIndex ? this.changeImage(this.currentImageIndex - 1) : this.options.wrapAround && this.album.length > 1 && this.changeImage(this.album.length - 1) : "n" !== c && 39 !== b || (this.currentImageIndex !== this.album.length - 1 ? this.changeImage(this.currentImageIndex + 1) : this.options.wrapAround && this.album.length > 1 && this.changeImage(0));
  }, b.prototype.end = function () {
    this.disableKeyboardNav(), a(window).off("resize", this.sizeOverlay), this.$lightbox.fadeOut(this.options.fadeDuration), this.$overlay.fadeOut(this.options.fadeDuration), a("select, object, embed").css({
      visibility: "visible"
    }), this.options.disableScrolling && a("html").removeClass("lb-disable-scrolling");
  }, new b();
});

/***/ }),

/***/ "./assets/js/lib/superfish/hoverIntent.js":
/*!************************************************!*\
  !*** ./assets/js/lib/superfish/hoverIntent.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * hoverIntent v1.8.1 // 2014.08.11 // jQuery v1.9.1+
 * http://briancherne.github.io/jquery-hoverIntent/
 *
 * You may use hoverIntent under the terms of the MIT license. Basically that
 * means you are free to use hoverIntent as long as this header is left intact.
 * Copyright 2007, 2014 Brian Cherne
 */

/* hoverIntent is similar to jQuery's built-in "hover" method except that
 * instead of firing the handlerIn function immediately, hoverIntent checks
 * to see if the user's mouse has slowed down (beneath the sensitivity
 * threshold) before firing the event. The handlerOut function is only
 * called after a matching handlerIn.
 *
 * // basic usage ... just like .hover()
 * .hoverIntent( handlerIn, handlerOut )
 * .hoverIntent( handlerInOut )
 *
 * // basic usage ... with event delegation!
 * .hoverIntent( handlerIn, handlerOut, selector )
 * .hoverIntent( handlerInOut, selector )
 *
 * // using a basic configuration object
 * .hoverIntent( config )
 *
 * @param  handlerIn   function OR configuration object
 * @param  handlerOut  function OR selector for delegation OR undefined
 * @param  selector    selector OR undefined
 * @author Brian Cherne <brian(at)cherne(dot)net>
 */
;

(function (factory) {
  'use strict';

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function ($) {
  'use strict'; // default configuration values

  var _cfg = {
    interval: 100,
    sensitivity: 6,
    timeout: 0
  }; // counter used to generate an ID for each instance

  var INSTANCE_COUNT = 0; // current X and Y position of mouse, updated during mousemove tracking (shared across instances)

  var cX, cY; // saves the current pointer position coordinates based on the given mousemove event

  var track = function track(ev) {
    cX = ev.pageX;
    cY = ev.pageY;
  }; // compares current and previous mouse positions


  var compare = function compare(ev, $el, s, cfg) {
    // compare mouse positions to see if pointer has slowed enough to trigger `over` function
    if (Math.sqrt((s.pX - cX) * (s.pX - cX) + (s.pY - cY) * (s.pY - cY)) < cfg.sensitivity) {
      $el.off(s.event, track);
      delete s.timeoutId; // set hoverIntent state as active for this element (permits `out` handler to trigger)

      s.isActive = true; // overwrite old mouseenter event coordinates with most recent pointer position

      ev.pageX = cX;
      ev.pageY = cY; // clear coordinate data from state object

      delete s.pX;
      delete s.pY;
      return cfg.over.apply($el[0], [ev]);
    } else {
      // set previous coordinates for next comparison
      s.pX = cX;
      s.pY = cY; // use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)

      s.timeoutId = setTimeout(function () {
        compare(ev, $el, s, cfg);
      }, cfg.interval);
    }
  }; // triggers given `out` function at configured `timeout` after a mouseleave and clears state


  var delay = function delay(ev, $el, s, out) {
    delete $el.data('hoverIntent')[s.id];
    return out.apply($el[0], [ev]);
  };

  $.fn.hoverIntent = function (handlerIn, handlerOut, selector) {
    // instance ID, used as a key to store and retrieve state information on an element
    var instanceId = INSTANCE_COUNT++; // extend the default configuration and parse parameters

    var cfg = $.extend({}, _cfg);

    if ($.isPlainObject(handlerIn)) {
      cfg = $.extend(cfg, handlerIn);

      if (!$.isFunction(cfg.out)) {
        cfg.out = cfg.over;
      }
    } else if ($.isFunction(handlerOut)) {
      cfg = $.extend(cfg, {
        over: handlerIn,
        out: handlerOut,
        selector: selector
      });
    } else {
      cfg = $.extend(cfg, {
        over: handlerIn,
        out: handlerIn,
        selector: handlerOut
      });
    } // A private function for handling mouse 'hovering'


    var handleHover = function handleHover(e) {
      // cloned event to pass to handlers (copy required for event object to be passed in IE)
      var ev = $.extend({}, e); // the current target of the mouse event, wrapped in a jQuery object

      var $el = $(this); // read hoverIntent data from element (or initialize if not present)

      var hoverIntentData = $el.data('hoverIntent');

      if (!hoverIntentData) {
        $el.data('hoverIntent', hoverIntentData = {});
      } // read per-instance state from element (or initialize if not present)


      var state = hoverIntentData[instanceId];

      if (!state) {
        hoverIntentData[instanceId] = state = {
          id: instanceId
        };
      } // state properties:
      // id = instance ID, used to clean up data
      // timeoutId = timeout ID, reused for tracking mouse position and delaying "out" handler
      // isActive = plugin state, true after `over` is called just until `out` is called
      // pX, pY = previously-measured pointer coordinates, updated at each polling interval
      // event = string representing the namespaced event used for mouse tracking
      // clear any existing timeout


      if (state.timeoutId) {
        state.timeoutId = clearTimeout(state.timeoutId);
      } // namespaced event used to register and unregister mousemove tracking


      var mousemove = state.event = 'mousemove.hoverIntent.hoverIntent' + instanceId; // handle the event, based on its type

      if (e.type === 'mouseenter') {
        // do nothing if already active
        if (state.isActive) {
          return;
        } // set "previous" X and Y position based on initial entry point


        state.pX = ev.pageX;
        state.pY = ev.pageY; // update "current" X and Y position based on mousemove

        $el.off(mousemove, track).on(mousemove, track); // start polling interval (self-calling timeout) to compare mouse coordinates over time

        state.timeoutId = setTimeout(function () {
          compare(ev, $el, state, cfg);
        }, cfg.interval);
      } else {
        // "mouseleave"
        // do nothing if not already active
        if (!state.isActive) {
          return;
        } // unbind expensive mousemove event


        $el.off(mousemove, track); // if hoverIntent state is true, then call the mouseOut function after the specified delay

        state.timeoutId = setTimeout(function () {
          delay(ev, $el, state, cfg.out);
        }, cfg.timeout);
      }
    }; // listen for mouseenter and mouseleave


    return this.on({
      'mouseenter.hoverIntent': handleHover,
      'mouseleave.hoverIntent': handleHover
    }, cfg.selector);
  };
});

/***/ }),

/***/ "./assets/js/lib/superfish/superfish.min.js":
/*!**************************************************!*\
  !*** ./assets/js/lib/superfish/superfish.min.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * jQuery Superfish Menu Plugin - v1.7.9
 * Copyright (c) 2016 Joel Birch
 *
 * Dual licensed under the MIT and GPL licenses:
 *	http://www.opensource.org/licenses/mit-license.php
 *	http://www.gnu.org/licenses/gpl.html
 */
;
!function (a, b) {
  "use strict";

  var c = function () {
    var c = {
      bcClass: "sf-breadcrumb",
      menuClass: "sf-js-enabled",
      anchorClass: "sf-with-ul",
      menuArrowClass: "sf-arrows"
    },
        d = function () {
      var b = /^(?![\w\W]*Windows Phone)[\w\W]*(iPhone|iPad|iPod)/i.test(navigator.userAgent);
      return b && a("html").css("cursor", "pointer").on("click", a.noop), b;
    }(),
        e = function () {
      var a = document.documentElement.style;
      return "behavior" in a && "fill" in a && /iemobile/i.test(navigator.userAgent);
    }(),
        f = function () {
      return !!b.PointerEvent;
    }(),
        g = function g(a, b, d) {
      var e,
          f = c.menuClass;
      b.cssArrows && (f += " " + c.menuArrowClass), e = d ? "addClass" : "removeClass", a[e](f);
    },
        h = function h(b, d) {
      return b.find("li." + d.pathClass).slice(0, d.pathLevels).addClass(d.hoverClass + " " + c.bcClass).filter(function () {
        return a(this).children(d.popUpSelector).hide().show().length;
      }).removeClass(d.pathClass);
    },
        i = function i(a, b) {
      var d = b ? "addClass" : "removeClass";
      a.children("a")[d](c.anchorClass);
    },
        j = function j(a) {
      var b = a.css("ms-touch-action"),
          c = a.css("touch-action");
      c = c || b, c = "pan-y" === c ? "auto" : "pan-y", a.css({
        "ms-touch-action": c,
        "touch-action": c
      });
    },
        k = function k(a) {
      return a.closest("." + c.menuClass);
    },
        l = function l(a) {
      return k(a).data("sfOptions");
    },
        m = function m() {
      var b = a(this),
          c = l(b);
      clearTimeout(c.sfTimer), b.siblings().superfish("hide").end().superfish("show");
    },
        n = function n(b) {
      b.retainPath = a.inArray(this[0], b.$path) > -1, this.superfish("hide"), this.parents("." + b.hoverClass).length || (b.onIdle.call(k(this)), b.$path.length && a.proxy(m, b.$path)());
    },
        o = function o() {
      var b = a(this),
          c = l(b);
      d ? a.proxy(n, b, c)() : (clearTimeout(c.sfTimer), c.sfTimer = setTimeout(a.proxy(n, b, c), c.delay));
    },
        p = function p(b) {
      var c = a(this),
          d = l(c),
          e = c.siblings(b.data.popUpSelector);
      return d.onHandleTouch.call(e) === !1 ? this : void (e.length > 0 && e.is(":hidden") && (c.one("click.superfish", !1), "MSPointerDown" === b.type || "pointerdown" === b.type ? c.trigger("focus") : a.proxy(m, c.parent("li"))()));
    },
        q = function q(b, c) {
      var g = "li:has(" + c.popUpSelector + ")";
      a.fn.hoverIntent && !c.disableHI ? b.hoverIntent(m, o, g) : b.on("mouseenter.superfish", g, m).on("mouseleave.superfish", g, o);
      var h = "MSPointerDown.superfish";
      f && (h = "pointerdown.superfish"), d || (h += " touchend.superfish"), e && (h += " mousedown.superfish"), b.on("focusin.superfish", "li", m).on("focusout.superfish", "li", o).on(h, "a", c, p);
    };

    return {
      hide: function hide(b) {
        if (this.length) {
          var c = this,
              d = l(c);
          if (!d) return this;
          var e = d.retainPath === !0 ? d.$path : "",
              f = c.find("li." + d.hoverClass).add(this).not(e).removeClass(d.hoverClass).children(d.popUpSelector),
              g = d.speedOut;
          if (b && (f.show(), g = 0), d.retainPath = !1, d.onBeforeHide.call(f) === !1) return this;
          f.stop(!0, !0).animate(d.animationOut, g, function () {
            var b = a(this);
            d.onHide.call(b);
          });
        }

        return this;
      },
      show: function show() {
        var a = l(this);
        if (!a) return this;
        var b = this.addClass(a.hoverClass),
            c = b.children(a.popUpSelector);
        return a.onBeforeShow.call(c) === !1 ? this : (c.stop(!0, !0).animate(a.animation, a.speed, function () {
          a.onShow.call(c);
        }), this);
      },
      destroy: function destroy() {
        return this.each(function () {
          var b,
              d = a(this),
              e = d.data("sfOptions");
          return e ? (b = d.find(e.popUpSelector).parent("li"), clearTimeout(e.sfTimer), g(d, e), i(b), j(d), d.off(".superfish").off(".hoverIntent"), b.children(e.popUpSelector).attr("style", function (a, b) {
            return b.replace(/display[^;]+;?/g, "");
          }), e.$path.removeClass(e.hoverClass + " " + c.bcClass).addClass(e.pathClass), d.find("." + e.hoverClass).removeClass(e.hoverClass), e.onDestroy.call(d), void d.removeData("sfOptions")) : !1;
        });
      },
      init: function init(b) {
        return this.each(function () {
          var d = a(this);
          if (d.data("sfOptions")) return !1;
          var e = a.extend({}, a.fn.superfish.defaults, b),
              f = d.find(e.popUpSelector).parent("li");
          e.$path = h(d, e), d.data("sfOptions", e), g(d, e, !0), i(f, !0), j(d), q(d, e), f.not("." + c.bcClass).superfish("hide", !0), e.onInit.call(this);
        });
      }
    };
  }();

  a.fn.superfish = function (b, d) {
    return c[b] ? c[b].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != _typeof(b) && b ? a.error("Method " + b + " does not exist on jQuery.fn.superfish") : c.init.apply(this, arguments);
  }, a.fn.superfish.defaults = {
    popUpSelector: "ul,.sf-mega",
    hoverClass: "sfHover",
    pathClass: "overrideThisToUse",
    pathLevels: 1,
    delay: 800,
    animation: {
      opacity: "show"
    },
    animationOut: {
      opacity: "hide"
    },
    speed: "normal",
    speedOut: "fast",
    cssArrows: !0,
    disableHI: !1,
    onInit: a.noop,
    onBeforeShow: a.noop,
    onShow: a.noop,
    onBeforeHide: a.noop,
    onHide: a.noop,
    onIdle: a.noop,
    onDestroy: a.noop,
    onHandleTouch: a.noop
  };
}(jQuery, window);

/***/ }),

/***/ "./assets/js/lib/touchSwipe/jquery.touchSwipe.min.js":
/*!***********************************************************!*\
  !*** ./assets/js/lib/touchSwipe/jquery.touchSwipe.min.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * @fileOverview TouchSwipe - jQuery Plugin
 * @version 1.6.18
 *
 * @author Matt Bryson http://www.github.com/mattbryson
 * @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
 * @see http://labs.rampinteractive.co.uk/touchSwipe/
 * @see http://plugins.jquery.com/project/touchSwipe
 * @license
 * Copyright (c) 2010-2015 Matt Bryson
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 */
!function (factory) {
   true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js").jQuery ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory( true && module.exports ? __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js") : jQuery);
}(function ($) {
  "use strict";

  function init(options) {
    return !options || void 0 !== options.allowPageScroll || void 0 === options.swipe && void 0 === options.swipeStatus || (options.allowPageScroll = NONE), void 0 !== options.click && void 0 === options.tap && (options.tap = options.click), options || (options = {}), options = $.extend({}, $.fn.swipe.defaults, options), this.each(function () {
      var $this = $(this),
          plugin = $this.data(PLUGIN_NS);
      plugin || (plugin = new TouchSwipe(this, options), $this.data(PLUGIN_NS, plugin));
    });
  }

  function TouchSwipe(element, options) {
    function touchStart(jqEvent) {
      if (!(getTouchInProgress() || $(jqEvent.target).closest(options.excludedElements, $element).length > 0)) {
        var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;

        if (!event.pointerType || "mouse" != event.pointerType || 0 != options.fallbackToMouseEvents) {
          var ret,
              touches = event.touches,
              evt = touches ? touches[0] : event;
          return phase = PHASE_START, touches ? fingerCount = touches.length : options.preventDefaultEvents !== !1 && jqEvent.preventDefault(), distance = 0, direction = null, currentDirection = null, pinchDirection = null, duration = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, pinchDistance = 0, maximumsMap = createMaximumsData(), cancelMultiFingerRelease(), createFingerData(0, evt), !touches || fingerCount === options.fingers || options.fingers === ALL_FINGERS || hasPinches() ? (startTime = getTimeStamp(), 2 == fingerCount && (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)), (options.swipeStatus || options.pinchStatus) && (ret = triggerHandler(event, phase))) : ret = !1, ret === !1 ? (phase = PHASE_CANCEL, triggerHandler(event, phase), ret) : (options.hold && (holdTimeout = setTimeout($.proxy(function () {
            $element.trigger("hold", [event.target]), options.hold && (ret = options.hold.call($element, event, event.target));
          }, this), options.longTapThreshold)), setTouchInProgress(!0), null);
        }
      }
    }

    function touchMove(jqEvent) {
      var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;

      if (phase !== PHASE_END && phase !== PHASE_CANCEL && !inMultiFingerRelease()) {
        var ret,
            touches = event.touches,
            evt = touches ? touches[0] : event,
            currentFinger = updateFingerData(evt);

        if (endTime = getTimeStamp(), touches && (fingerCount = touches.length), options.hold && clearTimeout(holdTimeout), phase = PHASE_MOVE, 2 == fingerCount && (0 == startTouchesDistance ? (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)) : (updateFingerData(touches[1]), endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end), pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end)), pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance), pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance)), fingerCount === options.fingers || options.fingers === ALL_FINGERS || !touches || hasPinches()) {
          if (direction = calculateDirection(currentFinger.start, currentFinger.end), currentDirection = calculateDirection(currentFinger.last, currentFinger.end), validateDefaultEvent(jqEvent, currentDirection), distance = calculateDistance(currentFinger.start, currentFinger.end), duration = calculateDuration(), setMaxDistance(direction, distance), ret = triggerHandler(event, phase), !options.triggerOnTouchEnd || options.triggerOnTouchLeave) {
            var inBounds = !0;

            if (options.triggerOnTouchLeave) {
              var bounds = getbounds(this);
              inBounds = isInBounds(currentFinger.end, bounds);
            }

            !options.triggerOnTouchEnd && inBounds ? phase = getNextPhase(PHASE_MOVE) : options.triggerOnTouchLeave && !inBounds && (phase = getNextPhase(PHASE_END)), phase != PHASE_CANCEL && phase != PHASE_END || triggerHandler(event, phase);
          }
        } else phase = PHASE_CANCEL, triggerHandler(event, phase);

        ret === !1 && (phase = PHASE_CANCEL, triggerHandler(event, phase));
      }
    }

    function touchEnd(jqEvent) {
      var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent,
          touches = event.touches;

      if (touches) {
        if (touches.length && !inMultiFingerRelease()) return startMultiFingerRelease(event), !0;
        if (touches.length && inMultiFingerRelease()) return !0;
      }

      return inMultiFingerRelease() && (fingerCount = fingerCountAtRelease), endTime = getTimeStamp(), duration = calculateDuration(), didSwipeBackToCancel() || !validateSwipeDistance() ? (phase = PHASE_CANCEL, triggerHandler(event, phase)) : options.triggerOnTouchEnd || options.triggerOnTouchEnd === !1 && phase === PHASE_MOVE ? (options.preventDefaultEvents !== !1 && jqEvent.cancelable !== !1 && jqEvent.preventDefault(), phase = PHASE_END, triggerHandler(event, phase)) : !options.triggerOnTouchEnd && hasTap() ? (phase = PHASE_END, triggerHandlerForGesture(event, phase, TAP)) : phase === PHASE_MOVE && (phase = PHASE_CANCEL, triggerHandler(event, phase)), setTouchInProgress(!1), null;
    }

    function touchCancel() {
      fingerCount = 0, endTime = 0, startTime = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, cancelMultiFingerRelease(), setTouchInProgress(!1);
    }

    function touchLeave(jqEvent) {
      var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
      options.triggerOnTouchLeave && (phase = getNextPhase(PHASE_END), triggerHandler(event, phase));
    }

    function removeListeners() {
      $element.unbind(START_EV, touchStart), $element.unbind(CANCEL_EV, touchCancel), $element.unbind(MOVE_EV, touchMove), $element.unbind(END_EV, touchEnd), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave), setTouchInProgress(!1);
    }

    function getNextPhase(currentPhase) {
      var nextPhase = currentPhase,
          validTime = validateSwipeTime(),
          validDistance = validateSwipeDistance(),
          didCancel = didSwipeBackToCancel();
      return !validTime || didCancel ? nextPhase = PHASE_CANCEL : !validDistance || currentPhase != PHASE_MOVE || options.triggerOnTouchEnd && !options.triggerOnTouchLeave ? !validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave && (nextPhase = PHASE_CANCEL) : nextPhase = PHASE_END, nextPhase;
    }

    function triggerHandler(event, phase) {
      var ret,
          touches = event.touches;
      return (didSwipe() || hasSwipes()) && (ret = triggerHandlerForGesture(event, phase, SWIPE)), (didPinch() || hasPinches()) && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, PINCH)), didDoubleTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP) : didLongTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, LONG_TAP) : didTap() && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, TAP)), phase === PHASE_CANCEL && touchCancel(event), phase === PHASE_END && (touches ? touches.length || touchCancel(event) : touchCancel(event)), ret;
    }

    function triggerHandlerForGesture(event, phase, gesture) {
      var ret;

      if (gesture == SWIPE) {
        if ($element.trigger("swipeStatus", [phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection]), options.swipeStatus && (ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection), ret === !1)) return !1;

        if (phase == PHASE_END && validateSwipe()) {
          if (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), $element.trigger("swipe", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipe && (ret = options.swipe.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection), ret === !1)) return !1;

          switch (direction) {
            case LEFT:
              $element.trigger("swipeLeft", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeLeft && (ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
              break;

            case RIGHT:
              $element.trigger("swipeRight", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeRight && (ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
              break;

            case UP:
              $element.trigger("swipeUp", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeUp && (ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
              break;

            case DOWN:
              $element.trigger("swipeDown", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeDown && (ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
          }
        }
      }

      if (gesture == PINCH) {
        if ($element.trigger("pinchStatus", [phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchStatus && (ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData), ret === !1)) return !1;
        if (phase == PHASE_END && validatePinch()) switch (pinchDirection) {
          case IN:
            $element.trigger("pinchIn", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchIn && (ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData));
            break;

          case OUT:
            $element.trigger("pinchOut", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchOut && (ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData));
        }
      }

      return gesture == TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), hasDoubleTap() && !inDoubleTap() ? (doubleTapStartTime = getTimeStamp(), singleTapTimeout = setTimeout($.proxy(function () {
        doubleTapStartTime = null, $element.trigger("tap", [event.target]), options.tap && (ret = options.tap.call($element, event, event.target));
      }, this), options.doubleTapThreshold)) : (doubleTapStartTime = null, $element.trigger("tap", [event.target]), options.tap && (ret = options.tap.call($element, event, event.target)))) : gesture == DOUBLE_TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), doubleTapStartTime = null, $element.trigger("doubletap", [event.target]), options.doubleTap && (ret = options.doubleTap.call($element, event, event.target))) : gesture == LONG_TAP && (phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), doubleTapStartTime = null, $element.trigger("longtap", [event.target]), options.longTap && (ret = options.longTap.call($element, event, event.target)))), ret;
    }

    function validateSwipeDistance() {
      var valid = !0;
      return null !== options.threshold && (valid = distance >= options.threshold), valid;
    }

    function didSwipeBackToCancel() {
      var cancelled = !1;
      return null !== options.cancelThreshold && null !== direction && (cancelled = getMaxDistance(direction) - distance >= options.cancelThreshold), cancelled;
    }

    function validatePinchDistance() {
      return null === options.pinchThreshold || pinchDistance >= options.pinchThreshold;
    }

    function validateSwipeTime() {
      var result;
      return result = !options.maxTimeThreshold || !(duration >= options.maxTimeThreshold);
    }

    function validateDefaultEvent(jqEvent, direction) {
      if (options.preventDefaultEvents !== !1) if (options.allowPageScroll === NONE) jqEvent.preventDefault();else {
        var auto = options.allowPageScroll === AUTO;

        switch (direction) {
          case LEFT:
            (options.swipeLeft && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
            break;

          case RIGHT:
            (options.swipeRight && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
            break;

          case UP:
            (options.swipeUp && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
            break;

          case DOWN:
            (options.swipeDown && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
            break;

          case NONE:
        }
      }
    }

    function validatePinch() {
      var hasCorrectFingerCount = validateFingers(),
          hasEndPoint = validateEndPoint(),
          hasCorrectDistance = validatePinchDistance();
      return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;
    }

    function hasPinches() {
      return !!(options.pinchStatus || options.pinchIn || options.pinchOut);
    }

    function didPinch() {
      return !(!validatePinch() || !hasPinches());
    }

    function validateSwipe() {
      var hasValidTime = validateSwipeTime(),
          hasValidDistance = validateSwipeDistance(),
          hasCorrectFingerCount = validateFingers(),
          hasEndPoint = validateEndPoint(),
          didCancel = didSwipeBackToCancel(),
          valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
      return valid;
    }

    function hasSwipes() {
      return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown);
    }

    function didSwipe() {
      return !(!validateSwipe() || !hasSwipes());
    }

    function validateFingers() {
      return fingerCount === options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH;
    }

    function validateEndPoint() {
      return 0 !== fingerData[0].end.x;
    }

    function hasTap() {
      return !!options.tap;
    }

    function hasDoubleTap() {
      return !!options.doubleTap;
    }

    function hasLongTap() {
      return !!options.longTap;
    }

    function validateDoubleTap() {
      if (null == doubleTapStartTime) return !1;
      var now = getTimeStamp();
      return hasDoubleTap() && now - doubleTapStartTime <= options.doubleTapThreshold;
    }

    function inDoubleTap() {
      return validateDoubleTap();
    }

    function validateTap() {
      return (1 === fingerCount || !SUPPORTS_TOUCH) && (isNaN(distance) || distance < options.threshold);
    }

    function validateLongTap() {
      return duration > options.longTapThreshold && distance < DOUBLE_TAP_THRESHOLD;
    }

    function didTap() {
      return !(!validateTap() || !hasTap());
    }

    function didDoubleTap() {
      return !(!validateDoubleTap() || !hasDoubleTap());
    }

    function didLongTap() {
      return !(!validateLongTap() || !hasLongTap());
    }

    function startMultiFingerRelease(event) {
      previousTouchEndTime = getTimeStamp(), fingerCountAtRelease = event.touches.length + 1;
    }

    function cancelMultiFingerRelease() {
      previousTouchEndTime = 0, fingerCountAtRelease = 0;
    }

    function inMultiFingerRelease() {
      var withinThreshold = !1;

      if (previousTouchEndTime) {
        var diff = getTimeStamp() - previousTouchEndTime;
        diff <= options.fingerReleaseThreshold && (withinThreshold = !0);
      }

      return withinThreshold;
    }

    function getTouchInProgress() {
      return !($element.data(PLUGIN_NS + "_intouch") !== !0);
    }

    function setTouchInProgress(val) {
      $element && (val === !0 ? ($element.bind(MOVE_EV, touchMove), $element.bind(END_EV, touchEnd), LEAVE_EV && $element.bind(LEAVE_EV, touchLeave)) : ($element.unbind(MOVE_EV, touchMove, !1), $element.unbind(END_EV, touchEnd, !1), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave, !1)), $element.data(PLUGIN_NS + "_intouch", val === !0));
    }

    function createFingerData(id, evt) {
      var f = {
        start: {
          x: 0,
          y: 0
        },
        last: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: 0
        }
      };
      return f.start.x = f.last.x = f.end.x = evt.pageX || evt.clientX, f.start.y = f.last.y = f.end.y = evt.pageY || evt.clientY, fingerData[id] = f, f;
    }

    function updateFingerData(evt) {
      var id = void 0 !== evt.identifier ? evt.identifier : 0,
          f = getFingerData(id);
      return null === f && (f = createFingerData(id, evt)), f.last.x = f.end.x, f.last.y = f.end.y, f.end.x = evt.pageX || evt.clientX, f.end.y = evt.pageY || evt.clientY, f;
    }

    function getFingerData(id) {
      return fingerData[id] || null;
    }

    function setMaxDistance(direction, distance) {
      direction != NONE && (distance = Math.max(distance, getMaxDistance(direction)), maximumsMap[direction].distance = distance);
    }

    function getMaxDistance(direction) {
      if (maximumsMap[direction]) return maximumsMap[direction].distance;
    }

    function createMaximumsData() {
      var maxData = {};
      return maxData[LEFT] = createMaximumVO(LEFT), maxData[RIGHT] = createMaximumVO(RIGHT), maxData[UP] = createMaximumVO(UP), maxData[DOWN] = createMaximumVO(DOWN), maxData;
    }

    function createMaximumVO(dir) {
      return {
        direction: dir,
        distance: 0
      };
    }

    function calculateDuration() {
      return endTime - startTime;
    }

    function calculateTouchesDistance(startPoint, endPoint) {
      var diffX = Math.abs(startPoint.x - endPoint.x),
          diffY = Math.abs(startPoint.y - endPoint.y);
      return Math.round(Math.sqrt(diffX * diffX + diffY * diffY));
    }

    function calculatePinchZoom(startDistance, endDistance) {
      var percent = endDistance / startDistance * 1;
      return percent.toFixed(2);
    }

    function calculatePinchDirection() {
      return pinchZoom < 1 ? OUT : IN;
    }

    function calculateDistance(startPoint, endPoint) {
      return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)));
    }

    function calculateAngle(startPoint, endPoint) {
      var x = startPoint.x - endPoint.x,
          y = endPoint.y - startPoint.y,
          r = Math.atan2(y, x),
          angle = Math.round(180 * r / Math.PI);
      return angle < 0 && (angle = 360 - Math.abs(angle)), angle;
    }

    function calculateDirection(startPoint, endPoint) {
      if (comparePoints(startPoint, endPoint)) return NONE;
      var angle = calculateAngle(startPoint, endPoint);
      return angle <= 45 && angle >= 0 ? LEFT : angle <= 360 && angle >= 315 ? LEFT : angle >= 135 && angle <= 225 ? RIGHT : angle > 45 && angle < 135 ? DOWN : UP;
    }

    function getTimeStamp() {
      var now = new Date();
      return now.getTime();
    }

    function getbounds(el) {
      el = $(el);
      var offset = el.offset(),
          bounds = {
        left: offset.left,
        right: offset.left + el.outerWidth(),
        top: offset.top,
        bottom: offset.top + el.outerHeight()
      };
      return bounds;
    }

    function isInBounds(point, bounds) {
      return point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom;
    }

    function comparePoints(pointA, pointB) {
      return pointA.x == pointB.x && pointA.y == pointB.y;
    }

    var options = $.extend({}, options),
        useTouchEvents = SUPPORTS_TOUCH || SUPPORTS_POINTER || !options.fallbackToMouseEvents,
        START_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerDown" : "pointerdown" : "touchstart" : "mousedown",
        MOVE_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerMove" : "pointermove" : "touchmove" : "mousemove",
        END_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerUp" : "pointerup" : "touchend" : "mouseup",
        LEAVE_EV = useTouchEvents ? SUPPORTS_POINTER ? "mouseleave" : null : "mouseleave",
        CANCEL_EV = SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerCancel" : "pointercancel" : "touchcancel",
        distance = 0,
        direction = null,
        currentDirection = null,
        duration = 0,
        startTouchesDistance = 0,
        endTouchesDistance = 0,
        pinchZoom = 1,
        pinchDistance = 0,
        pinchDirection = 0,
        maximumsMap = null,
        $element = $(element),
        phase = "start",
        fingerCount = 0,
        fingerData = {},
        startTime = 0,
        endTime = 0,
        previousTouchEndTime = 0,
        fingerCountAtRelease = 0,
        doubleTapStartTime = 0,
        singleTapTimeout = null,
        holdTimeout = null;

    try {
      $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel);
    } catch (e) {
      $.error("events not supported " + START_EV + "," + CANCEL_EV + " on jQuery.swipe");
    }

    this.enable = function () {
      return this.disable(), $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel), $element;
    }, this.disable = function () {
      return removeListeners(), $element;
    }, this.destroy = function () {
      removeListeners(), $element.data(PLUGIN_NS, null), $element = null;
    }, this.option = function (property, value) {
      if ("object" == _typeof(property)) options = $.extend(options, property);else if (void 0 !== options[property]) {
        if (void 0 === value) return options[property];
        options[property] = value;
      } else {
        if (!property) return options;
        $.error("Option " + property + " does not exist on jQuery.swipe.options");
      }
      return null;
    };
  }

  var VERSION = "1.6.18",
      LEFT = "left",
      RIGHT = "right",
      UP = "up",
      DOWN = "down",
      IN = "in",
      OUT = "out",
      NONE = "none",
      AUTO = "auto",
      SWIPE = "swipe",
      PINCH = "pinch",
      TAP = "tap",
      DOUBLE_TAP = "doubletap",
      LONG_TAP = "longtap",
      HORIZONTAL = "horizontal",
      VERTICAL = "vertical",
      ALL_FINGERS = "all",
      DOUBLE_TAP_THRESHOLD = 10,
      PHASE_START = "start",
      PHASE_MOVE = "move",
      PHASE_END = "end",
      PHASE_CANCEL = "cancel",
      SUPPORTS_TOUCH = "ontouchstart" in window,
      SUPPORTS_POINTER_IE10 = window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !SUPPORTS_TOUCH,
      SUPPORTS_POINTER = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !SUPPORTS_TOUCH,
      PLUGIN_NS = "TouchSwipe",
      defaults = {
    fingers: 1,
    threshold: 75,
    cancelThreshold: null,
    pinchThreshold: 20,
    maxTimeThreshold: null,
    fingerReleaseThreshold: 250,
    longTapThreshold: 500,
    doubleTapThreshold: 200,
    swipe: null,
    swipeLeft: null,
    swipeRight: null,
    swipeUp: null,
    swipeDown: null,
    swipeStatus: null,
    pinchIn: null,
    pinchOut: null,
    pinchStatus: null,
    click: null,
    tap: null,
    doubleTap: null,
    longTap: null,
    hold: null,
    triggerOnTouchEnd: !0,
    triggerOnTouchLeave: !1,
    allowPageScroll: "auto",
    fallbackToMouseEvents: !0,
    excludedElements: ".noSwipe",
    preventDefaultEvents: !0
  };
  $.fn.swipe = function (method) {
    var $this = $(this),
        plugin = $this.data(PLUGIN_NS);

    if (plugin && "string" == typeof method) {
      if (plugin[method]) return plugin[method].apply(plugin, Array.prototype.slice.call(arguments, 1));
      $.error("Method " + method + " does not exist on jQuery.swipe");
    } else if (plugin && "object" == _typeof(method)) plugin.option.apply(plugin, arguments);else if (!(plugin || "object" != _typeof(method) && method)) return init.apply(this, arguments);

    return $this;
  }, $.fn.swipe.version = VERSION, $.fn.swipe.defaults = defaults, $.fn.swipe.phases = {
    PHASE_START: PHASE_START,
    PHASE_MOVE: PHASE_MOVE,
    PHASE_END: PHASE_END,
    PHASE_CANCEL: PHASE_CANCEL
  }, $.fn.swipe.directions = {
    LEFT: LEFT,
    RIGHT: RIGHT,
    UP: UP,
    DOWN: DOWN,
    IN: IN,
    OUT: OUT
  }, $.fn.swipe.pageScroll = {
    NONE: NONE,
    HORIZONTAL: HORIZONTAL,
    VERTICAL: VERTICAL,
    AUTO: AUTO
  }, $.fn.swipe.fingers = {
    ONE: 1,
    TWO: 2,
    THREE: 3,
    FOUR: 4,
    FIVE: 5,
    ALL: ALL_FINGERS
  };
});

/***/ }),

/***/ "./assets/js/lib/waypoints/waypoints.min.js":
/*!**************************************************!*\
  !*** ./assets/js/lib/waypoints/waypoints.min.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
Waypoints - 4.0.1
Copyright © 2011-2016 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
!function () {
  "use strict";

  function t(o) {
    if (!o) throw new Error("No options passed to Waypoint constructor");
    if (!o.element) throw new Error("No element option passed to Waypoint constructor");
    if (!o.handler) throw new Error("No handler option passed to Waypoint constructor");
    this.key = "waypoint-" + e, this.options = t.Adapter.extend({}, t.defaults, o), this.element = this.options.element, this.adapter = new t.Adapter(this.element), this.callback = o.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = t.Group.findOrCreate({
      name: this.options.group,
      axis: this.axis
    }), this.context = t.Context.findOrCreateByElement(this.options.context), t.offsetAliases[this.options.offset] && (this.options.offset = t.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), i[this.key] = this, e += 1;
  }

  var e = 0,
      i = {};
  t.prototype.queueTrigger = function (t) {
    this.group.queueTrigger(this, t);
  }, t.prototype.trigger = function (t) {
    this.enabled && this.callback && this.callback.apply(this, t);
  }, t.prototype.destroy = function () {
    this.context.remove(this), this.group.remove(this), delete i[this.key];
  }, t.prototype.disable = function () {
    return this.enabled = !1, this;
  }, t.prototype.enable = function () {
    return this.context.refresh(), this.enabled = !0, this;
  }, t.prototype.next = function () {
    return this.group.next(this);
  }, t.prototype.previous = function () {
    return this.group.previous(this);
  }, t.invokeAll = function (t) {
    var e = [];

    for (var o in i) {
      e.push(i[o]);
    }

    for (var n = 0, r = e.length; r > n; n++) {
      e[n][t]();
    }
  }, t.destroyAll = function () {
    t.invokeAll("destroy");
  }, t.disableAll = function () {
    t.invokeAll("disable");
  }, t.enableAll = function () {
    t.Context.refreshAll();

    for (var e in i) {
      i[e].enabled = !0;
    }

    return this;
  }, t.refreshAll = function () {
    t.Context.refreshAll();
  }, t.viewportHeight = function () {
    return window.innerHeight || document.documentElement.clientHeight;
  }, t.viewportWidth = function () {
    return document.documentElement.clientWidth;
  }, t.adapters = [], t.defaults = {
    context: window,
    continuous: !0,
    enabled: !0,
    group: "default",
    horizontal: !1,
    offset: 0
  }, t.offsetAliases = {
    "bottom-in-view": function bottomInView() {
      return this.context.innerHeight() - this.adapter.outerHeight();
    },
    "right-in-view": function rightInView() {
      return this.context.innerWidth() - this.adapter.outerWidth();
    }
  }, window.Waypoint = t;
}(), function () {
  "use strict";

  function t(t) {
    window.setTimeout(t, 1e3 / 60);
  }

  function e(t) {
    this.element = t, this.Adapter = n.Adapter, this.adapter = new this.Adapter(t), this.key = "waypoint-context-" + i, this.didScroll = !1, this.didResize = !1, this.oldScroll = {
      x: this.adapter.scrollLeft(),
      y: this.adapter.scrollTop()
    }, this.waypoints = {
      vertical: {},
      horizontal: {}
    }, t.waypointContextKey = this.key, o[t.waypointContextKey] = this, i += 1, n.windowContext || (n.windowContext = !0, n.windowContext = new e(window)), this.createThrottledScrollHandler(), this.createThrottledResizeHandler();
  }

  var i = 0,
      o = {},
      n = window.Waypoint,
      r = window.onload;
  e.prototype.add = function (t) {
    var e = t.options.horizontal ? "horizontal" : "vertical";
    this.waypoints[e][t.key] = t, this.refresh();
  }, e.prototype.checkEmpty = function () {
    var t = this.Adapter.isEmptyObject(this.waypoints.horizontal),
        e = this.Adapter.isEmptyObject(this.waypoints.vertical),
        i = this.element == this.element.window;
    t && e && !i && (this.adapter.off(".waypoints"), delete o[this.key]);
  }, e.prototype.createThrottledResizeHandler = function () {
    function t() {
      e.handleResize(), e.didResize = !1;
    }

    var e = this;
    this.adapter.on("resize.waypoints", function () {
      e.didResize || (e.didResize = !0, n.requestAnimationFrame(t));
    });
  }, e.prototype.createThrottledScrollHandler = function () {
    function t() {
      e.handleScroll(), e.didScroll = !1;
    }

    var e = this;
    this.adapter.on("scroll.waypoints", function () {
      (!e.didScroll || n.isTouch) && (e.didScroll = !0, n.requestAnimationFrame(t));
    });
  }, e.prototype.handleResize = function () {
    n.Context.refreshAll();
  }, e.prototype.handleScroll = function () {
    var t = {},
        e = {
      horizontal: {
        newScroll: this.adapter.scrollLeft(),
        oldScroll: this.oldScroll.x,
        forward: "right",
        backward: "left"
      },
      vertical: {
        newScroll: this.adapter.scrollTop(),
        oldScroll: this.oldScroll.y,
        forward: "down",
        backward: "up"
      }
    };

    for (var i in e) {
      var o = e[i],
          n = o.newScroll > o.oldScroll,
          r = n ? o.forward : o.backward;

      for (var s in this.waypoints[i]) {
        var a = this.waypoints[i][s];

        if (null !== a.triggerPoint) {
          var l = o.oldScroll < a.triggerPoint,
              h = o.newScroll >= a.triggerPoint,
              p = l && h,
              u = !l && !h;
          (p || u) && (a.queueTrigger(r), t[a.group.id] = a.group);
        }
      }
    }

    for (var c in t) {
      t[c].flushTriggers();
    }

    this.oldScroll = {
      x: e.horizontal.newScroll,
      y: e.vertical.newScroll
    };
  }, e.prototype.innerHeight = function () {
    return this.element == this.element.window ? n.viewportHeight() : this.adapter.innerHeight();
  }, e.prototype.remove = function (t) {
    delete this.waypoints[t.axis][t.key], this.checkEmpty();
  }, e.prototype.innerWidth = function () {
    return this.element == this.element.window ? n.viewportWidth() : this.adapter.innerWidth();
  }, e.prototype.destroy = function () {
    var t = [];

    for (var e in this.waypoints) {
      for (var i in this.waypoints[e]) {
        t.push(this.waypoints[e][i]);
      }
    }

    for (var o = 0, n = t.length; n > o; o++) {
      t[o].destroy();
    }
  }, e.prototype.refresh = function () {
    var t,
        e = this.element == this.element.window,
        i = e ? void 0 : this.adapter.offset(),
        o = {};
    this.handleScroll(), t = {
      horizontal: {
        contextOffset: e ? 0 : i.left,
        contextScroll: e ? 0 : this.oldScroll.x,
        contextDimension: this.innerWidth(),
        oldScroll: this.oldScroll.x,
        forward: "right",
        backward: "left",
        offsetProp: "left"
      },
      vertical: {
        contextOffset: e ? 0 : i.top,
        contextScroll: e ? 0 : this.oldScroll.y,
        contextDimension: this.innerHeight(),
        oldScroll: this.oldScroll.y,
        forward: "down",
        backward: "up",
        offsetProp: "top"
      }
    };

    for (var r in t) {
      var s = t[r];

      for (var a in this.waypoints[r]) {
        var l,
            h,
            p,
            u,
            c,
            d = this.waypoints[r][a],
            f = d.options.offset,
            w = d.triggerPoint,
            y = 0,
            g = null == w;
        d.element !== d.element.window && (y = d.adapter.offset()[s.offsetProp]), "function" == typeof f ? f = f.apply(d) : "string" == typeof f && (f = parseFloat(f), d.options.offset.indexOf("%") > -1 && (f = Math.ceil(s.contextDimension * f / 100))), l = s.contextScroll - s.contextOffset, d.triggerPoint = Math.floor(y + l - f), h = w < s.oldScroll, p = d.triggerPoint >= s.oldScroll, u = h && p, c = !h && !p, !g && u ? (d.queueTrigger(s.backward), o[d.group.id] = d.group) : !g && c ? (d.queueTrigger(s.forward), o[d.group.id] = d.group) : g && s.oldScroll >= d.triggerPoint && (d.queueTrigger(s.forward), o[d.group.id] = d.group);
      }
    }

    return n.requestAnimationFrame(function () {
      for (var t in o) {
        o[t].flushTriggers();
      }
    }), this;
  }, e.findOrCreateByElement = function (t) {
    return e.findByElement(t) || new e(t);
  }, e.refreshAll = function () {
    for (var t in o) {
      o[t].refresh();
    }
  }, e.findByElement = function (t) {
    return o[t.waypointContextKey];
  }, window.onload = function () {
    r && r(), e.refreshAll();
  }, n.requestAnimationFrame = function (e) {
    var i = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || t;
    i.call(window, e);
  }, n.Context = e;
}(), function () {
  "use strict";

  function t(t, e) {
    return t.triggerPoint - e.triggerPoint;
  }

  function e(t, e) {
    return e.triggerPoint - t.triggerPoint;
  }

  function i(t) {
    this.name = t.name, this.axis = t.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], this.clearTriggerQueues(), o[this.axis][this.name] = this;
  }

  var o = {
    vertical: {},
    horizontal: {}
  },
      n = window.Waypoint;
  i.prototype.add = function (t) {
    this.waypoints.push(t);
  }, i.prototype.clearTriggerQueues = function () {
    this.triggerQueues = {
      up: [],
      down: [],
      left: [],
      right: []
    };
  }, i.prototype.flushTriggers = function () {
    for (var i in this.triggerQueues) {
      var o = this.triggerQueues[i],
          n = "up" === i || "left" === i;
      o.sort(n ? e : t);

      for (var r = 0, s = o.length; s > r; r += 1) {
        var a = o[r];
        (a.options.continuous || r === o.length - 1) && a.trigger([i]);
      }
    }

    this.clearTriggerQueues();
  }, i.prototype.next = function (e) {
    this.waypoints.sort(t);
    var i = n.Adapter.inArray(e, this.waypoints),
        o = i === this.waypoints.length - 1;
    return o ? null : this.waypoints[i + 1];
  }, i.prototype.previous = function (e) {
    this.waypoints.sort(t);
    var i = n.Adapter.inArray(e, this.waypoints);
    return i ? this.waypoints[i - 1] : null;
  }, i.prototype.queueTrigger = function (t, e) {
    this.triggerQueues[e].push(t);
  }, i.prototype.remove = function (t) {
    var e = n.Adapter.inArray(t, this.waypoints);
    e > -1 && this.waypoints.splice(e, 1);
  }, i.prototype.first = function () {
    return this.waypoints[0];
  }, i.prototype.last = function () {
    return this.waypoints[this.waypoints.length - 1];
  }, i.findOrCreate = function (t) {
    return o[t.axis][t.name] || new i(t);
  }, n.Group = i;
}(), function () {
  "use strict";

  function t(t) {
    this.$element = e(t);
  }

  var e = window.jQuery,
      i = window.Waypoint;
  e.each(["innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop"], function (e, i) {
    t.prototype[i] = function () {
      var t = Array.prototype.slice.call(arguments);
      return this.$element[i].apply(this.$element, t);
    };
  }), e.each(["extend", "inArray", "isEmptyObject"], function (i, o) {
    t[o] = e[o];
  }), i.adapters.push({
    name: "jquery",
    Adapter: t
  }), i.Adapter = t;
}(), function () {
  "use strict";

  function t(t) {
    return function () {
      var i = [],
          o = arguments[0];
      return t.isFunction(arguments[0]) && (o = t.extend({}, arguments[1]), o.handler = arguments[0]), this.each(function () {
        var n = t.extend({}, o, {
          element: this
        });
        "string" == typeof n.context && (n.context = t(this).closest(n.context)[0]), i.push(new e(n));
      }), i;
    };
  }

  var e = window.Waypoint;
  window.jQuery && (window.jQuery.fn.waypoint = t(window.jQuery)), window.Zepto && (window.Zepto.fn.waypoint = t(window.Zepto));
}();

/***/ }),

/***/ "./assets/js/lib/wow/wow.min.js":
/*!**************************************!*\
  !*** ./assets/js/lib/wow/wow.min.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! WOW wow.js - v1.3.0 - 2016-10-04
* https://wowjs.uk
* Copyright (c) 2016 Thomas Grainger; Licensed MIT */
!function (a, b) {
  if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (b),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else { var c; }
}(this, function (a, b) {
  "use strict";

  function c(a, b) {
    if (!(a instanceof b)) throw new TypeError("Cannot call a class as a function");
  }

  function d(a, b) {
    return b.indexOf(a) >= 0;
  }

  function e(a, b) {
    for (var c in b) {
      if (null == a[c]) {
        var d = b[c];
        a[c] = d;
      }
    }

    return a;
  }

  function f(a) {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(a);
  }

  function g(a) {
    var b = arguments.length <= 1 || void 0 === arguments[1] ? !1 : arguments[1],
        c = arguments.length <= 2 || void 0 === arguments[2] ? !1 : arguments[2],
        d = arguments.length <= 3 || void 0 === arguments[3] ? null : arguments[3],
        e = void 0;
    return null != document.createEvent ? (e = document.createEvent("CustomEvent"), e.initCustomEvent(a, b, c, d)) : null != document.createEventObject ? (e = document.createEventObject(), e.eventType = a) : e.eventName = a, e;
  }

  function h(a, b) {
    null != a.dispatchEvent ? a.dispatchEvent(b) : b in (null != a) ? a[b]() : "on" + b in (null != a) && a["on" + b]();
  }

  function i(a, b, c) {
    null != a.addEventListener ? a.addEventListener(b, c, !1) : null != a.attachEvent ? a.attachEvent("on" + b, c) : a[b] = c;
  }

  function j(a, b, c) {
    null != a.removeEventListener ? a.removeEventListener(b, c, !1) : null != a.detachEvent ? a.detachEvent("on" + b, c) : delete a[b];
  }

  function k() {
    return "innerHeight" in window ? window.innerHeight : document.documentElement.clientHeight;
  }

  Object.defineProperty(b, "__esModule", {
    value: !0
  });

  var l,
      m,
      n = function () {
    function a(a, b) {
      for (var c = 0; c < b.length; c++) {
        var d = b[c];
        d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(a, d.key, d);
      }
    }

    return function (b, c, d) {
      return c && a(b.prototype, c), d && a(b, d), b;
    };
  }(),
      o = window.WeakMap || window.MozWeakMap || function () {
    function a() {
      c(this, a), this.keys = [], this.values = [];
    }

    return n(a, [{
      key: "get",
      value: function value(a) {
        for (var b = 0; b < this.keys.length; b++) {
          var c = this.keys[b];
          if (c === a) return this.values[b];
        }
      }
    }, {
      key: "set",
      value: function value(a, b) {
        for (var c = 0; c < this.keys.length; c++) {
          var d = this.keys[c];
          if (d === a) return this.values[c] = b, this;
        }

        return this.keys.push(a), this.values.push(b), this;
      }
    }]), a;
  }(),
      p = window.MutationObserver || window.WebkitMutationObserver || window.MozMutationObserver || (m = l = function () {
    function a() {
      c(this, a), "undefined" != typeof console && null !== console && (console.warn("MutationObserver is not supported by your browser."), console.warn("WOW.js cannot detect dom mutations, please call .sync() after loading new content."));
    }

    return n(a, [{
      key: "observe",
      value: function value() {}
    }]), a;
  }(), l.notSupported = !0, m),
      q = window.getComputedStyle || function (a) {
    var b = /(\-([a-z]){1})/g;
    return {
      getPropertyValue: function getPropertyValue(c) {
        "float" === c && (c = "styleFloat"), b.test(c) && c.replace(b, function (a, b) {
          return b.toUpperCase();
        });
        var d = a.currentStyle;
        return (null != d ? d[c] : void 0) || null;
      }
    };
  },
      r = function () {
    function a() {
      var b = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];
      c(this, a), this.defaults = {
        boxClass: "wow",
        animateClass: "animated",
        offset: 0,
        mobile: !0,
        live: !0,
        callback: null,
        scrollContainer: null,
        resetAnimation: !0
      }, this.animate = function () {
        return "requestAnimationFrame" in window ? function (a) {
          return window.requestAnimationFrame(a);
        } : function (a) {
          return a();
        };
      }(), this.vendors = ["moz", "webkit"], this.start = this.start.bind(this), this.resetAnimation = this.resetAnimation.bind(this), this.scrollHandler = this.scrollHandler.bind(this), this.scrollCallback = this.scrollCallback.bind(this), this.scrolled = !0, this.config = e(b, this.defaults), null != b.scrollContainer && (this.config.scrollContainer = document.querySelector(b.scrollContainer)), this.animationNameCache = new o(), this.wowEvent = g(this.config.boxClass);
    }

    return n(a, [{
      key: "init",
      value: function value() {
        this.element = window.document.documentElement, d(document.readyState, ["interactive", "complete"]) ? this.start() : i(document, "DOMContentLoaded", this.start), this.finished = [];
      }
    }, {
      key: "start",
      value: function value() {
        var a = this;
        if (this.stopped = !1, this.boxes = [].slice.call(this.element.querySelectorAll("." + this.config.boxClass)), this.all = this.boxes.slice(0), this.boxes.length) if (this.disabled()) this.resetStyle();else for (var b = 0; b < this.boxes.length; b++) {
          var c = this.boxes[b];
          this.applyStyle(c, !0);
        }

        if (this.disabled() || (i(this.config.scrollContainer || window, "scroll", this.scrollHandler), i(window, "resize", this.scrollHandler), this.interval = setInterval(this.scrollCallback, 50)), this.config.live) {
          var d = new p(function (b) {
            for (var c = 0; c < b.length; c++) {
              for (var d = b[c], e = 0; e < d.addedNodes.length; e++) {
                var f = d.addedNodes[e];
                a.doSync(f);
              }
            }
          });
          d.observe(document.body, {
            childList: !0,
            subtree: !0
          });
        }
      }
    }, {
      key: "stop",
      value: function value() {
        this.stopped = !0, j(this.config.scrollContainer || window, "scroll", this.scrollHandler), j(window, "resize", this.scrollHandler), null != this.interval && clearInterval(this.interval);
      }
    }, {
      key: "sync",
      value: function value() {
        p.notSupported && this.doSync(this.element);
      }
    }, {
      key: "doSync",
      value: function value(a) {
        if ("undefined" != typeof a && null !== a || (a = this.element), 1 === a.nodeType) {
          a = a.parentNode || a;

          for (var b = a.querySelectorAll("." + this.config.boxClass), c = 0; c < b.length; c++) {
            var e = b[c];
            d(e, this.all) || (this.boxes.push(e), this.all.push(e), this.stopped || this.disabled() ? this.resetStyle() : this.applyStyle(e, !0), this.scrolled = !0);
          }
        }
      }
    }, {
      key: "show",
      value: function value(a) {
        return this.applyStyle(a), a.className = a.className + " " + this.config.animateClass, null != this.config.callback && this.config.callback(a), h(a, this.wowEvent), this.config.resetAnimation && (i(a, "animationend", this.resetAnimation), i(a, "oanimationend", this.resetAnimation), i(a, "webkitAnimationEnd", this.resetAnimation), i(a, "MSAnimationEnd", this.resetAnimation)), a;
      }
    }, {
      key: "applyStyle",
      value: function value(a, b) {
        var c = this,
            d = a.getAttribute("data-wow-duration"),
            e = a.getAttribute("data-wow-delay"),
            f = a.getAttribute("data-wow-iteration");
        return this.animate(function () {
          return c.customStyle(a, b, d, e, f);
        });
      }
    }, {
      key: "resetStyle",
      value: function value() {
        for (var a = 0; a < this.boxes.length; a++) {
          var b = this.boxes[a];
          b.style.visibility = "visible";
        }
      }
    }, {
      key: "resetAnimation",
      value: function value(a) {
        if (a.type.toLowerCase().indexOf("animationend") >= 0) {
          var b = a.target || a.srcElement;
          b.className = b.className.replace(this.config.animateClass, "").trim();
        }
      }
    }, {
      key: "customStyle",
      value: function value(a, b, c, d, e) {
        return b && this.cacheAnimationName(a), a.style.visibility = b ? "hidden" : "visible", c && this.vendorSet(a.style, {
          animationDuration: c
        }), d && this.vendorSet(a.style, {
          animationDelay: d
        }), e && this.vendorSet(a.style, {
          animationIterationCount: e
        }), this.vendorSet(a.style, {
          animationName: b ? "none" : this.cachedAnimationName(a)
        }), a;
      }
    }, {
      key: "vendorSet",
      value: function value(a, b) {
        for (var c in b) {
          if (b.hasOwnProperty(c)) {
            var d = b[c];
            a["" + c] = d;

            for (var e = 0; e < this.vendors.length; e++) {
              var f = this.vendors[e];
              a["" + f + c.charAt(0).toUpperCase() + c.substr(1)] = d;
            }
          }
        }
      }
    }, {
      key: "vendorCSS",
      value: function value(a, b) {
        for (var c = q(a), d = c.getPropertyCSSValue(b), e = 0; e < this.vendors.length; e++) {
          var f = this.vendors[e];
          d = d || c.getPropertyCSSValue("-" + f + "-" + b);
        }

        return d;
      }
    }, {
      key: "animationName",
      value: function value(a) {
        var b = void 0;

        try {
          b = this.vendorCSS(a, "animation-name").cssText;
        } catch (c) {
          b = q(a).getPropertyValue("animation-name");
        }

        return "none" === b ? "" : b;
      }
    }, {
      key: "cacheAnimationName",
      value: function value(a) {
        return this.animationNameCache.set(a, this.animationName(a));
      }
    }, {
      key: "cachedAnimationName",
      value: function value(a) {
        return this.animationNameCache.get(a);
      }
    }, {
      key: "scrollHandler",
      value: function value() {
        this.scrolled = !0;
      }
    }, {
      key: "scrollCallback",
      value: function value() {
        if (this.scrolled) {
          this.scrolled = !1;

          for (var a = [], b = 0; b < this.boxes.length; b++) {
            var c = this.boxes[b];

            if (c) {
              if (this.isVisible(c)) {
                this.show(c);
                continue;
              }

              a.push(c);
            }
          }

          this.boxes = a, this.boxes.length || this.config.live || this.stop();
        }
      }
    }, {
      key: "offsetTop",
      value: function value(a) {
        for (; void 0 === a.offsetTop;) {
          a = a.parentNode;
        }

        for (var b = a.offsetTop; a.offsetParent;) {
          a = a.offsetParent, b += a.offsetTop;
        }

        return b;
      }
    }, {
      key: "isVisible",
      value: function value(a) {
        var b = a.getAttribute("data-wow-offset") || this.config.offset,
            c = this.config.scrollContainer && this.config.scrollContainer.scrollTop || window.pageYOffset,
            d = c + Math.min(this.element.clientHeight, k()) - b,
            e = this.offsetTop(a),
            f = e + a.clientHeight;
        return d >= e && f >= c;
      }
    }, {
      key: "disabled",
      value: function value() {
        return !this.config.mobile && f(navigator.userAgent);
      }
    }]), a;
  }();

  b["default"] = r, a.exports = b["default"];
});

/***/ }),

/***/ "./assets/js/main.js":
/*!***************************!*\
  !*** ./assets/js/main.js ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_wow_wow_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/wow/wow.min */ "./assets/js/lib/wow/wow.min.js");
/* harmony import */ var _lib_wow_wow_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_wow_wow_min__WEBPACK_IMPORTED_MODULE_0__);


(function ($) {
  "use strict"; // Preloader

  $(window).on('load', function () {
    if ($('#preloader').length) {
      $('#preloader').delay(100).fadeOut('slow', function () {
        $(this).remove();
      });
    }
  }); // Back to top button

  $(window).scroll(function () {
    if ($(this).scrollTop() > 100) {
      $('.back-to-top').fadeIn('slow');
    } else {
      $('.back-to-top').fadeOut('slow');
    }
  });
  $('.back-to-top').click(function () {
    $('html, body').animate({
      scrollTop: 0
    }, 1500, 'easeInOutExpo');
    return false;
  }); // Initiate the wowjs animation library

  var wow = new _lib_wow_wow_min__WEBPACK_IMPORTED_MODULE_0___default.a().init(); // Initiate superfish on nav menu

  $('.nav-menu').superfish({
    animation: {
      opacity: 'show'
    },
    speed: 400
  }); // Mobile Navigation

  if ($('#nav-menu-container').length) {
    var $mobile_nav = $('#nav-menu-container').clone().prop({
      id: 'mobile-nav'
    });
    $mobile_nav.find('> ul').attr({
      'class': '',
      'id': ''
    });
    $('body').append($mobile_nav);
    $('body').prepend('<button type="button" id="mobile-nav-toggle"><i class="fa fa-bars"></i></button>');
    $('body').append('<div id="mobile-body-overly"></div>');
    $('#mobile-nav').find('.menu-has-children').prepend('<i class="fa fa-chevron-down"></i>');
    $(document).on('click', '.menu-has-children i', function (e) {
      $(this).next().toggleClass('menu-item-active');
      $(this).nextAll('ul').eq(0).slideToggle();
      $(this).toggleClass("fa-chevron-up fa-chevron-down");
    });
    $(document).on('click', '#mobile-nav-toggle', function (e) {
      $('body').toggleClass('mobile-nav-active');
      $('#mobile-nav-toggle i').toggleClass('fa-times fa-bars');
      $('#mobile-body-overly').toggle();
    });
    $(document).click(function (e) {
      var container = $("#mobile-nav, #mobile-nav-toggle");

      if (!container.is(e.target) && container.has(e.target).length === 0) {
        if ($('body').hasClass('mobile-nav-active')) {
          $('body').removeClass('mobile-nav-active');
          $('#mobile-nav-toggle i').toggleClass('fa-times fa-bars');
          $('#mobile-body-overly').fadeOut();
        }
      }
    });
  } else if ($("#mobile-nav, #mobile-nav-toggle").length) {
    $("#mobile-nav, #mobile-nav-toggle").hide();
  } // Smooth scroll for the menu and links with .scrollto classes


  $('.nav-menu a, #mobile-nav a, .scrollto').on('click', function () {
    if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
      var target = $(this.hash);

      if (target.length) {
        var top_space = 0;

        if ($('#header').length) {
          top_space = $('#header').outerHeight();

          if (!$('#header').hasClass('header-scrolled')) {
            top_space = top_space - 20;
          }
        }

        $('html, body').animate({
          scrollTop: target.offset().top - top_space
        }, 1500, 'easeInOutExpo');

        if ($(this).parents('.nav-menu').length) {
          $('.nav-menu .menu-active').removeClass('menu-active');
          $(this).closest('li').addClass('menu-active');
        }

        if ($('body').hasClass('mobile-nav-active')) {
          $('body').removeClass('mobile-nav-active');
          $('#mobile-nav-toggle i').toggleClass('fa-times fa-bars');
          $('#mobile-body-overly').fadeOut();
        }

        return false;
      }
    }
  }); // jQuery counterUp (used in Facts section)

  $('[data-toggle="counter-up"]').counterUp({
    delay: 10,
    time: 1000
  }); // Porfolio isotope and filter
  // var portfolioIsotope = $('.gallery-container').isotope({
  //     itemSelector: '.gallery-item',
  //     layoutMode  : 'fitRows'
  // });
  // $('#gallery-filters li').on('click', function () {
  //     $("#gallery-filters li").removeClass('filter-active');
  //     $(this).addClass('filter-active');
  //
  //     portfolioIsotope.isotope({filter: $(this).data('filter')});
  // });

  $(document).on('click', '.collapse-text-down', function (e) {
    $(this).parent().parent().find('#' + $(this).data('target-id')).show();
    $(this).hide();
  });
  $(document).on('click', '.collapse-text-up', function (e) {
    $('#' + $(this).data('target-id')).hide();
    $(this).parent().parent().parent().find('.collapse-text-down').show();
  });
})(jQuery);

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.15.0
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["default"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })

},[["./assets/js/app.js","runtime"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvYXBwLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9saWIvYm9vdHN0cmFwL2pzL2Jvb3RzdHJhcC5idW5kbGUubWluLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9saWIvYm9vdHN0cmFwL2pzL2Jvb3RzdHJhcC5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2xpYi9jb3VudGVydXAvY291bnRlcnVwLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbGliL2Vhc2luZy9lYXNpbmcubWluLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9saWIvbGlnaHRib3gvanMvbGlnaHRib3gubWluLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9saWIvc3VwZXJmaXNoL2hvdmVySW50ZW50LmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9saWIvc3VwZXJmaXNoL3N1cGVyZmlzaC5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2xpYi90b3VjaFN3aXBlL2pxdWVyeS50b3VjaFN3aXBlLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbGliL3dheXBvaW50cy93YXlwb2ludHMubWluLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9saWIvd293L3dvdy5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvZXNtL3BvcHBlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyJdLCJuYW1lcyI6WyJyZXF1aXJlIiwidCIsImUiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwicCIsImkiLCJuIiwibGVuZ3RoIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJzIiwicHJvdG90eXBlIiwibCIsIm8iLCJhcmd1bWVudHMiLCJyIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImNvbmNhdCIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImZvckVhY2giLCJ2YWx1ZSIsImhhc093blByb3BlcnR5IiwiZGVmYXVsdCIsIm9uZSIsIm0iLCJUUkFOU0lUSU9OX0VORCIsInNldFRpbWVvdXQiLCJ0cmlnZ2VyVHJhbnNpdGlvbkVuZCIsImdldFVJRCIsIk1hdGgiLCJyYW5kb20iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsInRyaW0iLCJxdWVyeVNlbGVjdG9yIiwiZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQiLCJjc3MiLCJwYXJzZUZsb2F0Iiwic3BsaXQiLCJyZWZsb3ciLCJvZmZzZXRIZWlnaHQiLCJ0cmlnZ2VyIiwic3VwcG9ydHNUcmFuc2l0aW9uRW5kIiwiQm9vbGVhbiIsImlzRWxlbWVudCIsIm5vZGVUeXBlIiwidHlwZUNoZWNrQ29uZmlnIiwiY2FsbCIsImEiLCJ0b1N0cmluZyIsIm1hdGNoIiwidG9Mb3dlckNhc2UiLCJSZWdFeHAiLCJ0ZXN0IiwiRXJyb3IiLCJ0b1VwcGVyQ2FzZSIsImZpbmRTaGFkb3dSb290IiwiZG9jdW1lbnRFbGVtZW50IiwiYXR0YWNoU2hhZG93IiwiZ2V0Um9vdE5vZGUiLCJTaGFkb3dSb290IiwicGFyZW50Tm9kZSIsImZuIiwiZW11bGF0ZVRyYW5zaXRpb25FbmQiLCJldmVudCIsInNwZWNpYWwiLCJiaW5kVHlwZSIsImRlbGVnYXRlVHlwZSIsImhhbmRsZSIsInRhcmdldCIsImlzIiwiaGFuZGxlT2JqIiwiaGFuZGxlciIsImFwcGx5IiwiYyIsImgiLCJDTE9TRSIsIkNMT1NFRCIsIkNMSUNLX0RBVEFfQVBJIiwidSIsImYiLCJkIiwiZyIsIl9lbGVtZW50IiwiY2xvc2UiLCJfZ2V0Um9vdEVsZW1lbnQiLCJfdHJpZ2dlckNsb3NlRXZlbnQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJfcmVtb3ZlRWxlbWVudCIsImRpc3Bvc2UiLCJyZW1vdmVEYXRhIiwiY2xvc2VzdCIsIkV2ZW50IiwicmVtb3ZlQ2xhc3MiLCJoYXNDbGFzcyIsIl9kZXN0cm95RWxlbWVudCIsImRldGFjaCIsInJlbW92ZSIsIl9qUXVlcnlJbnRlcmZhY2UiLCJlYWNoIiwiZGF0YSIsIl9oYW5kbGVEaXNtaXNzIiwicHJldmVudERlZmF1bHQiLCJnZXQiLCJvbiIsIkNvbnN0cnVjdG9yIiwibm9Db25mbGljdCIsIl8iLCJ2IiwieSIsIkUiLCJiIiwidyIsIlQiLCJDIiwiUyIsIkQiLCJJIiwiQSIsIk8iLCJOIiwiRk9DVVNfQkxVUl9EQVRBX0FQSSIsImsiLCJ0b2dnbGUiLCJ0eXBlIiwiY2hlY2tlZCIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiaGFzQXR0cmlidXRlIiwiZm9jdXMiLCJzZXRBdHRyaWJ1dGUiLCJ0b2dnbGVDbGFzcyIsIkwiLCJQIiwieCIsIkgiLCJqIiwiUiIsImludGVydmFsIiwia2V5Ym9hcmQiLCJzbGlkZSIsInBhdXNlIiwid3JhcCIsInRvdWNoIiwiRiIsIk0iLCJXIiwiVSIsIkIiLCJxIiwiU0xJREUiLCJTTElEIiwiS0VZRE9XTiIsIk1PVVNFRU5URVIiLCJNT1VTRUxFQVZFIiwiVE9VQ0hTVEFSVCIsIlRPVUNITU9WRSIsIlRPVUNIRU5EIiwiUE9JTlRFUkRPV04iLCJQT0lOVEVSVVAiLCJEUkFHX1NUQVJUIiwiTE9BRF9EQVRBX0FQSSIsIksiLCJRIiwiWSIsIlYiLCJYIiwieiIsIkciLCJKIiwiWiIsIiQiLCJ0dCIsImV0IiwibnQiLCJpdCIsIm90IiwicnQiLCJzdCIsIlRPVUNIIiwiUEVOIiwiYXQiLCJfaXRlbXMiLCJfaW50ZXJ2YWwiLCJfYWN0aXZlRWxlbWVudCIsIl9pc1BhdXNlZCIsIl9pc1NsaWRpbmciLCJ0b3VjaFRpbWVvdXQiLCJ0b3VjaFN0YXJ0WCIsInRvdWNoRGVsdGFYIiwiX2NvbmZpZyIsIl9nZXRDb25maWciLCJfaW5kaWNhdG9yc0VsZW1lbnQiLCJfdG91Y2hTdXBwb3J0ZWQiLCJuYXZpZ2F0b3IiLCJtYXhUb3VjaFBvaW50cyIsIl9wb2ludGVyRXZlbnQiLCJ3aW5kb3ciLCJQb2ludGVyRXZlbnQiLCJNU1BvaW50ZXJFdmVudCIsIl9hZGRFdmVudExpc3RlbmVycyIsIm5leHQiLCJfc2xpZGUiLCJuZXh0V2hlblZpc2libGUiLCJoaWRkZW4iLCJwcmV2IiwiY3ljbGUiLCJjbGVhckludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ2aXNpYmlsaXR5U3RhdGUiLCJiaW5kIiwidG8iLCJfZ2V0SXRlbUluZGV4Iiwib2ZmIiwiX2hhbmRsZVN3aXBlIiwiYWJzIiwiX2tleWRvd24iLCJfYWRkVG91Y2hFdmVudExpc3RlbmVycyIsIm9yaWdpbmFsRXZlbnQiLCJwb2ludGVyVHlwZSIsImNsaWVudFgiLCJ0b3VjaGVzIiwiY2xlYXJUaW1lb3V0IiwicXVlcnlTZWxlY3RvckFsbCIsImFkZCIsInRhZ05hbWUiLCJ3aGljaCIsInNsaWNlIiwiaW5kZXhPZiIsIl9nZXRJdGVtQnlEaXJlY3Rpb24iLCJfdHJpZ2dlclNsaWRlRXZlbnQiLCJyZWxhdGVkVGFyZ2V0IiwiZGlyZWN0aW9uIiwiZnJvbSIsIl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50IiwiY2hpbGRyZW4iLCJhZGRDbGFzcyIsInBhcnNlSW50IiwiZGVmYXVsdEludGVydmFsIiwiVHlwZUVycm9yIiwiX2RhdGFBcGlDbGlja0hhbmRsZXIiLCJsdCIsImN0IiwiaHQiLCJ1dCIsImZ0IiwicGFyZW50IiwiZHQiLCJwdCIsIlNIT1ciLCJTSE9XTiIsIkhJREUiLCJISURERU4iLCJtdCIsImd0IiwiX3QiLCJ2dCIsInl0IiwiRXQiLCJidCIsInd0IiwiVHQiLCJfaXNUcmFuc2l0aW9uaW5nIiwiX3RyaWdnZXJBcnJheSIsImlkIiwiX3NlbGVjdG9yIiwicHVzaCIsIl9wYXJlbnQiLCJfZ2V0UGFyZW50IiwiX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyIsImhpZGUiLCJzaG93Iiwibm90IiwiX2dldERpbWVuc2lvbiIsInN0eWxlIiwiYXR0ciIsInNldFRyYW5zaXRpb25pbmciLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJqcXVlcnkiLCJfZ2V0VGFyZ2V0RnJvbUVsZW1lbnQiLCJjdXJyZW50VGFyZ2V0IiwiQ3QiLCJTdCIsIkR0IiwiSXQiLCJ1c2VyQWdlbnQiLCJBdCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIk90IiwiTnQiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJnZXRDb21wdXRlZFN0eWxlIiwia3QiLCJub2RlTmFtZSIsImhvc3QiLCJMdCIsImJvZHkiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsIlB0IiwiTVNJbnB1dE1ldGhvZENvbnRleHQiLCJkb2N1bWVudE1vZGUiLCJ4dCIsIkh0IiwianQiLCJvZmZzZXRQYXJlbnQiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJSdCIsIkZ0IiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIiwiY3JlYXRlUmFuZ2UiLCJzZXRTdGFydCIsInNldEVuZCIsImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJNdCIsInNjcm9sbGluZ0VsZW1lbnQiLCJXdCIsIlV0IiwibWF4IiwiQnQiLCJoZWlnaHQiLCJ3aWR0aCIsInF0IiwiS3QiLCJRdCIsImFzc2lnbiIsIll0IiwicmlnaHQiLCJsZWZ0IiwiYm90dG9tIiwidG9wIiwiVnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIm9mZnNldFdpZHRoIiwiWHQiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsIm1hcmdpblRvcCIsIm1hcmdpbkxlZnQiLCJ6dCIsInBhcmVudEVsZW1lbnQiLCJHdCIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIkp0IiwibWFwIiwiYXJlYSIsInNvcnQiLCJadCIsIiR0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luUmlnaHQiLCJ0ZSIsInJlcGxhY2UiLCJlZSIsIm5lIiwiQXJyYXkiLCJmaW5kIiwiaWUiLCJmaW5kSW5kZXgiLCJmdW5jdGlvbiIsImNvbnNvbGUiLCJ3YXJuIiwiZW5hYmxlZCIsIm9mZnNldHMiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJvZSIsInNvbWUiLCJuYW1lIiwicmUiLCJjaGFyQXQiLCJzZSIsImFlIiwidXBkYXRlQm91bmQiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInNjcm9sbFBhcmVudHMiLCJzY3JvbGxFbGVtZW50IiwiZXZlbnRzRW5hYmxlZCIsImxlIiwic3RhdGUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInNjaGVkdWxlVXBkYXRlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNlIiwiaXNOYU4iLCJpc0Zpbml0ZSIsImhlIiwidWUiLCJmZSIsIm9yZGVyIiwiZGUiLCJwZSIsIm1lIiwicmV2ZXJzZSIsImdlIiwiX2UiLCJ2ZSIsInllIiwic2VhcmNoIiwicmVkdWNlIiwiRWUiLCJwbGFjZW1lbnQiLCJwb3NpdGlvbkZpeGVkIiwicmVtb3ZlT25EZXN0cm95Iiwib25DcmVhdGUiLCJvblVwZGF0ZSIsIm1vZGlmaWVycyIsInNoaWZ0Iiwic3RhcnQiLCJlbmQiLCJvZmZzZXQiLCJwcmV2ZW50T3ZlcmZsb3ciLCJib3VuZGFyaWVzRWxlbWVudCIsImluc3RhbmNlIiwicGFkZGluZyIsImJvdW5kYXJpZXMiLCJwcmlvcml0eSIsInByaW1hcnkiLCJlc2NhcGVXaXRoUmVmZXJlbmNlIiwic2Vjb25kYXJ5IiwibWluIiwia2VlcFRvZ2V0aGVyIiwiZmxvb3IiLCJhcnJvdyIsImVsZW1lbnQiLCJhcnJvd0VsZW1lbnQiLCJyb3VuZCIsImZsaXAiLCJmbGlwcGVkIiwib3JpZ2luYWxQbGFjZW1lbnQiLCJiZWhhdmlvciIsImZsaXBWYXJpYXRpb25zIiwiaW5uZXIiLCJhdHRyaWJ1dGVzIiwiY29tcHV0ZVN0eWxlIiwiZ3B1QWNjZWxlcmF0aW9uIiwicG9zaXRpb24iLCJkZXZpY2VQaXhlbFJhdGlvIiwid2lsbENoYW5nZSIsInN0eWxlcyIsImFycm93U3R5bGVzIiwiYXBwbHlTdHlsZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9uTG9hZCIsImJlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidXBkYXRlIiwib3B0aW9ucyIsIkRlZmF1bHRzIiwiaXNEZXN0cm95ZWQiLCJpc0NyZWF0ZWQiLCJlbmFibGVFdmVudExpc3RlbmVycyIsImRpc2FibGVFdmVudExpc3RlbmVycyIsInJlbW92ZUNoaWxkIiwiVXRpbHMiLCJnbG9iYWwiLCJQb3BwZXJVdGlscyIsInBsYWNlbWVudHMiLCJ3ZSIsIlRlIiwiQ2UiLCJTZSIsIkRlIiwiSWUiLCJBZSIsIkNMSUNLIiwiS0VZRE9XTl9EQVRBX0FQSSIsIktFWVVQX0RBVEFfQVBJIiwiT2UiLCJOZSIsImtlIiwiTGUiLCJQZSIsInhlIiwiSGUiLCJqZSIsIlJlIiwiRmUiLCJNZSIsIldlIiwiVWUiLCJCZSIsInFlIiwiS2UiLCJRZSIsIlllIiwiVmUiLCJib3VuZGFyeSIsImRpc3BsYXkiLCJYZSIsInplIiwiX3BvcHBlciIsIl9tZW51IiwiX2dldE1lbnVFbGVtZW50IiwiX2luTmF2YmFyIiwiX2RldGVjdE5hdmJhciIsImRpc2FibGVkIiwiX2dldFBhcmVudEZyb21FbGVtZW50IiwiX2NsZWFyTWVudXMiLCJfZ2V0UG9wcGVyQ29uZmlnIiwibm9vcCIsImRlc3Ryb3kiLCJzdG9wUHJvcGFnYXRpb24iLCJjb25zdHJ1Y3RvciIsIkRlZmF1bHQiLCJEZWZhdWx0VHlwZSIsIl9nZXRQbGFjZW1lbnQiLCJjbGlja0V2ZW50IiwiX2RhdGFBcGlLZXlkb3duSGFuZGxlciIsIkdlIiwiSmUiLCJaZSIsIiRlIiwidG4iLCJiYWNrZHJvcCIsImVuIiwibm4iLCJGT0NVU0lOIiwiUkVTSVpFIiwiQ0xJQ0tfRElTTUlTUyIsIktFWURPV05fRElTTUlTUyIsIk1PVVNFVVBfRElTTUlTUyIsIk1PVVNFRE9XTl9ESVNNSVNTIiwicm4iLCJzbiIsImFuIiwibG4iLCJjbiIsImhuIiwidW4iLCJkbiIsInBuIiwiX2RpYWxvZyIsIl9iYWNrZHJvcCIsIl9pc1Nob3duIiwiX2lzQm9keU92ZXJmbG93aW5nIiwiX2lnbm9yZUJhY2tkcm9wQ2xpY2siLCJfc2Nyb2xsYmFyV2lkdGgiLCJfY2hlY2tTY3JvbGxiYXIiLCJfc2V0U2Nyb2xsYmFyIiwiX2FkanVzdERpYWxvZyIsIl9zZXRFc2NhcGVFdmVudCIsIl9zZXRSZXNpemVFdmVudCIsIl9zaG93QmFja2Ryb3AiLCJfc2hvd0VsZW1lbnQiLCJfaGlkZU1vZGFsIiwiaGFuZGxlVXBkYXRlIiwiRUxFTUVOVF9OT0RFIiwiYXBwZW5kQ2hpbGQiLCJzY3JvbGxUb3AiLCJfZW5mb3JjZUZvY3VzIiwiaGFzIiwiX3Jlc2V0QWRqdXN0bWVudHMiLCJfcmVzZXRTY3JvbGxiYXIiLCJfcmVtb3ZlQmFja2Ryb3AiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiYXBwZW5kVG8iLCJzY3JvbGxIZWlnaHQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsIl9nZXRTY3JvbGxiYXJXaWR0aCIsIm1uIiwiZ24iLCJfbiIsInZuIiwieW4iLCJFbiIsImJuIiwiYW5pbWF0aW9uIiwidGVtcGxhdGUiLCJ0aXRsZSIsImRlbGF5IiwiaHRtbCIsInNlbGVjdG9yIiwiY29udGFpbmVyIiwiZmFsbGJhY2tQbGFjZW1lbnQiLCJ3biIsIkFVVE8iLCJUT1AiLCJSSUdIVCIsIkJPVFRPTSIsIkxFRlQiLCJUbiIsIkNuIiwiU24iLCJEbiIsIklOU0VSVEVEIiwiRk9DVVNPVVQiLCJJbiIsIkFuIiwiT24iLCJObiIsImtuIiwiTG4iLCJQbiIsInhuIiwiSG4iLCJfaXNFbmFibGVkIiwiX3RpbWVvdXQiLCJfaG92ZXJTdGF0ZSIsIl9hY3RpdmVUcmlnZ2VyIiwiY29uZmlnIiwidGlwIiwiX3NldExpc3RlbmVycyIsImVuYWJsZSIsImRpc2FibGUiLCJ0b2dnbGVFbmFibGVkIiwiREFUQV9LRVkiLCJfZ2V0RGVsZWdhdGVDb25maWciLCJjbGljayIsIl9pc1dpdGhBY3RpdmVUcmlnZ2VyIiwiX2VudGVyIiwiX2xlYXZlIiwiZ2V0VGlwRWxlbWVudCIsIkVWRU5UX0tFWSIsImlzV2l0aENvbnRlbnQiLCJOQU1FIiwic2V0Q29udGVudCIsIl9nZXRBdHRhY2htZW50IiwiYWRkQXR0YWNobWVudENsYXNzIiwiX2dldENvbnRhaW5lciIsIl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UiLCJfZml4VHJhbnNpdGlvbiIsIl9jbGVhblRpcENsYXNzIiwiZ2V0VGl0bGUiLCJzZXRFbGVtZW50Q29udGVudCIsImVtcHR5IiwiYXBwZW5kIiwidGV4dCIsIl9maXhUaXRsZSIsImNvbnRlbnQiLCJqb2luIiwiam4iLCJSbiIsIkZuIiwiTW4iLCJXbiIsIlVuIiwiQm4iLCJxbiIsIktuIiwiUW4iLCJZbiIsIlZuIiwiWG4iLCJ6biIsImNyZWF0ZSIsIl9fcHJvdG9fXyIsIl9nZXRDb250ZW50IiwiR24iLCJKbiIsIlpuIiwiJG4iLCJ0aSIsIm1ldGhvZCIsImVpIiwibmkiLCJBQ1RJVkFURSIsIlNDUk9MTCIsImlpIiwib2kiLCJyaSIsInNpIiwiYWkiLCJsaSIsImNpIiwiaGkiLCJ1aSIsImZpIiwiZGkiLCJwaSIsIm1pIiwiX3Njcm9sbEVsZW1lbnQiLCJfb2Zmc2V0cyIsIl90YXJnZXRzIiwiX2FjdGl2ZVRhcmdldCIsIl9zY3JvbGxIZWlnaHQiLCJfcHJvY2VzcyIsInJlZnJlc2giLCJfZ2V0U2Nyb2xsVG9wIiwiX2dldFNjcm9sbEhlaWdodCIsInBhZ2VZT2Zmc2V0IiwiX2dldE9mZnNldEhlaWdodCIsIl9hY3RpdmF0ZSIsIl9jbGVhciIsInBhcmVudHMiLCJnaSIsIl9pIiwidmkiLCJ0YWIiLCJ5aSIsIkVpIiwiYmkiLCJ3aSIsIlRpIiwiQ2kiLCJTaSIsIkRpIiwiSWkiLCJBaSIsIk9pIiwiTmkiLCJraSIsIkxpIiwibWFrZUFycmF5IiwiX3RyYW5zaXRpb25Db21wbGV0ZSIsIlBpIiwieGkiLCJIaSIsImppIiwiUmkiLCJGaSIsIk1pIiwiV2kiLCJVaSIsIkJpIiwiYXV0b2hpZGUiLCJxaSIsIktpIiwiUWkiLCJfY2xvc2UiLCJVdGlsIiwiQWxlcnQiLCJCdXR0b24iLCJDYXJvdXNlbCIsIkNvbGxhcHNlIiwiRHJvcGRvd24iLCJNb2RhbCIsIlBvcG92ZXIiLCJTY3JvbGxzcHkiLCJUYWIiLCJUb2FzdCIsIlRvb2x0aXAiLCJjb3VudGVyVXAiLCJzZXR0aW5ncyIsImV4dGVuZCIsInRpbWUiLCJiZWdpbkF0IiwiZm9ybWF0dGVyIiwiY29udGV4dCIsImNhbGxiYWNrIiwiJHRoaXMiLCJjb3VudGVyIiwiY291bnRlclVwcGVyIiwibnVtcyIsImRpdmlzaW9ucyIsIm51bSIsImlzQ29tbWEiLCJkZWNpbWFsUGxhY2VzIiwiaXNUaW1lIiwidGltZXMiLCJwb3AiLCJuZXdOdW0iLCJ0b0ZpeGVkIiwiaG91cnMiLCJtaW51dGVzIiwic2Vjb25kcyIsInVuc2hpZnQiLCJ3YXlwb2ludCIsImpRdWVyeSIsImVhc2luZyIsImpzd2luZyIsInN3aW5nIiwicG93Iiwic3FydCIsInNpbiIsImNvcyIsIlBJIiwiZGVmIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJblNpbmUiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dFNpbmUiLCJlYXNlSW5FeHBvIiwiZWFzZU91dEV4cG8iLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluQ2lyYyIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJlYXNlT3V0RWxhc3RpYyIsImVhc2VJbk91dEVsYXN0aWMiLCJlYXNlSW5CYWNrIiwiZWFzZU91dEJhY2siLCJlYXNlSW5PdXRCYWNrIiwiZWFzZUluQm91bmNlIiwiZWFzZU91dEJvdW5jZSIsImVhc2VJbk91dEJvdW5jZSIsImFsYnVtIiwiY3VycmVudEltYWdlSW5kZXgiLCJpbml0IiwiZGVmYXVsdHMiLCJvcHRpb24iLCJhbGJ1bUxhYmVsIiwiYWx3YXlzU2hvd05hdk9uVG91Y2hEZXZpY2VzIiwiZmFkZUR1cmF0aW9uIiwiZml0SW1hZ2VzSW5WaWV3cG9ydCIsImltYWdlRmFkZUR1cmF0aW9uIiwicG9zaXRpb25Gcm9tVG9wIiwicmVzaXplRHVyYXRpb24iLCJzaG93SW1hZ2VOdW1iZXJMYWJlbCIsIndyYXBBcm91bmQiLCJkaXNhYmxlU2Nyb2xsaW5nIiwic2FuaXRpemVUaXRsZSIsImltYWdlQ291bnRMYWJlbCIsInJlYWR5IiwiYnVpbGQiLCIkbGlnaHRib3giLCIkb3ZlcmxheSIsIiRvdXRlckNvbnRhaW5lciIsIiRjb250YWluZXIiLCIkaW1hZ2UiLCIkbmF2IiwiY29udGFpbmVyUGFkZGluZyIsImltYWdlQm9yZGVyV2lkdGgiLCJjaGFuZ2VJbWFnZSIsImFsdCIsImxpbmsiLCJwcm94eSIsInNpemVPdmVybGF5IiwidmlzaWJpbGl0eSIsInByb3AiLCJzY3JvbGxMZWZ0IiwiZmFkZUluIiwiZGlzYWJsZUtleWJvYXJkTmF2IiwiSW1hZ2UiLCJvbmxvYWQiLCJzcmMiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsInNpemVDb250YWluZXIiLCJzaG93SW1hZ2UiLCJvdXRlcldpZHRoIiwib3V0ZXJIZWlnaHQiLCJhbmltYXRlIiwic3RvcCIsInVwZGF0ZU5hdiIsInVwZGF0ZURldGFpbHMiLCJwcmVsb2FkTmVpZ2hib3JpbmdJbWFnZXMiLCJlbmFibGVLZXlib2FyZE5hdiIsImNyZWF0ZUV2ZW50Iiwib3BlbiIsImxvY2F0aW9uIiwiaHJlZiIsImtleWJvYXJkQWN0aW9uIiwia2V5Q29kZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImZhZGVPdXQiLCJmYWN0b3J5IiwiX2NmZyIsInNlbnNpdGl2aXR5IiwidGltZW91dCIsIklOU1RBTkNFX0NPVU5UIiwiY1giLCJjWSIsInRyYWNrIiwiZXYiLCJwYWdlWCIsInBhZ2VZIiwiY29tcGFyZSIsIiRlbCIsImNmZyIsInBYIiwicFkiLCJ0aW1lb3V0SWQiLCJpc0FjdGl2ZSIsIm92ZXIiLCJvdXQiLCJob3ZlckludGVudCIsImhhbmRsZXJJbiIsImhhbmRsZXJPdXQiLCJpbnN0YW5jZUlkIiwiaXNQbGFpbk9iamVjdCIsImlzRnVuY3Rpb24iLCJoYW5kbGVIb3ZlciIsImhvdmVySW50ZW50RGF0YSIsIm1vdXNlbW92ZSIsImJjQ2xhc3MiLCJtZW51Q2xhc3MiLCJhbmNob3JDbGFzcyIsIm1lbnVBcnJvd0NsYXNzIiwiY3NzQXJyb3dzIiwicGF0aENsYXNzIiwicGF0aExldmVscyIsImhvdmVyQ2xhc3MiLCJwb3BVcFNlbGVjdG9yIiwic2ZUaW1lciIsInNpYmxpbmdzIiwic3VwZXJmaXNoIiwicmV0YWluUGF0aCIsImluQXJyYXkiLCIkcGF0aCIsIm9uSWRsZSIsIm9uSGFuZGxlVG91Y2giLCJkaXNhYmxlSEkiLCJzcGVlZE91dCIsIm9uQmVmb3JlSGlkZSIsImFuaW1hdGlvbk91dCIsIm9uSGlkZSIsIm9uQmVmb3JlU2hvdyIsInNwZWVkIiwib25TaG93Iiwib25EZXN0cm95Iiwib25Jbml0IiwiZXJyb3IiLCJvcGFjaXR5IiwiYWxsb3dQYWdlU2Nyb2xsIiwic3dpcGUiLCJzd2lwZVN0YXR1cyIsIk5PTkUiLCJ0YXAiLCJwbHVnaW4iLCJQTFVHSU5fTlMiLCJUb3VjaFN3aXBlIiwidG91Y2hTdGFydCIsImpxRXZlbnQiLCJnZXRUb3VjaEluUHJvZ3Jlc3MiLCJleGNsdWRlZEVsZW1lbnRzIiwiJGVsZW1lbnQiLCJmYWxsYmFja1RvTW91c2VFdmVudHMiLCJyZXQiLCJldnQiLCJwaGFzZSIsIlBIQVNFX1NUQVJUIiwiZmluZ2VyQ291bnQiLCJwcmV2ZW50RGVmYXVsdEV2ZW50cyIsImRpc3RhbmNlIiwiY3VycmVudERpcmVjdGlvbiIsInBpbmNoRGlyZWN0aW9uIiwiZHVyYXRpb24iLCJzdGFydFRvdWNoZXNEaXN0YW5jZSIsImVuZFRvdWNoZXNEaXN0YW5jZSIsInBpbmNoWm9vbSIsInBpbmNoRGlzdGFuY2UiLCJtYXhpbXVtc01hcCIsImNyZWF0ZU1heGltdW1zRGF0YSIsImNhbmNlbE11bHRpRmluZ2VyUmVsZWFzZSIsImNyZWF0ZUZpbmdlckRhdGEiLCJmaW5nZXJzIiwiQUxMX0ZJTkdFUlMiLCJoYXNQaW5jaGVzIiwic3RhcnRUaW1lIiwiZ2V0VGltZVN0YW1wIiwiY2FsY3VsYXRlVG91Y2hlc0Rpc3RhbmNlIiwiZmluZ2VyRGF0YSIsInBpbmNoU3RhdHVzIiwidHJpZ2dlckhhbmRsZXIiLCJQSEFTRV9DQU5DRUwiLCJob2xkIiwiaG9sZFRpbWVvdXQiLCJsb25nVGFwVGhyZXNob2xkIiwic2V0VG91Y2hJblByb2dyZXNzIiwidG91Y2hNb3ZlIiwiUEhBU0VfRU5EIiwiaW5NdWx0aUZpbmdlclJlbGVhc2UiLCJjdXJyZW50RmluZ2VyIiwidXBkYXRlRmluZ2VyRGF0YSIsImVuZFRpbWUiLCJQSEFTRV9NT1ZFIiwiY2FsY3VsYXRlUGluY2hEaXJlY3Rpb24iLCJjYWxjdWxhdGVQaW5jaFpvb20iLCJjYWxjdWxhdGVEaXJlY3Rpb24iLCJsYXN0IiwidmFsaWRhdGVEZWZhdWx0RXZlbnQiLCJjYWxjdWxhdGVEaXN0YW5jZSIsImNhbGN1bGF0ZUR1cmF0aW9uIiwic2V0TWF4RGlzdGFuY2UiLCJ0cmlnZ2VyT25Ub3VjaEVuZCIsInRyaWdnZXJPblRvdWNoTGVhdmUiLCJpbkJvdW5kcyIsImJvdW5kcyIsImdldGJvdW5kcyIsImlzSW5Cb3VuZHMiLCJnZXROZXh0UGhhc2UiLCJ0b3VjaEVuZCIsInN0YXJ0TXVsdGlGaW5nZXJSZWxlYXNlIiwiZmluZ2VyQ291bnRBdFJlbGVhc2UiLCJkaWRTd2lwZUJhY2tUb0NhbmNlbCIsInZhbGlkYXRlU3dpcGVEaXN0YW5jZSIsImNhbmNlbGFibGUiLCJoYXNUYXAiLCJ0cmlnZ2VySGFuZGxlckZvckdlc3R1cmUiLCJUQVAiLCJ0b3VjaENhbmNlbCIsInRvdWNoTGVhdmUiLCJyZW1vdmVMaXN0ZW5lcnMiLCJ1bmJpbmQiLCJTVEFSVF9FViIsIkNBTkNFTF9FViIsIk1PVkVfRVYiLCJFTkRfRVYiLCJMRUFWRV9FViIsImN1cnJlbnRQaGFzZSIsIm5leHRQaGFzZSIsInZhbGlkVGltZSIsInZhbGlkYXRlU3dpcGVUaW1lIiwidmFsaWREaXN0YW5jZSIsImRpZENhbmNlbCIsImRpZFN3aXBlIiwiaGFzU3dpcGVzIiwiU1dJUEUiLCJkaWRQaW5jaCIsIlBJTkNIIiwiZGlkRG91YmxlVGFwIiwiRE9VQkxFX1RBUCIsImRpZExvbmdUYXAiLCJMT05HX1RBUCIsImRpZFRhcCIsImdlc3R1cmUiLCJ2YWxpZGF0ZVN3aXBlIiwic2luZ2xlVGFwVGltZW91dCIsInN3aXBlTGVmdCIsInN3aXBlUmlnaHQiLCJVUCIsInN3aXBlVXAiLCJET1dOIiwic3dpcGVEb3duIiwidmFsaWRhdGVQaW5jaCIsIklOIiwicGluY2hJbiIsIk9VVCIsInBpbmNoT3V0IiwiaGFzRG91YmxlVGFwIiwiaW5Eb3VibGVUYXAiLCJkb3VibGVUYXBTdGFydFRpbWUiLCJkb3VibGVUYXBUaHJlc2hvbGQiLCJkb3VibGVUYXAiLCJsb25nVGFwIiwidmFsaWQiLCJ0aHJlc2hvbGQiLCJjYW5jZWxsZWQiLCJjYW5jZWxUaHJlc2hvbGQiLCJnZXRNYXhEaXN0YW5jZSIsInZhbGlkYXRlUGluY2hEaXN0YW5jZSIsInBpbmNoVGhyZXNob2xkIiwicmVzdWx0IiwibWF4VGltZVRocmVzaG9sZCIsImF1dG8iLCJIT1JJWk9OVEFMIiwiVkVSVElDQUwiLCJoYXNDb3JyZWN0RmluZ2VyQ291bnQiLCJ2YWxpZGF0ZUZpbmdlcnMiLCJoYXNFbmRQb2ludCIsInZhbGlkYXRlRW5kUG9pbnQiLCJoYXNDb3JyZWN0RGlzdGFuY2UiLCJoYXNWYWxpZFRpbWUiLCJoYXNWYWxpZERpc3RhbmNlIiwiU1VQUE9SVFNfVE9VQ0giLCJoYXNMb25nVGFwIiwidmFsaWRhdGVEb3VibGVUYXAiLCJub3ciLCJ2YWxpZGF0ZVRhcCIsInZhbGlkYXRlTG9uZ1RhcCIsIkRPVUJMRV9UQVBfVEhSRVNIT0xEIiwicHJldmlvdXNUb3VjaEVuZFRpbWUiLCJ3aXRoaW5UaHJlc2hvbGQiLCJkaWZmIiwiZmluZ2VyUmVsZWFzZVRocmVzaG9sZCIsInZhbCIsImNsaWVudFkiLCJpZGVudGlmaWVyIiwiZ2V0RmluZ2VyRGF0YSIsIm1heERhdGEiLCJjcmVhdGVNYXhpbXVtVk8iLCJkaXIiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJkaWZmWCIsImRpZmZZIiwic3RhcnREaXN0YW5jZSIsImVuZERpc3RhbmNlIiwicGVyY2VudCIsImNhbGN1bGF0ZUFuZ2xlIiwiYXRhbjIiLCJhbmdsZSIsImNvbXBhcmVQb2ludHMiLCJEYXRlIiwiZ2V0VGltZSIsImVsIiwicG9pbnQiLCJwb2ludEEiLCJwb2ludEIiLCJ1c2VUb3VjaEV2ZW50cyIsIlNVUFBPUlRTX1BPSU5URVIiLCJTVVBQT1JUU19QT0lOVEVSX0lFMTAiLCJwcm9wZXJ0eSIsIlZFUlNJT04iLCJtc1BvaW50ZXJFbmFibGVkIiwicG9pbnRlckVuYWJsZWQiLCJ2ZXJzaW9uIiwicGhhc2VzIiwiZGlyZWN0aW9ucyIsInBhZ2VTY3JvbGwiLCJPTkUiLCJUV08iLCJUSFJFRSIsIkZPVVIiLCJGSVZFIiwiQUxMIiwiQWRhcHRlciIsImFkYXB0ZXIiLCJheGlzIiwiaG9yaXpvbnRhbCIsInRyaWdnZXJQb2ludCIsImdyb3VwIiwiR3JvdXAiLCJmaW5kT3JDcmVhdGUiLCJDb250ZXh0IiwiZmluZE9yQ3JlYXRlQnlFbGVtZW50Iiwib2Zmc2V0QWxpYXNlcyIsInF1ZXVlVHJpZ2dlciIsInByZXZpb3VzIiwiaW52b2tlQWxsIiwiZGVzdHJveUFsbCIsImRpc2FibGVBbGwiLCJlbmFibGVBbGwiLCJyZWZyZXNoQWxsIiwidmlld3BvcnRIZWlnaHQiLCJ2aWV3cG9ydFdpZHRoIiwiYWRhcHRlcnMiLCJjb250aW51b3VzIiwiV2F5cG9pbnQiLCJkaWRTY3JvbGwiLCJkaWRSZXNpemUiLCJvbGRTY3JvbGwiLCJ3YXlwb2ludHMiLCJ2ZXJ0aWNhbCIsIndheXBvaW50Q29udGV4dEtleSIsIndpbmRvd0NvbnRleHQiLCJjcmVhdGVUaHJvdHRsZWRTY3JvbGxIYW5kbGVyIiwiY3JlYXRlVGhyb3R0bGVkUmVzaXplSGFuZGxlciIsImNoZWNrRW1wdHkiLCJpc0VtcHR5T2JqZWN0IiwiaGFuZGxlUmVzaXplIiwiaGFuZGxlU2Nyb2xsIiwiaXNUb3VjaCIsIm5ld1Njcm9sbCIsImZvcndhcmQiLCJiYWNrd2FyZCIsImZsdXNoVHJpZ2dlcnMiLCJjb250ZXh0T2Zmc2V0IiwiY29udGV4dFNjcm9sbCIsImNvbnRleHREaW1lbnNpb24iLCJvZmZzZXRQcm9wIiwiY2VpbCIsImZpbmRCeUVsZW1lbnQiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjbGVhclRyaWdnZXJRdWV1ZXMiLCJ0cmlnZ2VyUXVldWVzIiwidXAiLCJkb3duIiwic3BsaWNlIiwiZmlyc3QiLCJaZXB0byIsImluaXRDdXN0b21FdmVudCIsImNyZWF0ZUV2ZW50T2JqZWN0IiwiZXZlbnRUeXBlIiwiZXZlbnROYW1lIiwiZGlzcGF0Y2hFdmVudCIsImF0dGFjaEV2ZW50IiwiZGV0YWNoRXZlbnQiLCJXZWFrTWFwIiwiTW96V2Vha01hcCIsInZhbHVlcyIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJraXRNdXRhdGlvbk9ic2VydmVyIiwiTW96TXV0YXRpb25PYnNlcnZlciIsIm5vdFN1cHBvcnRlZCIsImdldFByb3BlcnR5VmFsdWUiLCJjdXJyZW50U3R5bGUiLCJib3hDbGFzcyIsImFuaW1hdGVDbGFzcyIsIm1vYmlsZSIsImxpdmUiLCJzY3JvbGxDb250YWluZXIiLCJyZXNldEFuaW1hdGlvbiIsInZlbmRvcnMiLCJzY3JvbGxIYW5kbGVyIiwic2Nyb2xsQ2FsbGJhY2siLCJzY3JvbGxlZCIsImFuaW1hdGlvbk5hbWVDYWNoZSIsIndvd0V2ZW50IiwicmVhZHlTdGF0ZSIsImZpbmlzaGVkIiwic3RvcHBlZCIsImJveGVzIiwiYWxsIiwicmVzZXRTdHlsZSIsImFkZGVkTm9kZXMiLCJkb1N5bmMiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImN1c3RvbVN0eWxlIiwic3JjRWxlbWVudCIsImNhY2hlQW5pbWF0aW9uTmFtZSIsInZlbmRvclNldCIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRGVsYXkiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImFuaW1hdGlvbk5hbWUiLCJjYWNoZWRBbmltYXRpb25OYW1lIiwic3Vic3RyIiwiZ2V0UHJvcGVydHlDU1NWYWx1ZSIsInZlbmRvckNTUyIsImNzc1RleHQiLCJzZXQiLCJpc1Zpc2libGUiLCJvZmZzZXRUb3AiLCJzY3JvbGwiLCJ3b3ciLCJXT1ciLCIkbW9iaWxlX25hdiIsImNsb25lIiwicHJlcGVuZCIsIm5leHRBbGwiLCJlcSIsInNsaWRlVG9nZ2xlIiwicGF0aG5hbWUiLCJob3N0bmFtZSIsImhhc2giLCJ0b3Bfc3BhY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFQUEsbUJBQU8sQ0FBQywwRkFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLHdHQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsaUZBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyxxRUFBRCxDQUFQLEMsQ0FDQTs7O0FBQ0FBLG1CQUFPLENBQUMsbUZBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyxnRkFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLGlGQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsbUdBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyxpRkFBRCxDQUFQOztBQUVBQSxtQkFBTyxD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDZCQUE2QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7O0FBRWYsU0FBUzs7QUFFVDtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVEsc0NBQXNDO0FBQzlDLFFBQVE7QUFDUixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHNDQUFzQztBQUM5RSxvQ0FBb0MsdUNBQXVDO0FBQzNFLG9DQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYyxxQ0FBcUM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLElBQTBDO0FBQy9DLENBQUMsaUNBQWtCLEVBQUUsbUNBQUU7QUFDdkI7QUFDQSxFQUFFO0FBQUEsb0dBQUU7QUFDSjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3IyVUQ7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFZSxxRUFBTSxFQUFDO0FBQ3RCOzs7Ozs7Ozs7Ozs7O0FDM2lGQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDREE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbnN0ICQgPSByZXF1aXJlKCdqcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzJyk7XG4vLyBjb25zdCBqUXVlcnkgPSAkLm5vQ29uZmxpY3QodHJ1ZSk7XG5cbnJlcXVpcmUoJy4vbGliL2Jvb3RzdHJhcC9qcy9ib290c3RyYXAubWluLmpzJyk7XG5yZXF1aXJlKCcuL2xpYi9ib290c3RyYXAvanMvYm9vdHN0cmFwLmJ1bmRsZS5taW4uanMnKTtcbnJlcXVpcmUoJy4vbGliL2NvdW50ZXJ1cC9jb3VudGVydXAubWluJyk7XG5yZXF1aXJlKCcuL2xpYi9lYXNpbmcvZWFzaW5nLm1pbicpO1xuLy8gcmVxdWlyZSgnLi9saWIvaXNvdG9wZS9pc290b3BlLnBrZ2QubWluLmpzJyk7XG5yZXF1aXJlKCcuL2xpYi9saWdodGJveC9qcy9saWdodGJveC5taW4nKTtcbnJlcXVpcmUoJy4vbGliL3N1cGVyZmlzaC9ob3ZlckludGVudC5qcycpO1xucmVxdWlyZSgnLi9saWIvc3VwZXJmaXNoL3N1cGVyZmlzaC5taW4nKTtcbnJlcXVpcmUoJy4vbGliL3RvdWNoU3dpcGUvanF1ZXJ5LnRvdWNoU3dpcGUubWluJyk7XG5yZXF1aXJlKCcuL2xpYi93YXlwb2ludHMvd2F5cG9pbnRzLm1pbicpO1xuXG5yZXF1aXJlKCcuL21haW4uanMnKTtcblxuLy8gaW1wb3J0ICcuL2xpYi9ib290c3RyYXAvanMvYm9vdHN0cmFwLm1pbi5qcyc7XG4vLyBpbXBvcnQgJy4vbGliL2Jvb3RzdHJhcC9qcy9ib290c3RyYXAuYnVuZGxlLm1pbi5qcyc7XG4vLyBpbXBvcnQgJy4vbGliL2NvdW50ZXJ1cC9jb3VudGVydXAubWluJztcbi8vIGltcG9ydCAnLi9saWIvZWFzaW5nL2Vhc2luZy5taW4nO1xuLy8gaW1wb3J0ICcuL2xpYi9pc290b3BlL2lzb3RvcGUucGtnZC5taW4nO1xuLy8gaW1wb3J0ICcuL2xpYi9saWdodGJveC9qcy9saWdodGJveC5taW4nO1xuLy8gaW1wb3J0ICcuL2xpYi9zdXBlcmZpc2gvaG92ZXJJbnRlbnQuanMnO1xuLy8gaW1wb3J0ICcuL2xpYi9zdXBlcmZpc2gvc3VwZXJmaXNoLm1pbic7XG4vLyBpbXBvcnQgJy4vbGliL3RvdWNoU3dpcGUvanF1ZXJ5LnRvdWNoU3dpcGUubWluJztcbi8vIGltcG9ydCAnLi9saWIvd2F5cG9pbnRzL3dheXBvaW50cy5taW4nO1xuLy9cbi8vIGltcG9ydCAnLi9tYWluLmpzJztcbiIsIi8qIVxuICAqIEJvb3RzdHJhcCB2NC4yLjEgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXG4gICogQ29weXJpZ2h0IDIwMTEtMjAxOCBUaGUgQm9vdHN0cmFwIEF1dGhvcnMgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ncmFwaHMvY29udHJpYnV0b3JzKVxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gICovXG4hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9lKGV4cG9ydHMscmVxdWlyZShcImpxdWVyeVwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCIsXCJqcXVlcnlcIl0sZSk6ZSh0LmJvb3RzdHJhcD17fSx0LmpRdWVyeSl9KHRoaXMsZnVuY3Rpb24odCxwKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBpPWVbbl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGkua2V5LGkpfX1mdW5jdGlvbiBzKHQsZSxuKXtyZXR1cm4gZSYmaSh0LnByb3RvdHlwZSxlKSxuJiZpKHQsbiksdH1mdW5jdGlvbiBsKG8pe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e30sZT1PYmplY3Qua2V5cyhyKTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzJiYoZT1lLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHIpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLHQpLmVudW1lcmFibGV9KSkpLGUuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgZSxuLGk7ZT1vLGk9cltuPXRdLG4gaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVtuXT1pfSl9cmV0dXJuIG99cD1wJiZwLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFwiKT9wLmRlZmF1bHQ6cDt2YXIgZT1cInRyYW5zaXRpb25lbmRcIjtmdW5jdGlvbiBuKHQpe3ZhciBlPXRoaXMsbj0hMTtyZXR1cm4gcCh0aGlzKS5vbmUobS5UUkFOU0lUSU9OX0VORCxmdW5jdGlvbigpe249ITB9KSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bnx8bS50cmlnZ2VyVHJhbnNpdGlvbkVuZChlKX0sdCksdGhpc312YXIgbT17VFJBTlNJVElPTl9FTkQ6XCJic1RyYW5zaXRpb25FbmRcIixnZXRVSUQ6ZnVuY3Rpb24odCl7Zm9yKDt0Kz1+figxZTYqTWF0aC5yYW5kb20oKSksZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodCk7KTtyZXR1cm4gdH0sZ2V0U2VsZWN0b3JGcm9tRWxlbWVudDpmdW5jdGlvbih0KXt2YXIgZT10LmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpO2lmKCFlfHxcIiNcIj09PWUpe3ZhciBuPXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtlPW4mJlwiI1wiIT09bj9uLnRyaW0oKTpcIlwifXJldHVybiBlJiZkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGUpP2U6bnVsbH0sZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQ6ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuIDA7dmFyIGU9cCh0KS5jc3MoXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIpLG49cCh0KS5jc3MoXCJ0cmFuc2l0aW9uLWRlbGF5XCIpLGk9cGFyc2VGbG9hdChlKSxvPXBhcnNlRmxvYXQobik7cmV0dXJuIGl8fG8/KGU9ZS5zcGxpdChcIixcIilbMF0sbj1uLnNwbGl0KFwiLFwiKVswXSwxZTMqKHBhcnNlRmxvYXQoZSkrcGFyc2VGbG9hdChuKSkpOjB9LHJlZmxvdzpmdW5jdGlvbih0KXtyZXR1cm4gdC5vZmZzZXRIZWlnaHR9LHRyaWdnZXJUcmFuc2l0aW9uRW5kOmZ1bmN0aW9uKHQpe3AodCkudHJpZ2dlcihlKX0sc3VwcG9ydHNUcmFuc2l0aW9uRW5kOmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oZSl9LGlzRWxlbWVudDpmdW5jdGlvbih0KXtyZXR1cm4odFswXXx8dCkubm9kZVR5cGV9LHR5cGVDaGVja0NvbmZpZzpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpIGluIG4paWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4saSkpe3ZhciBvPW5baV0scj1lW2ldLHM9ciYmbS5pc0VsZW1lbnQocik/XCJlbGVtZW50XCI6KGE9cix7fS50b1N0cmluZy5jYWxsKGEpLm1hdGNoKC9cXHMoW2Etel0rKS9pKVsxXS50b0xvd2VyQ2FzZSgpKTtpZighbmV3IFJlZ0V4cChvKS50ZXN0KHMpKXRocm93IG5ldyBFcnJvcih0LnRvVXBwZXJDYXNlKCkrJzogT3B0aW9uIFwiJytpKydcIiBwcm92aWRlZCB0eXBlIFwiJytzKydcIiBidXQgZXhwZWN0ZWQgdHlwZSBcIicrbysnXCIuJyl9dmFyIGF9LGZpbmRTaGFkb3dSb290OmZ1bmN0aW9uKHQpe2lmKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KXJldHVybiBudWxsO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQuZ2V0Um9vdE5vZGUpcmV0dXJuIHQgaW5zdGFuY2VvZiBTaGFkb3dSb290P3Q6dC5wYXJlbnROb2RlP20uZmluZFNoYWRvd1Jvb3QodC5wYXJlbnROb2RlKTpudWxsO3ZhciBlPXQuZ2V0Um9vdE5vZGUoKTtyZXR1cm4gZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q/ZTpudWxsfX07cC5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZD1uLHAuZXZlbnQuc3BlY2lhbFttLlRSQU5TSVRJT05fRU5EXT17YmluZFR5cGU6ZSxkZWxlZ2F0ZVR5cGU6ZSxoYW5kbGU6ZnVuY3Rpb24odCl7aWYocCh0LnRhcmdldCkuaXModGhpcykpcmV0dXJuIHQuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpfX07dmFyIG89XCJhbGVydFwiLHI9XCJicy5hbGVydFwiLGE9XCIuXCIrcixjPXAuZm5bb10saD17Q0xPU0U6XCJjbG9zZVwiK2EsQ0xPU0VEOlwiY2xvc2VkXCIrYSxDTElDS19EQVRBX0FQSTpcImNsaWNrXCIrYStcIi5kYXRhLWFwaVwifSx1PVwiYWxlcnRcIixmPVwiZmFkZVwiLGQ9XCJzaG93XCIsZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGkodCl7dGhpcy5fZWxlbWVudD10fXZhciB0PWkucHJvdG90eXBlO3JldHVybiB0LmNsb3NlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2VsZW1lbnQ7dCYmKGU9dGhpcy5fZ2V0Um9vdEVsZW1lbnQodCkpLHRoaXMuX3RyaWdnZXJDbG9zZUV2ZW50KGUpLmlzRGVmYXVsdFByZXZlbnRlZCgpfHx0aGlzLl9yZW1vdmVFbGVtZW50KGUpfSx0LmRpc3Bvc2U9ZnVuY3Rpb24oKXtwLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCxyKSx0aGlzLl9lbGVtZW50PW51bGx9LHQuX2dldFJvb3RFbGVtZW50PWZ1bmN0aW9uKHQpe3ZhciBlPW0uZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0KSxuPSExO3JldHVybiBlJiYobj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGUpKSxufHwobj1wKHQpLmNsb3Nlc3QoXCIuXCIrdSlbMF0pLG59LHQuX3RyaWdnZXJDbG9zZUV2ZW50PWZ1bmN0aW9uKHQpe3ZhciBlPXAuRXZlbnQoaC5DTE9TRSk7cmV0dXJuIHAodCkudHJpZ2dlcihlKSxlfSx0Ll9yZW1vdmVFbGVtZW50PWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7aWYocChlKS5yZW1vdmVDbGFzcyhkKSxwKGUpLmhhc0NsYXNzKGYpKXt2YXIgdD1tLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGUpO3AoZSkub25lKG0uVFJBTlNJVElPTl9FTkQsZnVuY3Rpb24odCl7cmV0dXJuIG4uX2Rlc3Ryb3lFbGVtZW50KGUsdCl9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0KX1lbHNlIHRoaXMuX2Rlc3Ryb3lFbGVtZW50KGUpfSx0Ll9kZXN0cm95RWxlbWVudD1mdW5jdGlvbih0KXtwKHQpLmRldGFjaCgpLnRyaWdnZXIoaC5DTE9TRUQpLnJlbW92ZSgpfSxpLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PXAodGhpcyksZT10LmRhdGEocik7ZXx8KGU9bmV3IGkodGhpcyksdC5kYXRhKHIsZSkpLFwiY2xvc2VcIj09PW4mJmVbbl0odGhpcyl9KX0saS5faGFuZGxlRGlzbWlzcz1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7dCYmdC5wcmV2ZW50RGVmYXVsdCgpLGUuY2xvc2UodGhpcyl9fSxzKGksbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMi4xXCJ9fV0pLGl9KCk7cChkb2N1bWVudCkub24oaC5DTElDS19EQVRBX0FQSSwnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJyxnLl9oYW5kbGVEaXNtaXNzKG5ldyBnKSkscC5mbltvXT1nLl9qUXVlcnlJbnRlcmZhY2UscC5mbltvXS5Db25zdHJ1Y3Rvcj1nLHAuZm5bb10ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBwLmZuW29dPWMsZy5falF1ZXJ5SW50ZXJmYWNlfTt2YXIgXz1cImJ1dHRvblwiLHY9XCJicy5idXR0b25cIix5PVwiLlwiK3YsRT1cIi5kYXRhLWFwaVwiLGI9cC5mbltfXSx3PVwiYWN0aXZlXCIsVD1cImJ0blwiLEM9XCJmb2N1c1wiLFM9J1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLEQ9J1tkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIl0nLEk9J2lucHV0Om5vdChbdHlwZT1cImhpZGRlblwiXSknLEE9XCIuYWN0aXZlXCIsTz1cIi5idG5cIixOPXtDTElDS19EQVRBX0FQSTpcImNsaWNrXCIreStFLEZPQ1VTX0JMVVJfREFUQV9BUEk6XCJmb2N1c1wiK3krRStcIiBibHVyXCIreStFfSxrPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbih0KXt0aGlzLl9lbGVtZW50PXR9dmFyIHQ9bi5wcm90b3R5cGU7cmV0dXJuIHQudG9nZ2xlPWZ1bmN0aW9uKCl7dmFyIHQ9ITAsZT0hMCxuPXAodGhpcy5fZWxlbWVudCkuY2xvc2VzdChEKVswXTtpZihuKXt2YXIgaT10aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoSSk7aWYoaSl7aWYoXCJyYWRpb1wiPT09aS50eXBlKWlmKGkuY2hlY2tlZCYmdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModykpdD0hMTtlbHNle3ZhciBvPW4ucXVlcnlTZWxlY3RvcihBKTtvJiZwKG8pLnJlbW92ZUNsYXNzKHcpfWlmKHQpe2lmKGkuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIil8fG4uaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIil8fGkuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIil8fG4uY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIikpcmV0dXJuO2kuY2hlY2tlZD0hdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModykscChpKS50cmlnZ2VyKFwiY2hhbmdlXCIpfWkuZm9jdXMoKSxlPSExfX1lJiZ0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCF0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh3KSksdCYmcCh0aGlzLl9lbGVtZW50KS50b2dnbGVDbGFzcyh3KX0sdC5kaXNwb3NlPWZ1bmN0aW9uKCl7cC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsdiksdGhpcy5fZWxlbWVudD1udWxsfSxuLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PXAodGhpcykuZGF0YSh2KTt0fHwodD1uZXcgbih0aGlzKSxwKHRoaXMpLmRhdGEodix0KSksXCJ0b2dnbGVcIj09PWUmJnRbZV0oKX0pfSxzKG4sbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMi4xXCJ9fV0pLG59KCk7cChkb2N1bWVudCkub24oTi5DTElDS19EQVRBX0FQSSxTLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKTt2YXIgZT10LnRhcmdldDtwKGUpLmhhc0NsYXNzKFQpfHwoZT1wKGUpLmNsb3Nlc3QoTykpLGsuX2pRdWVyeUludGVyZmFjZS5jYWxsKHAoZSksXCJ0b2dnbGVcIil9KS5vbihOLkZPQ1VTX0JMVVJfREFUQV9BUEksUyxmdW5jdGlvbih0KXt2YXIgZT1wKHQudGFyZ2V0KS5jbG9zZXN0KE8pWzBdO3AoZSkudG9nZ2xlQ2xhc3MoQywvXmZvY3VzKGluKT8kLy50ZXN0KHQudHlwZSkpfSkscC5mbltfXT1rLl9qUXVlcnlJbnRlcmZhY2UscC5mbltfXS5Db25zdHJ1Y3Rvcj1rLHAuZm5bX10ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBwLmZuW19dPWIsay5falF1ZXJ5SW50ZXJmYWNlfTt2YXIgTD1cImNhcm91c2VsXCIsUD1cImJzLmNhcm91c2VsXCIseD1cIi5cIitQLEg9XCIuZGF0YS1hcGlcIixqPXAuZm5bTF0sUj17aW50ZXJ2YWw6NWUzLGtleWJvYXJkOiEwLHNsaWRlOiExLHBhdXNlOlwiaG92ZXJcIix3cmFwOiEwLHRvdWNoOiEwfSxGPXtpbnRlcnZhbDpcIihudW1iZXJ8Ym9vbGVhbilcIixrZXlib2FyZDpcImJvb2xlYW5cIixzbGlkZTpcIihib29sZWFufHN0cmluZylcIixwYXVzZTpcIihzdHJpbmd8Ym9vbGVhbilcIix3cmFwOlwiYm9vbGVhblwiLHRvdWNoOlwiYm9vbGVhblwifSxNPVwibmV4dFwiLFc9XCJwcmV2XCIsVT1cImxlZnRcIixCPVwicmlnaHRcIixxPXtTTElERTpcInNsaWRlXCIreCxTTElEOlwic2xpZFwiK3gsS0VZRE9XTjpcImtleWRvd25cIit4LE1PVVNFRU5URVI6XCJtb3VzZWVudGVyXCIreCxNT1VTRUxFQVZFOlwibW91c2VsZWF2ZVwiK3gsVE9VQ0hTVEFSVDpcInRvdWNoc3RhcnRcIit4LFRPVUNITU9WRTpcInRvdWNobW92ZVwiK3gsVE9VQ0hFTkQ6XCJ0b3VjaGVuZFwiK3gsUE9JTlRFUkRPV046XCJwb2ludGVyZG93blwiK3gsUE9JTlRFUlVQOlwicG9pbnRlcnVwXCIreCxEUkFHX1NUQVJUOlwiZHJhZ3N0YXJ0XCIreCxMT0FEX0RBVEFfQVBJOlwibG9hZFwiK3grSCxDTElDS19EQVRBX0FQSTpcImNsaWNrXCIreCtIfSxLPVwiY2Fyb3VzZWxcIixRPVwiYWN0aXZlXCIsWT1cInNsaWRlXCIsVj1cImNhcm91c2VsLWl0ZW0tcmlnaHRcIixYPVwiY2Fyb3VzZWwtaXRlbS1sZWZ0XCIsej1cImNhcm91c2VsLWl0ZW0tbmV4dFwiLEc9XCJjYXJvdXNlbC1pdGVtLXByZXZcIixKPVwicG9pbnRlci1ldmVudFwiLFo9XCIuYWN0aXZlXCIsJD1cIi5hY3RpdmUuY2Fyb3VzZWwtaXRlbVwiLHR0PVwiLmNhcm91c2VsLWl0ZW1cIixldD1cIi5jYXJvdXNlbC1pdGVtIGltZ1wiLG50PVwiLmNhcm91c2VsLWl0ZW0tbmV4dCwgLmNhcm91c2VsLWl0ZW0tcHJldlwiLGl0PVwiLmNhcm91c2VsLWluZGljYXRvcnNcIixvdD1cIltkYXRhLXNsaWRlXSwgW2RhdGEtc2xpZGUtdG9dXCIscnQ9J1tkYXRhLXJpZGU9XCJjYXJvdXNlbFwiXScsc3Q9e1RPVUNIOlwidG91Y2hcIixQRU46XCJwZW5cIn0sYXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKHQsZSl7dGhpcy5faXRlbXM9bnVsbCx0aGlzLl9pbnRlcnZhbD1udWxsLHRoaXMuX2FjdGl2ZUVsZW1lbnQ9bnVsbCx0aGlzLl9pc1BhdXNlZD0hMSx0aGlzLl9pc1NsaWRpbmc9ITEsdGhpcy50b3VjaFRpbWVvdXQ9bnVsbCx0aGlzLnRvdWNoU3RhcnRYPTAsdGhpcy50b3VjaERlbHRhWD0wLHRoaXMuX2NvbmZpZz10aGlzLl9nZXRDb25maWcoZSksdGhpcy5fZWxlbWVudD10LHRoaXMuX2luZGljYXRvcnNFbGVtZW50PXRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihpdCksdGhpcy5fdG91Y2hTdXBwb3J0ZWQ9XCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudHx8MDxuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMsdGhpcy5fcG9pbnRlckV2ZW50PUJvb2xlYW4od2luZG93LlBvaW50ZXJFdmVudHx8d2luZG93Lk1TUG9pbnRlckV2ZW50KSx0aGlzLl9hZGRFdmVudExpc3RlbmVycygpfXZhciB0PXIucHJvdG90eXBlO3JldHVybiB0Lm5leHQ9ZnVuY3Rpb24oKXt0aGlzLl9pc1NsaWRpbmd8fHRoaXMuX3NsaWRlKE0pfSx0Lm5leHRXaGVuVmlzaWJsZT1mdW5jdGlvbigpeyFkb2N1bWVudC5oaWRkZW4mJnAodGhpcy5fZWxlbWVudCkuaXMoXCI6dmlzaWJsZVwiKSYmXCJoaWRkZW5cIiE9PXAodGhpcy5fZWxlbWVudCkuY3NzKFwidmlzaWJpbGl0eVwiKSYmdGhpcy5uZXh0KCl9LHQucHJldj1mdW5jdGlvbigpe3RoaXMuX2lzU2xpZGluZ3x8dGhpcy5fc2xpZGUoVyl9LHQucGF1c2U9ZnVuY3Rpb24odCl7dHx8KHRoaXMuX2lzUGF1c2VkPSEwKSx0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IobnQpJiYobS50cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KSx0aGlzLmN5Y2xlKCEwKSksY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksdGhpcy5faW50ZXJ2YWw9bnVsbH0sdC5jeWNsZT1mdW5jdGlvbih0KXt0fHwodGhpcy5faXNQYXVzZWQ9ITEpLHRoaXMuX2ludGVydmFsJiYoY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksdGhpcy5faW50ZXJ2YWw9bnVsbCksdGhpcy5fY29uZmlnLmludGVydmFsJiYhdGhpcy5faXNQYXVzZWQmJih0aGlzLl9pbnRlcnZhbD1zZXRJbnRlcnZhbCgoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlP3RoaXMubmV4dFdoZW5WaXNpYmxlOnRoaXMubmV4dCkuYmluZCh0aGlzKSx0aGlzLl9jb25maWcuaW50ZXJ2YWwpKX0sdC50bz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMuX2FjdGl2ZUVsZW1lbnQ9dGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKCQpO3ZhciBuPXRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtpZighKHQ+dGhpcy5faXRlbXMubGVuZ3RoLTF8fHQ8MCkpaWYodGhpcy5faXNTbGlkaW5nKXAodGhpcy5fZWxlbWVudCkub25lKHEuU0xJRCxmdW5jdGlvbigpe3JldHVybiBlLnRvKHQpfSk7ZWxzZXtpZihuPT09dClyZXR1cm4gdGhpcy5wYXVzZSgpLHZvaWQgdGhpcy5jeWNsZSgpO3ZhciBpPW48dD9NOlc7dGhpcy5fc2xpZGUoaSx0aGlzLl9pdGVtc1t0XSl9fSx0LmRpc3Bvc2U9ZnVuY3Rpb24oKXtwKHRoaXMuX2VsZW1lbnQpLm9mZih4KSxwLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCxQKSx0aGlzLl9pdGVtcz1udWxsLHRoaXMuX2NvbmZpZz1udWxsLHRoaXMuX2VsZW1lbnQ9bnVsbCx0aGlzLl9pbnRlcnZhbD1udWxsLHRoaXMuX2lzUGF1c2VkPW51bGwsdGhpcy5faXNTbGlkaW5nPW51bGwsdGhpcy5fYWN0aXZlRWxlbWVudD1udWxsLHRoaXMuX2luZGljYXRvcnNFbGVtZW50PW51bGx9LHQuX2dldENvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4gdD1sKHt9LFIsdCksbS50eXBlQ2hlY2tDb25maWcoTCx0LEYpLHR9LHQuX2hhbmRsZVN3aXBlPWZ1bmN0aW9uKCl7dmFyIHQ9TWF0aC5hYnModGhpcy50b3VjaERlbHRhWCk7aWYoISh0PD00MCkpe3ZhciBlPXQvdGhpcy50b3VjaERlbHRhWDswPGUmJnRoaXMucHJldigpLGU8MCYmdGhpcy5uZXh0KCl9fSx0Ll9hZGRFdmVudExpc3RlbmVycz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5fY29uZmlnLmtleWJvYXJkJiZwKHRoaXMuX2VsZW1lbnQpLm9uKHEuS0VZRE9XTixmdW5jdGlvbih0KXtyZXR1cm4gZS5fa2V5ZG93bih0KX0pLFwiaG92ZXJcIj09PXRoaXMuX2NvbmZpZy5wYXVzZSYmcCh0aGlzLl9lbGVtZW50KS5vbihxLk1PVVNFRU5URVIsZnVuY3Rpb24odCl7cmV0dXJuIGUucGF1c2UodCl9KS5vbihxLk1PVVNFTEVBVkUsZnVuY3Rpb24odCl7cmV0dXJuIGUuY3ljbGUodCl9KSx0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCl9LHQuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgbj10aGlzO2lmKHRoaXMuX3RvdWNoU3VwcG9ydGVkKXt2YXIgZT1mdW5jdGlvbih0KXtuLl9wb2ludGVyRXZlbnQmJnN0W3Qub3JpZ2luYWxFdmVudC5wb2ludGVyVHlwZS50b1VwcGVyQ2FzZSgpXT9uLnRvdWNoU3RhcnRYPXQub3JpZ2luYWxFdmVudC5jbGllbnRYOm4uX3BvaW50ZXJFdmVudHx8KG4udG91Y2hTdGFydFg9dC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCl9LGk9ZnVuY3Rpb24odCl7bi5fcG9pbnRlckV2ZW50JiZzdFt0Lm9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUudG9VcHBlckNhc2UoKV0mJihuLnRvdWNoRGVsdGFYPXQub3JpZ2luYWxFdmVudC5jbGllbnRYLW4udG91Y2hTdGFydFgpLG4uX2hhbmRsZVN3aXBlKCksXCJob3ZlclwiPT09bi5fY29uZmlnLnBhdXNlJiYobi5wYXVzZSgpLG4udG91Y2hUaW1lb3V0JiZjbGVhclRpbWVvdXQobi50b3VjaFRpbWVvdXQpLG4udG91Y2hUaW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24odCl7cmV0dXJuIG4uY3ljbGUodCl9LDUwMCtuLl9jb25maWcuaW50ZXJ2YWwpKX07cCh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZXQpKS5vbihxLkRSQUdfU1RBUlQsZnVuY3Rpb24odCl7cmV0dXJuIHQucHJldmVudERlZmF1bHQoKX0pLHRoaXMuX3BvaW50ZXJFdmVudD8ocCh0aGlzLl9lbGVtZW50KS5vbihxLlBPSU5URVJET1dOLGZ1bmN0aW9uKHQpe3JldHVybiBlKHQpfSkscCh0aGlzLl9lbGVtZW50KS5vbihxLlBPSU5URVJVUCxmdW5jdGlvbih0KXtyZXR1cm4gaSh0KX0pLHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChKKSk6KHAodGhpcy5fZWxlbWVudCkub24ocS5UT1VDSFNUQVJULGZ1bmN0aW9uKHQpe3JldHVybiBlKHQpfSkscCh0aGlzLl9lbGVtZW50KS5vbihxLlRPVUNITU9WRSxmdW5jdGlvbih0KXt2YXIgZTsoZT10KS5vcmlnaW5hbEV2ZW50LnRvdWNoZXMmJjE8ZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXMubGVuZ3RoP24udG91Y2hEZWx0YVg9MDpuLnRvdWNoRGVsdGFYPWUub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdLmNsaWVudFgtbi50b3VjaFN0YXJ0WH0pLHAodGhpcy5fZWxlbWVudCkub24ocS5UT1VDSEVORCxmdW5jdGlvbih0KXtyZXR1cm4gaSh0KX0pKX19LHQuX2tleWRvd249ZnVuY3Rpb24odCl7aWYoIS9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkpc3dpdGNoKHQud2hpY2gpe2Nhc2UgMzc6dC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMucHJldigpO2JyZWFrO2Nhc2UgMzk6dC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMubmV4dCgpfX0sdC5fZ2V0SXRlbUluZGV4PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9pdGVtcz10JiZ0LnBhcmVudE5vZGU/W10uc2xpY2UuY2FsbCh0LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbCh0dCkpOltdLHRoaXMuX2l0ZW1zLmluZGV4T2YodCl9LHQuX2dldEl0ZW1CeURpcmVjdGlvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXQ9PT1NLGk9dD09PVcsbz10aGlzLl9nZXRJdGVtSW5kZXgoZSkscj10aGlzLl9pdGVtcy5sZW5ndGgtMTtpZigoaSYmMD09PW98fG4mJm89PT1yKSYmIXRoaXMuX2NvbmZpZy53cmFwKXJldHVybiBlO3ZhciBzPShvKyh0PT09Vz8tMToxKSkldGhpcy5faXRlbXMubGVuZ3RoO3JldHVybi0xPT09cz90aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGgtMV06dGhpcy5faXRlbXNbc119LHQuX3RyaWdnZXJTbGlkZUV2ZW50PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fZ2V0SXRlbUluZGV4KHQpLGk9dGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcigkKSksbz1wLkV2ZW50KHEuU0xJREUse3JlbGF0ZWRUYXJnZXQ6dCxkaXJlY3Rpb246ZSxmcm9tOmksdG86bn0pO3JldHVybiBwKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIobyksb30sdC5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudD1mdW5jdGlvbih0KXtpZih0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCl7dmFyIGU9W10uc2xpY2UuY2FsbCh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFopKTtwKGUpLnJlbW92ZUNsYXNzKFEpO3ZhciBuPXRoaXMuX2luZGljYXRvcnNFbGVtZW50LmNoaWxkcmVuW3RoaXMuX2dldEl0ZW1JbmRleCh0KV07biYmcChuKS5hZGRDbGFzcyhRKX19LHQuX3NsaWRlPWZ1bmN0aW9uKHQsZSl7dmFyIG4saSxvLHI9dGhpcyxzPXRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcigkKSxhPXRoaXMuX2dldEl0ZW1JbmRleChzKSxsPWV8fHMmJnRoaXMuX2dldEl0ZW1CeURpcmVjdGlvbih0LHMpLGM9dGhpcy5fZ2V0SXRlbUluZGV4KGwpLGg9Qm9vbGVhbih0aGlzLl9pbnRlcnZhbCk7aWYobz10PT09TT8obj1YLGk9eixVKToobj1WLGk9RyxCKSxsJiZwKGwpLmhhc0NsYXNzKFEpKXRoaXMuX2lzU2xpZGluZz0hMTtlbHNlIGlmKCF0aGlzLl90cmlnZ2VyU2xpZGVFdmVudChsLG8pLmlzRGVmYXVsdFByZXZlbnRlZCgpJiZzJiZsKXt0aGlzLl9pc1NsaWRpbmc9ITAsaCYmdGhpcy5wYXVzZSgpLHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQobCk7dmFyIHU9cC5FdmVudChxLlNMSUQse3JlbGF0ZWRUYXJnZXQ6bCxkaXJlY3Rpb246byxmcm9tOmEsdG86Y30pO2lmKHAodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoWSkpe3AobCkuYWRkQ2xhc3MoaSksbS5yZWZsb3cobCkscChzKS5hZGRDbGFzcyhuKSxwKGwpLmFkZENsYXNzKG4pO3ZhciBmPXBhcnNlSW50KGwuZ2V0QXR0cmlidXRlKFwiZGF0YS1pbnRlcnZhbFwiKSwxMCk7dGhpcy5fY29uZmlnLmludGVydmFsPWY/KHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWw9dGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbHx8dGhpcy5fY29uZmlnLmludGVydmFsLGYpOnRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWx8fHRoaXMuX2NvbmZpZy5pbnRlcnZhbDt2YXIgZD1tLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHMpO3Aocykub25lKG0uVFJBTlNJVElPTl9FTkQsZnVuY3Rpb24oKXtwKGwpLnJlbW92ZUNsYXNzKG4rXCIgXCIraSkuYWRkQ2xhc3MoUSkscChzKS5yZW1vdmVDbGFzcyhRK1wiIFwiK2krXCIgXCIrbiksci5faXNTbGlkaW5nPSExLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gcChyLl9lbGVtZW50KS50cmlnZ2VyKHUpfSwwKX0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGQpfWVsc2UgcChzKS5yZW1vdmVDbGFzcyhRKSxwKGwpLmFkZENsYXNzKFEpLHRoaXMuX2lzU2xpZGluZz0hMSxwKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIodSk7aCYmdGhpcy5jeWNsZSgpfX0sci5falF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD1wKHRoaXMpLmRhdGEoUCksZT1sKHt9LFIscCh0aGlzKS5kYXRhKCkpO1wib2JqZWN0XCI9PXR5cGVvZiBpJiYoZT1sKHt9LGUsaSkpO3ZhciBuPVwic3RyaW5nXCI9PXR5cGVvZiBpP2k6ZS5zbGlkZTtpZih0fHwodD1uZXcgcih0aGlzLGUpLHAodGhpcykuZGF0YShQLHQpKSxcIm51bWJlclwiPT10eXBlb2YgaSl0LnRvKGkpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIG4pe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB0W25dKXRocm93IG5ldyBUeXBlRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicrbisnXCInKTt0W25dKCl9ZWxzZSBlLmludGVydmFsJiYodC5wYXVzZSgpLHQuY3ljbGUoKSl9KX0sci5fZGF0YUFwaUNsaWNrSGFuZGxlcj1mdW5jdGlvbih0KXt2YXIgZT1tLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7aWYoZSl7dmFyIG49cChlKVswXTtpZihuJiZwKG4pLmhhc0NsYXNzKEspKXt2YXIgaT1sKHt9LHAobikuZGF0YSgpLHAodGhpcykuZGF0YSgpKSxvPXRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1zbGlkZS10b1wiKTtvJiYoaS5pbnRlcnZhbD0hMSksci5falF1ZXJ5SW50ZXJmYWNlLmNhbGwocChuKSxpKSxvJiZwKG4pLmRhdGEoUCkudG8obyksdC5wcmV2ZW50RGVmYXVsdCgpfX19LHMocixudWxsLFt7a2V5OlwiVkVSU0lPTlwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiNC4yLjFcIn19LHtrZXk6XCJEZWZhdWx0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFJ9fV0pLHJ9KCk7cChkb2N1bWVudCkub24ocS5DTElDS19EQVRBX0FQSSxvdCxhdC5fZGF0YUFwaUNsaWNrSGFuZGxlcikscCh3aW5kb3cpLm9uKHEuTE9BRF9EQVRBX0FQSSxmdW5jdGlvbigpe2Zvcih2YXIgdD1bXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocnQpKSxlPTAsbj10Lmxlbmd0aDtlPG47ZSsrKXt2YXIgaT1wKHRbZV0pO2F0Ll9qUXVlcnlJbnRlcmZhY2UuY2FsbChpLGkuZGF0YSgpKX19KSxwLmZuW0xdPWF0Ll9qUXVlcnlJbnRlcmZhY2UscC5mbltMXS5Db25zdHJ1Y3Rvcj1hdCxwLmZuW0xdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gcC5mbltMXT1qLGF0Ll9qUXVlcnlJbnRlcmZhY2V9O3ZhciBsdD1cImNvbGxhcHNlXCIsY3Q9XCJicy5jb2xsYXBzZVwiLGh0PVwiLlwiK2N0LHV0PXAuZm5bbHRdLGZ0PXt0b2dnbGU6ITAscGFyZW50OlwiXCJ9LGR0PXt0b2dnbGU6XCJib29sZWFuXCIscGFyZW50OlwiKHN0cmluZ3xlbGVtZW50KVwifSxwdD17U0hPVzpcInNob3dcIitodCxTSE9XTjpcInNob3duXCIraHQsSElERTpcImhpZGVcIitodCxISURERU46XCJoaWRkZW5cIitodCxDTElDS19EQVRBX0FQSTpcImNsaWNrXCIraHQrXCIuZGF0YS1hcGlcIn0sbXQ9XCJzaG93XCIsZ3Q9XCJjb2xsYXBzZVwiLF90PVwiY29sbGFwc2luZ1wiLHZ0PVwiY29sbGFwc2VkXCIseXQ9XCJ3aWR0aFwiLEV0PVwiaGVpZ2h0XCIsYnQ9XCIuc2hvdywgLmNvbGxhcHNpbmdcIix3dD0nW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nLFR0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShlLHQpe3RoaXMuX2lzVHJhbnNpdGlvbmluZz0hMSx0aGlzLl9lbGVtZW50PWUsdGhpcy5fY29uZmlnPXRoaXMuX2dldENvbmZpZyh0KSx0aGlzLl90cmlnZ2VyQXJyYXk9W10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtocmVmPVwiIycrZS5pZCsnXCJdLFtkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2RhdGEtdGFyZ2V0PVwiIycrZS5pZCsnXCJdJykpO2Zvcih2YXIgbj1bXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwod3QpKSxpPTAsbz1uLmxlbmd0aDtpPG87aSsrKXt2YXIgcj1uW2ldLHM9bS5nZXRTZWxlY3RvckZyb21FbGVtZW50KHIpLGE9W10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHMpKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1lfSk7bnVsbCE9PXMmJjA8YS5sZW5ndGgmJih0aGlzLl9zZWxlY3Rvcj1zLHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKHIpKX10aGlzLl9wYXJlbnQ9dGhpcy5fY29uZmlnLnBhcmVudD90aGlzLl9nZXRQYXJlbnQoKTpudWxsLHRoaXMuX2NvbmZpZy5wYXJlbnR8fHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl9lbGVtZW50LHRoaXMuX3RyaWdnZXJBcnJheSksdGhpcy5fY29uZmlnLnRvZ2dsZSYmdGhpcy50b2dnbGUoKX12YXIgdD1hLnByb3RvdHlwZTtyZXR1cm4gdC50b2dnbGU9ZnVuY3Rpb24oKXtwKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKG10KT90aGlzLmhpZGUoKTp0aGlzLnNob3coKX0sdC5zaG93PWZ1bmN0aW9uKCl7dmFyIHQsZSxuPXRoaXM7aWYoIXRoaXMuX2lzVHJhbnNpdGlvbmluZyYmIXAodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MobXQpJiYodGhpcy5fcGFyZW50JiYwPT09KHQ9W10uc2xpY2UuY2FsbCh0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChidCkpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2Ygbi5fY29uZmlnLnBhcmVudD90LmdldEF0dHJpYnV0ZShcImRhdGEtcGFyZW50XCIpPT09bi5fY29uZmlnLnBhcmVudDp0LmNsYXNzTGlzdC5jb250YWlucyhndCl9KSkubGVuZ3RoJiYodD1udWxsKSwhKHQmJihlPXAodCkubm90KHRoaXMuX3NlbGVjdG9yKS5kYXRhKGN0KSkmJmUuX2lzVHJhbnNpdGlvbmluZykpKXt2YXIgaT1wLkV2ZW50KHB0LlNIT1cpO2lmKHAodGhpcy5fZWxlbWVudCkudHJpZ2dlcihpKSwhaS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSl7dCYmKGEuX2pRdWVyeUludGVyZmFjZS5jYWxsKHAodCkubm90KHRoaXMuX3NlbGVjdG9yKSxcImhpZGVcIiksZXx8cCh0KS5kYXRhKGN0LG51bGwpKTt2YXIgbz10aGlzLl9nZXREaW1lbnNpb24oKTtwKHRoaXMuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKGd0KS5hZGRDbGFzcyhfdCksdGhpcy5fZWxlbWVudC5zdHlsZVtvXT0wLHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGgmJnAodGhpcy5fdHJpZ2dlckFycmF5KS5yZW1vdmVDbGFzcyh2dCkuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMCksdGhpcy5zZXRUcmFuc2l0aW9uaW5nKCEwKTt2YXIgcj1cInNjcm9sbFwiKyhvWzBdLnRvVXBwZXJDYXNlKCkrby5zbGljZSgxKSkscz1tLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO3AodGhpcy5fZWxlbWVudCkub25lKG0uVFJBTlNJVElPTl9FTkQsZnVuY3Rpb24oKXtwKG4uX2VsZW1lbnQpLnJlbW92ZUNsYXNzKF90KS5hZGRDbGFzcyhndCkuYWRkQ2xhc3MobXQpLG4uX2VsZW1lbnQuc3R5bGVbb109XCJcIixuLnNldFRyYW5zaXRpb25pbmcoITEpLHAobi5fZWxlbWVudCkudHJpZ2dlcihwdC5TSE9XTil9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChzKSx0aGlzLl9lbGVtZW50LnN0eWxlW29dPXRoaXMuX2VsZW1lbnRbcl0rXCJweFwifX19LHQuaGlkZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoIXRoaXMuX2lzVHJhbnNpdGlvbmluZyYmcCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhtdCkpe3ZhciBlPXAuRXZlbnQocHQuSElERSk7aWYocCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKGUpLCFlLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt2YXIgbj10aGlzLl9nZXREaW1lbnNpb24oKTt0aGlzLl9lbGVtZW50LnN0eWxlW25dPXRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbbl0rXCJweFwiLG0ucmVmbG93KHRoaXMuX2VsZW1lbnQpLHAodGhpcy5fZWxlbWVudCkuYWRkQ2xhc3MoX3QpLnJlbW92ZUNsYXNzKGd0KS5yZW1vdmVDbGFzcyhtdCk7dmFyIGk9dGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aDtpZigwPGkpZm9yKHZhciBvPTA7bzxpO28rKyl7dmFyIHI9dGhpcy5fdHJpZ2dlckFycmF5W29dLHM9bS5nZXRTZWxlY3RvckZyb21FbGVtZW50KHIpO2lmKG51bGwhPT1zKXAoW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHMpKSkuaGFzQ2xhc3MobXQpfHxwKHIpLmFkZENsYXNzKHZ0KS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCExKX10aGlzLnNldFRyYW5zaXRpb25pbmcoITApO3RoaXMuX2VsZW1lbnQuc3R5bGVbbl09XCJcIjt2YXIgYT1tLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO3AodGhpcy5fZWxlbWVudCkub25lKG0uVFJBTlNJVElPTl9FTkQsZnVuY3Rpb24oKXt0LnNldFRyYW5zaXRpb25pbmcoITEpLHAodC5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoX3QpLmFkZENsYXNzKGd0KS50cmlnZ2VyKHB0LkhJRERFTil9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChhKX19fSx0LnNldFRyYW5zaXRpb25pbmc9ZnVuY3Rpb24odCl7dGhpcy5faXNUcmFuc2l0aW9uaW5nPXR9LHQuZGlzcG9zZT1mdW5jdGlvbigpe3AucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LGN0KSx0aGlzLl9jb25maWc9bnVsbCx0aGlzLl9wYXJlbnQ9bnVsbCx0aGlzLl9lbGVtZW50PW51bGwsdGhpcy5fdHJpZ2dlckFycmF5PW51bGwsdGhpcy5faXNUcmFuc2l0aW9uaW5nPW51bGx9LHQuX2dldENvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4odD1sKHt9LGZ0LHQpKS50b2dnbGU9Qm9vbGVhbih0LnRvZ2dsZSksbS50eXBlQ2hlY2tDb25maWcobHQsdCxkdCksdH0sdC5fZ2V0RGltZW5zaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHAodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoeXQpP3l0OkV0fSx0Ll9nZXRQYXJlbnQ9ZnVuY3Rpb24oKXt2YXIgdCxuPXRoaXM7bS5pc0VsZW1lbnQodGhpcy5fY29uZmlnLnBhcmVudCk/KHQ9dGhpcy5fY29uZmlnLnBhcmVudCxcInVuZGVmaW5lZFwiIT10eXBlb2YgdGhpcy5fY29uZmlnLnBhcmVudC5qcXVlcnkmJih0PXRoaXMuX2NvbmZpZy5wYXJlbnRbMF0pKTp0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fY29uZmlnLnBhcmVudCk7dmFyIGU9J1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2RhdGEtcGFyZW50PVwiJyt0aGlzLl9jb25maWcucGFyZW50KydcIl0nLGk9W10uc2xpY2UuY2FsbCh0LnF1ZXJ5U2VsZWN0b3JBbGwoZSkpO3JldHVybiBwKGkpLmVhY2goZnVuY3Rpb24odCxlKXtuLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoYS5fZ2V0VGFyZ2V0RnJvbUVsZW1lbnQoZSksW2VdKX0pLHR9LHQuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcz1mdW5jdGlvbih0LGUpe3ZhciBuPXAodCkuaGFzQ2xhc3MobXQpO2UubGVuZ3RoJiZwKGUpLnRvZ2dsZUNsYXNzKHZ0LCFuKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLG4pfSxhLl9nZXRUYXJnZXRGcm9tRWxlbWVudD1mdW5jdGlvbih0KXt2YXIgZT1tLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodCk7cmV0dXJuIGU/ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKTpudWxsfSxhLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PXAodGhpcyksZT10LmRhdGEoY3QpLG49bCh7fSxmdCx0LmRhdGEoKSxcIm9iamVjdFwiPT10eXBlb2YgaSYmaT9pOnt9KTtpZighZSYmbi50b2dnbGUmJi9zaG93fGhpZGUvLnRlc3QoaSkmJihuLnRvZ2dsZT0hMSksZXx8KGU9bmV3IGEodGhpcyxuKSx0LmRhdGEoY3QsZSkpLFwic3RyaW5nXCI9PXR5cGVvZiBpKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZVtpXSl0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK2krJ1wiJyk7ZVtpXSgpfX0pfSxzKGEsbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMi4xXCJ9fSx7a2V5OlwiRGVmYXVsdFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBmdH19XSksYX0oKTtwKGRvY3VtZW50KS5vbihwdC5DTElDS19EQVRBX0FQSSx3dCxmdW5jdGlvbih0KXtcIkFcIj09PXQuY3VycmVudFRhcmdldC50YWdOYW1lJiZ0LnByZXZlbnREZWZhdWx0KCk7dmFyIG49cCh0aGlzKSxlPW0uZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKSxpPVtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKSk7cChpKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9cCh0aGlzKSxlPXQuZGF0YShjdCk/XCJ0b2dnbGVcIjpuLmRhdGEoKTtUdC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwodCxlKX0pfSkscC5mbltsdF09VHQuX2pRdWVyeUludGVyZmFjZSxwLmZuW2x0XS5Db25zdHJ1Y3Rvcj1UdCxwLmZuW2x0XS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHAuZm5bbHRdPXV0LFR0Ll9qUXVlcnlJbnRlcmZhY2V9O2Zvcih2YXIgQ3Q9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50LFN0PVtcIkVkZ2VcIixcIlRyaWRlbnRcIixcIkZpcmVmb3hcIl0sRHQ9MCxJdD0wO0l0PFN0Lmxlbmd0aDtJdCs9MSlpZihDdCYmMDw9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFN0W0l0XSkpe0R0PTE7YnJlYWt9dmFyIEF0PUN0JiZ3aW5kb3cuUHJvbWlzZT9mdW5jdGlvbih0KXt2YXIgZT0hMTtyZXR1cm4gZnVuY3Rpb24oKXtlfHwoZT0hMCx3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe2U9ITEsdCgpfSkpfX06ZnVuY3Rpb24odCl7dmFyIGU9ITE7cmV0dXJuIGZ1bmN0aW9uKCl7ZXx8KGU9ITAsc2V0VGltZW91dChmdW5jdGlvbigpe2U9ITEsdCgpfSxEdCkpfX07ZnVuY3Rpb24gT3QodCl7cmV0dXJuIHQmJlwiW29iamVjdCBGdW5jdGlvbl1cIj09PXt9LnRvU3RyaW5nLmNhbGwodCl9ZnVuY3Rpb24gTnQodCxlKXtpZigxIT09dC5ub2RlVHlwZSlyZXR1cm5bXTt2YXIgbj10Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0LG51bGwpO3JldHVybiBlP25bZV06bn1mdW5jdGlvbiBrdCh0KXtyZXR1cm5cIkhUTUxcIj09PXQubm9kZU5hbWU/dDp0LnBhcmVudE5vZGV8fHQuaG9zdH1mdW5jdGlvbiBMdCh0KXtpZighdClyZXR1cm4gZG9jdW1lbnQuYm9keTtzd2l0Y2godC5ub2RlTmFtZSl7Y2FzZVwiSFRNTFwiOmNhc2VcIkJPRFlcIjpyZXR1cm4gdC5vd25lckRvY3VtZW50LmJvZHk7Y2FzZVwiI2RvY3VtZW50XCI6cmV0dXJuIHQuYm9keX12YXIgZT1OdCh0KSxuPWUub3ZlcmZsb3csaT1lLm92ZXJmbG93WCxvPWUub3ZlcmZsb3dZO3JldHVybi8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3QobitvK2kpP3Q6THQoa3QodCkpfXZhciBQdD1DdCYmISghd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0fHwhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSx4dD1DdCYmL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7ZnVuY3Rpb24gSHQodCl7cmV0dXJuIDExPT09dD9QdDoxMD09PXQ/eHQ6UHR8fHh0fWZ1bmN0aW9uIGp0KHQpe2lmKCF0KXJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7Zm9yKHZhciBlPUh0KDEwKT9kb2N1bWVudC5ib2R5Om51bGwsbj10Lm9mZnNldFBhcmVudHx8bnVsbDtuPT09ZSYmdC5uZXh0RWxlbWVudFNpYmxpbmc7KW49KHQ9dC5uZXh0RWxlbWVudFNpYmxpbmcpLm9mZnNldFBhcmVudDt2YXIgaT1uJiZuLm5vZGVOYW1lO3JldHVybiBpJiZcIkJPRFlcIiE9PWkmJlwiSFRNTFwiIT09aT8tMSE9PVtcIlRIXCIsXCJURFwiLFwiVEFCTEVcIl0uaW5kZXhPZihuLm5vZGVOYW1lKSYmXCJzdGF0aWNcIj09PU50KG4sXCJwb3NpdGlvblwiKT9qdChuKTpuOnQ/dC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR9ZnVuY3Rpb24gUnQodCl7cmV0dXJuIG51bGwhPT10LnBhcmVudE5vZGU/UnQodC5wYXJlbnROb2RlKTp0fWZ1bmN0aW9uIEZ0KHQsZSl7aWYoISh0JiZ0Lm5vZGVUeXBlJiZlJiZlLm5vZGVUeXBlKSlyZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O3ZhciBuPXQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZSkmTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcsaT1uP3Q6ZSxvPW4/ZTp0LHI9ZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtyLnNldFN0YXJ0KGksMCksci5zZXRFbmQobywwKTt2YXIgcyxhLGw9ci5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtpZih0IT09bCYmZSE9PWx8fGkuY29udGFpbnMobykpcmV0dXJuXCJCT0RZXCI9PT0oYT0ocz1sKS5ub2RlTmFtZSl8fFwiSFRNTFwiIT09YSYmanQocy5maXJzdEVsZW1lbnRDaGlsZCkhPT1zP2p0KGwpOmw7dmFyIGM9UnQodCk7cmV0dXJuIGMuaG9zdD9GdChjLmhvc3QsZSk6RnQodCxSdChlKS5ob3N0KX1mdW5jdGlvbiBNdCh0KXt2YXIgZT1cInRvcFwiPT09KDE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpcInRvcFwiKT9cInNjcm9sbFRvcFwiOlwic2Nyb2xsTGVmdFwiLG49dC5ub2RlTmFtZTtpZihcIkJPRFlcIiE9PW4mJlwiSFRNTFwiIT09bilyZXR1cm4gdFtlXTt2YXIgaT10Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O3JldHVybih0Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudHx8aSlbZV19ZnVuY3Rpb24gV3QodCxlKXt2YXIgbj1cInhcIj09PWU/XCJMZWZ0XCI6XCJUb3BcIixpPVwiTGVmdFwiPT09bj9cIlJpZ2h0XCI6XCJCb3R0b21cIjtyZXR1cm4gcGFyc2VGbG9hdCh0W1wiYm9yZGVyXCIrbitcIldpZHRoXCJdLDEwKStwYXJzZUZsb2F0KHRbXCJib3JkZXJcIitpK1wiV2lkdGhcIl0sMTApfWZ1bmN0aW9uIFV0KHQsZSxuLGkpe3JldHVybiBNYXRoLm1heChlW1wib2Zmc2V0XCIrdF0sZVtcInNjcm9sbFwiK3RdLG5bXCJjbGllbnRcIit0XSxuW1wib2Zmc2V0XCIrdF0sbltcInNjcm9sbFwiK3RdLEh0KDEwKT9wYXJzZUludChuW1wib2Zmc2V0XCIrdF0pK3BhcnNlSW50KGlbXCJtYXJnaW5cIisoXCJIZWlnaHRcIj09PXQ/XCJUb3BcIjpcIkxlZnRcIildKStwYXJzZUludChpW1wibWFyZ2luXCIrKFwiSGVpZ2h0XCI9PT10P1wiQm90dG9tXCI6XCJSaWdodFwiKV0pOjApfWZ1bmN0aW9uIEJ0KHQpe3ZhciBlPXQuYm9keSxuPXQuZG9jdW1lbnRFbGVtZW50LGk9SHQoMTApJiZnZXRDb21wdXRlZFN0eWxlKG4pO3JldHVybntoZWlnaHQ6VXQoXCJIZWlnaHRcIixlLG4saSksd2lkdGg6VXQoXCJXaWR0aFwiLGUsbixpKX19dmFyIHF0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gaSh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgaT1lW25dO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLmtleSxpKX19cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gZSYmaSh0LnByb3RvdHlwZSxlKSxuJiZpKHQsbiksdH19KCksS3Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fSxRdD1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgbj1hcmd1bWVudHNbZV07Zm9yKHZhciBpIGluIG4pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4saSkmJih0W2ldPW5baV0pfXJldHVybiB0fTtmdW5jdGlvbiBZdCh0KXtyZXR1cm4gUXQoe30sdCx7cmlnaHQ6dC5sZWZ0K3Qud2lkdGgsYm90dG9tOnQudG9wK3QuaGVpZ2h0fSl9ZnVuY3Rpb24gVnQodCl7dmFyIGU9e307dHJ5e2lmKEh0KDEwKSl7ZT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3ZhciBuPU10KHQsXCJ0b3BcIiksaT1NdCh0LFwibGVmdFwiKTtlLnRvcCs9bixlLmxlZnQrPWksZS5ib3R0b20rPW4sZS5yaWdodCs9aX1lbHNlIGU9dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKX1jYXRjaCh0KXt9dmFyIG89e2xlZnQ6ZS5sZWZ0LHRvcDplLnRvcCx3aWR0aDplLnJpZ2h0LWUubGVmdCxoZWlnaHQ6ZS5ib3R0b20tZS50b3B9LHI9XCJIVE1MXCI9PT10Lm5vZGVOYW1lP0J0KHQub3duZXJEb2N1bWVudCk6e30scz1yLndpZHRofHx0LmNsaWVudFdpZHRofHxvLnJpZ2h0LW8ubGVmdCxhPXIuaGVpZ2h0fHx0LmNsaWVudEhlaWdodHx8by5ib3R0b20tby50b3AsbD10Lm9mZnNldFdpZHRoLXMsYz10Lm9mZnNldEhlaWdodC1hO2lmKGx8fGMpe3ZhciBoPU50KHQpO2wtPVd0KGgsXCJ4XCIpLGMtPVd0KGgsXCJ5XCIpLG8ud2lkdGgtPWwsby5oZWlnaHQtPWN9cmV0dXJuIFl0KG8pfWZ1bmN0aW9uIFh0KHQsZSl7dmFyIG49Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxpPUh0KDEwKSxvPVwiSFRNTFwiPT09ZS5ub2RlTmFtZSxyPVZ0KHQpLHM9VnQoZSksYT1MdCh0KSxsPU50KGUpLGM9cGFyc2VGbG9hdChsLmJvcmRlclRvcFdpZHRoLDEwKSxoPXBhcnNlRmxvYXQobC5ib3JkZXJMZWZ0V2lkdGgsMTApO24mJm8mJihzLnRvcD1NYXRoLm1heChzLnRvcCwwKSxzLmxlZnQ9TWF0aC5tYXgocy5sZWZ0LDApKTt2YXIgdT1ZdCh7dG9wOnIudG9wLXMudG9wLWMsbGVmdDpyLmxlZnQtcy5sZWZ0LWgsd2lkdGg6ci53aWR0aCxoZWlnaHQ6ci5oZWlnaHR9KTtpZih1Lm1hcmdpblRvcD0wLHUubWFyZ2luTGVmdD0wLCFpJiZvKXt2YXIgZj1wYXJzZUZsb2F0KGwubWFyZ2luVG9wLDEwKSxkPXBhcnNlRmxvYXQobC5tYXJnaW5MZWZ0LDEwKTt1LnRvcC09Yy1mLHUuYm90dG9tLT1jLWYsdS5sZWZ0LT1oLWQsdS5yaWdodC09aC1kLHUubWFyZ2luVG9wPWYsdS5tYXJnaW5MZWZ0PWR9cmV0dXJuKGkmJiFuP2UuY29udGFpbnMoYSk6ZT09PWEmJlwiQk9EWVwiIT09YS5ub2RlTmFtZSkmJih1PWZ1bmN0aW9uKHQsZSl7dmFyIG49Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxpPU10KGUsXCJ0b3BcIiksbz1NdChlLFwibGVmdFwiKSxyPW4/LTE6MTtyZXR1cm4gdC50b3ArPWkqcix0LmJvdHRvbSs9aSpyLHQubGVmdCs9bypyLHQucmlnaHQrPW8qcix0fSh1LGUpKSx1fWZ1bmN0aW9uIHp0KHQpe2lmKCF0fHwhdC5wYXJlbnRFbGVtZW50fHxIdCgpKXJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7Zm9yKHZhciBlPXQucGFyZW50RWxlbWVudDtlJiZcIm5vbmVcIj09PU50KGUsXCJ0cmFuc2Zvcm1cIik7KWU9ZS5wYXJlbnRFbGVtZW50O3JldHVybiBlfHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR9ZnVuY3Rpb24gR3QodCxlLG4saSl7dmFyIG89NDxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0mJmFyZ3VtZW50c1s0XSxyPXt0b3A6MCxsZWZ0OjB9LHM9bz96dCh0KTpGdCh0LGUpO2lmKFwidmlld3BvcnRcIj09PWkpcj1mdW5jdGlvbih0KXt2YXIgZT0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLG49dC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxpPVh0KHQsbiksbz1NYXRoLm1heChuLmNsaWVudFdpZHRoLHdpbmRvdy5pbm5lcldpZHRofHwwKSxyPU1hdGgubWF4KG4uY2xpZW50SGVpZ2h0LHdpbmRvdy5pbm5lckhlaWdodHx8MCkscz1lPzA6TXQobiksYT1lPzA6TXQobixcImxlZnRcIik7cmV0dXJuIFl0KHt0b3A6cy1pLnRvcCtpLm1hcmdpblRvcCxsZWZ0OmEtaS5sZWZ0K2kubWFyZ2luTGVmdCx3aWR0aDpvLGhlaWdodDpyfSl9KHMsbyk7ZWxzZXt2YXIgYT12b2lkIDA7XCJzY3JvbGxQYXJlbnRcIj09PWk/XCJCT0RZXCI9PT0oYT1MdChrdChlKSkpLm5vZGVOYW1lJiYoYT10Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTphPVwid2luZG93XCI9PT1pP3Qub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ6aTt2YXIgbD1YdChhLHMsbyk7aWYoXCJIVE1MXCIhPT1hLm5vZGVOYW1lfHxmdW5jdGlvbiB0KGUpe3ZhciBuPWUubm9kZU5hbWU7cmV0dXJuXCJCT0RZXCIhPT1uJiZcIkhUTUxcIiE9PW4mJihcImZpeGVkXCI9PT1OdChlLFwicG9zaXRpb25cIil8fHQoa3QoZSkpKX0ocykpcj1sO2Vsc2V7dmFyIGM9QnQodC5vd25lckRvY3VtZW50KSxoPWMuaGVpZ2h0LHU9Yy53aWR0aDtyLnRvcCs9bC50b3AtbC5tYXJnaW5Ub3Asci5ib3R0b209aCtsLnRvcCxyLmxlZnQrPWwubGVmdC1sLm1hcmdpbkxlZnQsci5yaWdodD11K2wubGVmdH19dmFyIGY9XCJudW1iZXJcIj09dHlwZW9mKG49bnx8MCk7cmV0dXJuIHIubGVmdCs9Zj9uOm4ubGVmdHx8MCxyLnRvcCs9Zj9uOm4udG9wfHwwLHIucmlnaHQtPWY/bjpuLnJpZ2h0fHwwLHIuYm90dG9tLT1mP246bi5ib3R0b218fDAscn1mdW5jdGlvbiBKdCh0LGUsaSxuLG8pe3ZhciByPTU8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzVdP2FyZ3VtZW50c1s1XTowO2lmKC0xPT09dC5pbmRleE9mKFwiYXV0b1wiKSlyZXR1cm4gdDt2YXIgcz1HdChpLG4scixvKSxhPXt0b3A6e3dpZHRoOnMud2lkdGgsaGVpZ2h0OmUudG9wLXMudG9wfSxyaWdodDp7d2lkdGg6cy5yaWdodC1lLnJpZ2h0LGhlaWdodDpzLmhlaWdodH0sYm90dG9tOnt3aWR0aDpzLndpZHRoLGhlaWdodDpzLmJvdHRvbS1lLmJvdHRvbX0sbGVmdDp7d2lkdGg6ZS5sZWZ0LXMubGVmdCxoZWlnaHQ6cy5oZWlnaHR9fSxsPU9iamVjdC5rZXlzKGEpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gUXQoe2tleTp0fSxhW3RdLHthcmVhOihlPWFbdF0sZS53aWR0aCplLmhlaWdodCl9KTt2YXIgZX0pLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5hcmVhLXQuYXJlYX0pLGM9bC5maWx0ZXIoZnVuY3Rpb24odCl7dmFyIGU9dC53aWR0aCxuPXQuaGVpZ2h0O3JldHVybiBlPj1pLmNsaWVudFdpZHRoJiZuPj1pLmNsaWVudEhlaWdodH0pLGg9MDxjLmxlbmd0aD9jWzBdLmtleTpsWzBdLmtleSx1PXQuc3BsaXQoXCItXCIpWzFdO3JldHVybiBoKyh1P1wiLVwiK3U6XCJcIil9ZnVuY3Rpb24gWnQodCxlLG4pe3ZhciBpPTM8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpudWxsO3JldHVybiBYdChuLGk/enQoZSk6RnQoZSxuKSxpKX1mdW5jdGlvbiAkdCh0KXt2YXIgZT10Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0KSxuPXBhcnNlRmxvYXQoZS5tYXJnaW5Ub3B8fDApK3BhcnNlRmxvYXQoZS5tYXJnaW5Cb3R0b218fDApLGk9cGFyc2VGbG9hdChlLm1hcmdpbkxlZnR8fDApK3BhcnNlRmxvYXQoZS5tYXJnaW5SaWdodHx8MCk7cmV0dXJue3dpZHRoOnQub2Zmc2V0V2lkdGgraSxoZWlnaHQ6dC5vZmZzZXRIZWlnaHQrbn19ZnVuY3Rpb24gdGUodCl7dmFyIGU9e2xlZnQ6XCJyaWdodFwiLHJpZ2h0OlwibGVmdFwiLGJvdHRvbTpcInRvcFwiLHRvcDpcImJvdHRvbVwifTtyZXR1cm4gdC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZyxmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0pfWZ1bmN0aW9uIGVlKHQsZSxuKXtuPW4uc3BsaXQoXCItXCIpWzBdO3ZhciBpPSR0KHQpLG89e3dpZHRoOmkud2lkdGgsaGVpZ2h0OmkuaGVpZ2h0fSxyPS0xIT09W1wicmlnaHRcIixcImxlZnRcIl0uaW5kZXhPZihuKSxzPXI/XCJ0b3BcIjpcImxlZnRcIixhPXI/XCJsZWZ0XCI6XCJ0b3BcIixsPXI/XCJoZWlnaHRcIjpcIndpZHRoXCIsYz1yP1wid2lkdGhcIjpcImhlaWdodFwiO3JldHVybiBvW3NdPWVbc10rZVtsXS8yLWlbbF0vMixvW2FdPW49PT1hP2VbYV0taVtjXTplW3RlKGEpXSxvfWZ1bmN0aW9uIG5lKHQsZSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5maW5kP3QuZmluZChlKTp0LmZpbHRlcihlKVswXX1mdW5jdGlvbiBpZSh0LG4sZSl7cmV0dXJuKHZvaWQgMD09PWU/dDp0LnNsaWNlKDAsZnVuY3Rpb24odCxlLG4pe2lmKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpcmV0dXJuIHQuZmluZEluZGV4KGZ1bmN0aW9uKHQpe3JldHVybiB0W2VdPT09bn0pO3ZhciBpPW5lKHQsZnVuY3Rpb24odCl7cmV0dXJuIHRbZV09PT1ufSk7cmV0dXJuIHQuaW5kZXhPZihpKX0odCxcIm5hbWVcIixlKSkpLmZvckVhY2goZnVuY3Rpb24odCl7dC5mdW5jdGlvbiYmY29uc29sZS53YXJuKFwiYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCFcIik7dmFyIGU9dC5mdW5jdGlvbnx8dC5mbjt0LmVuYWJsZWQmJk90KGUpJiYobi5vZmZzZXRzLnBvcHBlcj1ZdChuLm9mZnNldHMucG9wcGVyKSxuLm9mZnNldHMucmVmZXJlbmNlPVl0KG4ub2Zmc2V0cy5yZWZlcmVuY2UpLG49ZShuLHQpKX0pLG59ZnVuY3Rpb24gb2UodCxuKXtyZXR1cm4gdC5zb21lKGZ1bmN0aW9uKHQpe3ZhciBlPXQubmFtZTtyZXR1cm4gdC5lbmFibGVkJiZlPT09bn0pfWZ1bmN0aW9uIHJlKHQpe2Zvcih2YXIgZT1bITEsXCJtc1wiLFwiV2Via2l0XCIsXCJNb3pcIixcIk9cIl0sbj10LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSksaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbz1lW2ldLHI9bz9cIlwiK28rbjp0O2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudC5ib2R5LnN0eWxlW3JdKXJldHVybiByfXJldHVybiBudWxsfWZ1bmN0aW9uIHNlKHQpe3ZhciBlPXQub3duZXJEb2N1bWVudDtyZXR1cm4gZT9lLmRlZmF1bHRWaWV3OndpbmRvd31mdW5jdGlvbiBhZSh0LGUsbixpKXtuLnVwZGF0ZUJvdW5kPWksc2UodCkuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLG4udXBkYXRlQm91bmQse3Bhc3NpdmU6ITB9KTt2YXIgbz1MdCh0KTtyZXR1cm4gZnVuY3Rpb24gdChlLG4saSxvKXt2YXIgcj1cIkJPRFlcIj09PWUubm9kZU5hbWUscz1yP2Uub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldzplO3MuYWRkRXZlbnRMaXN0ZW5lcihuLGkse3Bhc3NpdmU6ITB9KSxyfHx0KEx0KHMucGFyZW50Tm9kZSksbixpLG8pLG8ucHVzaChzKX0obyxcInNjcm9sbFwiLG4udXBkYXRlQm91bmQsbi5zY3JvbGxQYXJlbnRzKSxuLnNjcm9sbEVsZW1lbnQ9byxuLmV2ZW50c0VuYWJsZWQ9ITAsbn1mdW5jdGlvbiBsZSgpe3ZhciB0LGU7dGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkJiYoY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSksdGhpcy5zdGF0ZT0odD10aGlzLnJlZmVyZW5jZSxlPXRoaXMuc3RhdGUsc2UodCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLGUudXBkYXRlQm91bmQpLGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLGUudXBkYXRlQm91bmQpfSksZS51cGRhdGVCb3VuZD1udWxsLGUuc2Nyb2xsUGFyZW50cz1bXSxlLnNjcm9sbEVsZW1lbnQ9bnVsbCxlLmV2ZW50c0VuYWJsZWQ9ITEsZSkpfWZ1bmN0aW9uIGNlKHQpe3JldHVyblwiXCIhPT10JiYhaXNOYU4ocGFyc2VGbG9hdCh0KSkmJmlzRmluaXRlKHQpfWZ1bmN0aW9uIGhlKG4saSl7T2JqZWN0LmtleXMoaSkuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgZT1cIlwiOy0xIT09W1wid2lkdGhcIixcImhlaWdodFwiLFwidG9wXCIsXCJyaWdodFwiLFwiYm90dG9tXCIsXCJsZWZ0XCJdLmluZGV4T2YodCkmJmNlKGlbdF0pJiYoZT1cInB4XCIpLG4uc3R5bGVbdF09aVt0XStlfSl9dmFyIHVlPUN0JiYvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7ZnVuY3Rpb24gZmUodCxlLG4pe3ZhciBpPW5lKHQsZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZT09PWV9KSxvPSEhaSYmdC5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWU9PT1uJiZ0LmVuYWJsZWQmJnQub3JkZXI8aS5vcmRlcn0pO2lmKCFvKXt2YXIgcj1cImBcIitlK1wiYFwiLHM9XCJgXCIrbitcImBcIjtjb25zb2xlLndhcm4ocytcIiBtb2RpZmllciBpcyByZXF1aXJlZCBieSBcIityK1wiIG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgXCIrcitcIiFcIil9cmV0dXJuIG99dmFyIGRlPVtcImF1dG8tc3RhcnRcIixcImF1dG9cIixcImF1dG8tZW5kXCIsXCJ0b3Atc3RhcnRcIixcInRvcFwiLFwidG9wLWVuZFwiLFwicmlnaHQtc3RhcnRcIixcInJpZ2h0XCIsXCJyaWdodC1lbmRcIixcImJvdHRvbS1lbmRcIixcImJvdHRvbVwiLFwiYm90dG9tLXN0YXJ0XCIsXCJsZWZ0LWVuZFwiLFwibGVmdFwiLFwibGVmdC1zdGFydFwiXSxwZT1kZS5zbGljZSgzKTtmdW5jdGlvbiBtZSh0KXt2YXIgZT0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLG49cGUuaW5kZXhPZih0KSxpPXBlLnNsaWNlKG4rMSkuY29uY2F0KHBlLnNsaWNlKDAsbikpO3JldHVybiBlP2kucmV2ZXJzZSgpOml9dmFyIGdlPVwiZmxpcFwiLF9lPVwiY2xvY2t3aXNlXCIsdmU9XCJjb3VudGVyY2xvY2t3aXNlXCI7ZnVuY3Rpb24geWUodCxvLHIsZSl7dmFyIHM9WzAsMF0sYT0tMSE9PVtcInJpZ2h0XCIsXCJsZWZ0XCJdLmluZGV4T2YoZSksbj10LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHJpbSgpfSksaT1uLmluZGV4T2YobmUobixmdW5jdGlvbih0KXtyZXR1cm4tMSE9PXQuc2VhcmNoKC8sfFxccy8pfSkpO25baV0mJi0xPT09bltpXS5pbmRleE9mKFwiLFwiKSYmY29uc29sZS53YXJuKFwiT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLlwiKTt2YXIgbD0vXFxzKixcXHMqfFxccysvLGM9LTEhPT1pP1tuLnNsaWNlKDAsaSkuY29uY2F0KFtuW2ldLnNwbGl0KGwpWzBdXSksW25baV0uc3BsaXQobClbMV1dLmNvbmNhdChuLnNsaWNlKGkrMSkpXTpbbl07cmV0dXJuKGM9Yy5tYXAoZnVuY3Rpb24odCxlKXt2YXIgbj0oMT09PWU/IWE6YSk/XCJoZWlnaHRcIjpcIndpZHRoXCIsaT0hMTtyZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm5cIlwiPT09dFt0Lmxlbmd0aC0xXSYmLTEhPT1bXCIrXCIsXCItXCJdLmluZGV4T2YoZSk/KHRbdC5sZW5ndGgtMV09ZSxpPSEwLHQpOmk/KHRbdC5sZW5ndGgtMV0rPWUsaT0hMSx0KTp0LmNvbmNhdChlKX0sW10pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxlLG4saSl7dmFyIG89dC5tYXRjaCgvKCg/OlxcLXxcXCspP1xcZCpcXC4/XFxkKikoLiopLykscj0rb1sxXSxzPW9bMl07aWYoIXIpcmV0dXJuIHQ7aWYoMCE9PXMuaW5kZXhPZihcIiVcIikpcmV0dXJuXCJ2aFwiIT09cyYmXCJ2d1wiIT09cz9yOihcInZoXCI9PT1zP01hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsd2luZG93LmlubmVySGVpZ2h0fHwwKTpNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsd2luZG93LmlubmVyV2lkdGh8fDApKS8xMDAqcjt2YXIgYT12b2lkIDA7c3dpdGNoKHMpe2Nhc2VcIiVwXCI6YT1uO2JyZWFrO2Nhc2VcIiVcIjpjYXNlXCIlclwiOmRlZmF1bHQ6YT1pfXJldHVybiBZdChhKVtlXS8xMDAqcn0odCxuLG8scil9KX0pKS5mb3JFYWNoKGZ1bmN0aW9uKG4saSl7bi5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7Y2UodCkmJihzW2ldKz10KihcIi1cIj09PW5bZS0xXT8tMToxKSl9KX0pLHN9dmFyIEVlPXtwbGFjZW1lbnQ6XCJib3R0b21cIixwb3NpdGlvbkZpeGVkOiExLGV2ZW50c0VuYWJsZWQ6ITAscmVtb3ZlT25EZXN0cm95OiExLG9uQ3JlYXRlOmZ1bmN0aW9uKCl7fSxvblVwZGF0ZTpmdW5jdGlvbigpe30sbW9kaWZpZXJzOntzaGlmdDp7b3JkZXI6MTAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24odCl7dmFyIGU9dC5wbGFjZW1lbnQsbj1lLnNwbGl0KFwiLVwiKVswXSxpPWUuc3BsaXQoXCItXCIpWzFdO2lmKGkpe3ZhciBvPXQub2Zmc2V0cyxyPW8ucmVmZXJlbmNlLHM9by5wb3BwZXIsYT0tMSE9PVtcImJvdHRvbVwiLFwidG9wXCJdLmluZGV4T2YobiksbD1hP1wibGVmdFwiOlwidG9wXCIsYz1hP1wid2lkdGhcIjpcImhlaWdodFwiLGg9e3N0YXJ0Okt0KHt9LGwscltsXSksZW5kOkt0KHt9LGwscltsXStyW2NdLXNbY10pfTt0Lm9mZnNldHMucG9wcGVyPVF0KHt9LHMsaFtpXSl9cmV0dXJuIHR9fSxvZmZzZXQ6e29yZGVyOjIwMCxlbmFibGVkOiEwLGZuOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5vZmZzZXQsaT10LnBsYWNlbWVudCxvPXQub2Zmc2V0cyxyPW8ucG9wcGVyLHM9by5yZWZlcmVuY2UsYT1pLnNwbGl0KFwiLVwiKVswXSxsPXZvaWQgMDtyZXR1cm4gbD1jZSgrbik/WytuLDBdOnllKG4scixzLGEpLFwibGVmdFwiPT09YT8oci50b3ArPWxbMF0sci5sZWZ0LT1sWzFdKTpcInJpZ2h0XCI9PT1hPyhyLnRvcCs9bFswXSxyLmxlZnQrPWxbMV0pOlwidG9wXCI9PT1hPyhyLmxlZnQrPWxbMF0sci50b3AtPWxbMV0pOlwiYm90dG9tXCI9PT1hJiYoci5sZWZ0Kz1sWzBdLHIudG9wKz1sWzFdKSx0LnBvcHBlcj1yLHR9LG9mZnNldDowfSxwcmV2ZW50T3ZlcmZsb3c6e29yZGVyOjMwMCxlbmFibGVkOiEwLGZuOmZ1bmN0aW9uKHQsaSl7dmFyIGU9aS5ib3VuZGFyaWVzRWxlbWVudHx8anQodC5pbnN0YW5jZS5wb3BwZXIpO3QuaW5zdGFuY2UucmVmZXJlbmNlPT09ZSYmKGU9anQoZSkpO3ZhciBuPXJlKFwidHJhbnNmb3JtXCIpLG89dC5pbnN0YW5jZS5wb3BwZXIuc3R5bGUscj1vLnRvcCxzPW8ubGVmdCxhPW9bbl07by50b3A9XCJcIixvLmxlZnQ9XCJcIixvW25dPVwiXCI7dmFyIGw9R3QodC5pbnN0YW5jZS5wb3BwZXIsdC5pbnN0YW5jZS5yZWZlcmVuY2UsaS5wYWRkaW5nLGUsdC5wb3NpdGlvbkZpeGVkKTtvLnRvcD1yLG8ubGVmdD1zLG9bbl09YSxpLmJvdW5kYXJpZXM9bDt2YXIgYz1pLnByaW9yaXR5LGg9dC5vZmZzZXRzLnBvcHBlcix1PXtwcmltYXJ5OmZ1bmN0aW9uKHQpe3ZhciBlPWhbdF07cmV0dXJuIGhbdF08bFt0XSYmIWkuZXNjYXBlV2l0aFJlZmVyZW5jZSYmKGU9TWF0aC5tYXgoaFt0XSxsW3RdKSksS3Qoe30sdCxlKX0sc2Vjb25kYXJ5OmZ1bmN0aW9uKHQpe3ZhciBlPVwicmlnaHRcIj09PXQ/XCJsZWZ0XCI6XCJ0b3BcIixuPWhbZV07cmV0dXJuIGhbdF0+bFt0XSYmIWkuZXNjYXBlV2l0aFJlZmVyZW5jZSYmKG49TWF0aC5taW4oaFtlXSxsW3RdLShcInJpZ2h0XCI9PT10P2gud2lkdGg6aC5oZWlnaHQpKSksS3Qoe30sZSxuKX19O3JldHVybiBjLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGU9LTEhPT1bXCJsZWZ0XCIsXCJ0b3BcIl0uaW5kZXhPZih0KT9cInByaW1hcnlcIjpcInNlY29uZGFyeVwiO2g9UXQoe30saCx1W2VdKHQpKX0pLHQub2Zmc2V0cy5wb3BwZXI9aCx0fSxwcmlvcml0eTpbXCJsZWZ0XCIsXCJyaWdodFwiLFwidG9wXCIsXCJib3R0b21cIl0scGFkZGluZzo1LGJvdW5kYXJpZXNFbGVtZW50Olwic2Nyb2xsUGFyZW50XCJ9LGtlZXBUb2dldGhlcjp7b3JkZXI6NDAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24odCl7dmFyIGU9dC5vZmZzZXRzLG49ZS5wb3BwZXIsaT1lLnJlZmVyZW5jZSxvPXQucGxhY2VtZW50LnNwbGl0KFwiLVwiKVswXSxyPU1hdGguZmxvb3Iscz0tMSE9PVtcInRvcFwiLFwiYm90dG9tXCJdLmluZGV4T2YobyksYT1zP1wicmlnaHRcIjpcImJvdHRvbVwiLGw9cz9cImxlZnRcIjpcInRvcFwiLGM9cz9cIndpZHRoXCI6XCJoZWlnaHRcIjtyZXR1cm4gblthXTxyKGlbbF0pJiYodC5vZmZzZXRzLnBvcHBlcltsXT1yKGlbbF0pLW5bY10pLG5bbF0+cihpW2FdKSYmKHQub2Zmc2V0cy5wb3BwZXJbbF09cihpW2FdKSksdH19LGFycm93OntvcmRlcjo1MDAsZW5hYmxlZDohMCxmbjpmdW5jdGlvbih0LGUpe3ZhciBuO2lmKCFmZSh0Lmluc3RhbmNlLm1vZGlmaWVycyxcImFycm93XCIsXCJrZWVwVG9nZXRoZXJcIikpcmV0dXJuIHQ7dmFyIGk9ZS5lbGVtZW50O2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpKXtpZighKGk9dC5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihpKSkpcmV0dXJuIHR9ZWxzZSBpZighdC5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoaSkpcmV0dXJuIGNvbnNvbGUud2FybihcIldBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCFcIiksdDt2YXIgbz10LnBsYWNlbWVudC5zcGxpdChcIi1cIilbMF0scj10Lm9mZnNldHMscz1yLnBvcHBlcixhPXIucmVmZXJlbmNlLGw9LTEhPT1bXCJsZWZ0XCIsXCJyaWdodFwiXS5pbmRleE9mKG8pLGM9bD9cImhlaWdodFwiOlwid2lkdGhcIixoPWw/XCJUb3BcIjpcIkxlZnRcIix1PWgudG9Mb3dlckNhc2UoKSxmPWw/XCJsZWZ0XCI6XCJ0b3BcIixkPWw/XCJib3R0b21cIjpcInJpZ2h0XCIscD0kdChpKVtjXTthW2RdLXA8c1t1XSYmKHQub2Zmc2V0cy5wb3BwZXJbdV0tPXNbdV0tKGFbZF0tcCkpLGFbdV0rcD5zW2RdJiYodC5vZmZzZXRzLnBvcHBlclt1XSs9YVt1XStwLXNbZF0pLHQub2Zmc2V0cy5wb3BwZXI9WXQodC5vZmZzZXRzLnBvcHBlcik7dmFyIG09YVt1XSthW2NdLzItcC8yLGc9TnQodC5pbnN0YW5jZS5wb3BwZXIpLF89cGFyc2VGbG9hdChnW1wibWFyZ2luXCIraF0sMTApLHY9cGFyc2VGbG9hdChnW1wiYm9yZGVyXCIraCtcIldpZHRoXCJdLDEwKSx5PW0tdC5vZmZzZXRzLnBvcHBlclt1XS1fLXY7cmV0dXJuIHk9TWF0aC5tYXgoTWF0aC5taW4oc1tjXS1wLHkpLDApLHQuYXJyb3dFbGVtZW50PWksdC5vZmZzZXRzLmFycm93PShLdChuPXt9LHUsTWF0aC5yb3VuZCh5KSksS3QobixmLFwiXCIpLG4pLHR9LGVsZW1lbnQ6XCJbeC1hcnJvd11cIn0sZmxpcDp7b3JkZXI6NjAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24ocCxtKXtpZihvZShwLmluc3RhbmNlLm1vZGlmaWVycyxcImlubmVyXCIpKXJldHVybiBwO2lmKHAuZmxpcHBlZCYmcC5wbGFjZW1lbnQ9PT1wLm9yaWdpbmFsUGxhY2VtZW50KXJldHVybiBwO3ZhciBnPUd0KHAuaW5zdGFuY2UucG9wcGVyLHAuaW5zdGFuY2UucmVmZXJlbmNlLG0ucGFkZGluZyxtLmJvdW5kYXJpZXNFbGVtZW50LHAucG9zaXRpb25GaXhlZCksXz1wLnBsYWNlbWVudC5zcGxpdChcIi1cIilbMF0sdj10ZShfKSx5PXAucGxhY2VtZW50LnNwbGl0KFwiLVwiKVsxXXx8XCJcIixFPVtdO3N3aXRjaChtLmJlaGF2aW9yKXtjYXNlIGdlOkU9W18sdl07YnJlYWs7Y2FzZSBfZTpFPW1lKF8pO2JyZWFrO2Nhc2UgdmU6RT1tZShfLCEwKTticmVhaztkZWZhdWx0OkU9bS5iZWhhdmlvcn1yZXR1cm4gRS5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7aWYoXyE9PXR8fEUubGVuZ3RoPT09ZSsxKXJldHVybiBwO189cC5wbGFjZW1lbnQuc3BsaXQoXCItXCIpWzBdLHY9dGUoXyk7dmFyIG4saT1wLm9mZnNldHMucG9wcGVyLG89cC5vZmZzZXRzLnJlZmVyZW5jZSxyPU1hdGguZmxvb3Iscz1cImxlZnRcIj09PV8mJnIoaS5yaWdodCk+cihvLmxlZnQpfHxcInJpZ2h0XCI9PT1fJiZyKGkubGVmdCk8cihvLnJpZ2h0KXx8XCJ0b3BcIj09PV8mJnIoaS5ib3R0b20pPnIoby50b3ApfHxcImJvdHRvbVwiPT09XyYmcihpLnRvcCk8cihvLmJvdHRvbSksYT1yKGkubGVmdCk8cihnLmxlZnQpLGw9cihpLnJpZ2h0KT5yKGcucmlnaHQpLGM9cihpLnRvcCk8cihnLnRvcCksaD1yKGkuYm90dG9tKT5yKGcuYm90dG9tKSx1PVwibGVmdFwiPT09XyYmYXx8XCJyaWdodFwiPT09XyYmbHx8XCJ0b3BcIj09PV8mJmN8fFwiYm90dG9tXCI9PT1fJiZoLGY9LTEhPT1bXCJ0b3BcIixcImJvdHRvbVwiXS5pbmRleE9mKF8pLGQ9ISFtLmZsaXBWYXJpYXRpb25zJiYoZiYmXCJzdGFydFwiPT09eSYmYXx8ZiYmXCJlbmRcIj09PXkmJmx8fCFmJiZcInN0YXJ0XCI9PT15JiZjfHwhZiYmXCJlbmRcIj09PXkmJmgpOyhzfHx1fHxkKSYmKHAuZmxpcHBlZD0hMCwoc3x8dSkmJihfPUVbZSsxXSksZCYmKHk9XCJlbmRcIj09PShuPXkpP1wic3RhcnRcIjpcInN0YXJ0XCI9PT1uP1wiZW5kXCI6bikscC5wbGFjZW1lbnQ9XysoeT9cIi1cIit5OlwiXCIpLHAub2Zmc2V0cy5wb3BwZXI9UXQoe30scC5vZmZzZXRzLnBvcHBlcixlZShwLmluc3RhbmNlLnBvcHBlcixwLm9mZnNldHMucmVmZXJlbmNlLHAucGxhY2VtZW50KSkscD1pZShwLmluc3RhbmNlLm1vZGlmaWVycyxwLFwiZmxpcFwiKSl9KSxwfSxiZWhhdmlvcjpcImZsaXBcIixwYWRkaW5nOjUsYm91bmRhcmllc0VsZW1lbnQ6XCJ2aWV3cG9ydFwifSxpbm5lcjp7b3JkZXI6NzAwLGVuYWJsZWQ6ITEsZm46ZnVuY3Rpb24odCl7dmFyIGU9dC5wbGFjZW1lbnQsbj1lLnNwbGl0KFwiLVwiKVswXSxpPXQub2Zmc2V0cyxvPWkucG9wcGVyLHI9aS5yZWZlcmVuY2Uscz0tMSE9PVtcImxlZnRcIixcInJpZ2h0XCJdLmluZGV4T2YobiksYT0tMT09PVtcInRvcFwiLFwibGVmdFwiXS5pbmRleE9mKG4pO3JldHVybiBvW3M/XCJsZWZ0XCI6XCJ0b3BcIl09cltuXS0oYT9vW3M/XCJ3aWR0aFwiOlwiaGVpZ2h0XCJdOjApLHQucGxhY2VtZW50PXRlKGUpLHQub2Zmc2V0cy5wb3BwZXI9WXQobyksdH19LGhpZGU6e29yZGVyOjgwMCxlbmFibGVkOiEwLGZuOmZ1bmN0aW9uKHQpe2lmKCFmZSh0Lmluc3RhbmNlLm1vZGlmaWVycyxcImhpZGVcIixcInByZXZlbnRPdmVyZmxvd1wiKSlyZXR1cm4gdDt2YXIgZT10Lm9mZnNldHMucmVmZXJlbmNlLG49bmUodC5pbnN0YW5jZS5tb2RpZmllcnMsZnVuY3Rpb24odCl7cmV0dXJuXCJwcmV2ZW50T3ZlcmZsb3dcIj09PXQubmFtZX0pLmJvdW5kYXJpZXM7aWYoZS5ib3R0b208bi50b3B8fGUubGVmdD5uLnJpZ2h0fHxlLnRvcD5uLmJvdHRvbXx8ZS5yaWdodDxuLmxlZnQpe2lmKCEwPT09dC5oaWRlKXJldHVybiB0O3QuaGlkZT0hMCx0LmF0dHJpYnV0ZXNbXCJ4LW91dC1vZi1ib3VuZGFyaWVzXCJdPVwiXCJ9ZWxzZXtpZighMT09PXQuaGlkZSlyZXR1cm4gdDt0LmhpZGU9ITEsdC5hdHRyaWJ1dGVzW1wieC1vdXQtb2YtYm91bmRhcmllc1wiXT0hMX1yZXR1cm4gdH19LGNvbXB1dGVTdHlsZTp7b3JkZXI6ODUwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24odCxlKXt2YXIgbj1lLngsaT1lLnksbz10Lm9mZnNldHMucG9wcGVyLHI9bmUodC5pbnN0YW5jZS5tb2RpZmllcnMsZnVuY3Rpb24odCl7cmV0dXJuXCJhcHBseVN0eWxlXCI9PT10Lm5hbWV9KS5ncHVBY2NlbGVyYXRpb247dm9pZCAwIT09ciYmY29uc29sZS53YXJuKFwiV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyFcIik7dmFyIHMsYSxsLGMsaCx1LGYsZCxwLG0sZyxfLHY9dm9pZCAwIT09cj9yOmUuZ3B1QWNjZWxlcmF0aW9uLHk9anQodC5pbnN0YW5jZS5wb3BwZXIpLEU9VnQoeSksYj17cG9zaXRpb246by5wb3NpdGlvbn0sdz0ocz10LGE9d2luZG93LmRldmljZVBpeGVsUmF0aW88Mnx8IXVlLGw9cy5vZmZzZXRzLGM9bC5wb3BwZXIsaD1sLnJlZmVyZW5jZSx1PS0xIT09W1wibGVmdFwiLFwicmlnaHRcIl0uaW5kZXhPZihzLnBsYWNlbWVudCksZj0tMSE9PXMucGxhY2VtZW50LmluZGV4T2YoXCItXCIpLGQ9aC53aWR0aCUyPT1jLndpZHRoJTIscD1oLndpZHRoJTI9PTEmJmMud2lkdGglMj09MSxtPWZ1bmN0aW9uKHQpe3JldHVybiB0fSxnPWE/dXx8Znx8ZD9NYXRoLnJvdW5kOk1hdGguZmxvb3I6bSxfPWE/TWF0aC5yb3VuZDptLHtsZWZ0OmcocCYmIWYmJmE/Yy5sZWZ0LTE6Yy5sZWZ0KSx0b3A6XyhjLnRvcCksYm90dG9tOl8oYy5ib3R0b20pLHJpZ2h0OmcoYy5yaWdodCl9KSxUPVwiYm90dG9tXCI9PT1uP1widG9wXCI6XCJib3R0b21cIixDPVwicmlnaHRcIj09PWk/XCJsZWZ0XCI6XCJyaWdodFwiLFM9cmUoXCJ0cmFuc2Zvcm1cIiksRD12b2lkIDAsST12b2lkIDA7aWYoST1cImJvdHRvbVwiPT09VD9cIkhUTUxcIj09PXkubm9kZU5hbWU/LXkuY2xpZW50SGVpZ2h0K3cuYm90dG9tOi1FLmhlaWdodCt3LmJvdHRvbTp3LnRvcCxEPVwicmlnaHRcIj09PUM/XCJIVE1MXCI9PT15Lm5vZGVOYW1lPy15LmNsaWVudFdpZHRoK3cucmlnaHQ6LUUud2lkdGgrdy5yaWdodDp3LmxlZnQsdiYmUyliW1NdPVwidHJhbnNsYXRlM2QoXCIrRCtcInB4LCBcIitJK1wicHgsIDApXCIsYltUXT0wLGJbQ109MCxiLndpbGxDaGFuZ2U9XCJ0cmFuc2Zvcm1cIjtlbHNle3ZhciBBPVwiYm90dG9tXCI9PT1UPy0xOjEsTz1cInJpZ2h0XCI9PT1DPy0xOjE7YltUXT1JKkEsYltDXT1EKk8sYi53aWxsQ2hhbmdlPVQrXCIsIFwiK0N9dmFyIE49e1wieC1wbGFjZW1lbnRcIjp0LnBsYWNlbWVudH07cmV0dXJuIHQuYXR0cmlidXRlcz1RdCh7fSxOLHQuYXR0cmlidXRlcyksdC5zdHlsZXM9UXQoe30sYix0LnN0eWxlcyksdC5hcnJvd1N0eWxlcz1RdCh7fSx0Lm9mZnNldHMuYXJyb3csdC5hcnJvd1N0eWxlcyksdH0sZ3B1QWNjZWxlcmF0aW9uOiEwLHg6XCJib3R0b21cIix5OlwicmlnaHRcIn0sYXBwbHlTdHlsZTp7b3JkZXI6OTAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24odCl7dmFyIGUsbjtyZXR1cm4gaGUodC5pbnN0YW5jZS5wb3BwZXIsdC5zdHlsZXMpLGU9dC5pbnN0YW5jZS5wb3BwZXIsbj10LmF0dHJpYnV0ZXMsT2JqZWN0LmtleXMobikuZm9yRWFjaChmdW5jdGlvbih0KXshMSE9PW5bdF0/ZS5zZXRBdHRyaWJ1dGUodCxuW3RdKTplLnJlbW92ZUF0dHJpYnV0ZSh0KX0pLHQuYXJyb3dFbGVtZW50JiZPYmplY3Qua2V5cyh0LmFycm93U3R5bGVzKS5sZW5ndGgmJmhlKHQuYXJyb3dFbGVtZW50LHQuYXJyb3dTdHlsZXMpLHR9LG9uTG9hZDpmdW5jdGlvbih0LGUsbixpLG8pe3ZhciByPVp0KG8sZSx0LG4ucG9zaXRpb25GaXhlZCkscz1KdChuLnBsYWNlbWVudCxyLGUsdCxuLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LG4ubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7cmV0dXJuIGUuc2V0QXR0cmlidXRlKFwieC1wbGFjZW1lbnRcIixzKSxoZShlLHtwb3NpdGlvbjpuLnBvc2l0aW9uRml4ZWQ/XCJmaXhlZFwiOlwiYWJzb2x1dGVcIn0pLG59LGdwdUFjY2VsZXJhdGlvbjp2b2lkIDB9fX0sYmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKHQsZSl7dmFyIG49dGhpcyxpPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fTshZnVuY3Rpb24odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLHIpLHRoaXMuc2NoZWR1bGVVcGRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG4udXBkYXRlKX0sdGhpcy51cGRhdGU9QXQodGhpcy51cGRhdGUuYmluZCh0aGlzKSksdGhpcy5vcHRpb25zPVF0KHt9LHIuRGVmYXVsdHMsaSksdGhpcy5zdGF0ZT17aXNEZXN0cm95ZWQ6ITEsaXNDcmVhdGVkOiExLHNjcm9sbFBhcmVudHM6W119LHRoaXMucmVmZXJlbmNlPXQmJnQuanF1ZXJ5P3RbMF06dCx0aGlzLnBvcHBlcj1lJiZlLmpxdWVyeT9lWzBdOmUsdGhpcy5vcHRpb25zLm1vZGlmaWVycz17fSxPYmplY3Qua2V5cyhRdCh7fSxyLkRlZmF1bHRzLm1vZGlmaWVycyxpLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24odCl7bi5vcHRpb25zLm1vZGlmaWVyc1t0XT1RdCh7fSxyLkRlZmF1bHRzLm1vZGlmaWVyc1t0XXx8e30saS5tb2RpZmllcnM/aS5tb2RpZmllcnNbdF06e30pfSksdGhpcy5tb2RpZmllcnM9T2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBRdCh7bmFtZTp0fSxuLm9wdGlvbnMubW9kaWZpZXJzW3RdKX0pLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5vcmRlci1lLm9yZGVyfSksdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbih0KXt0LmVuYWJsZWQmJk90KHQub25Mb2FkKSYmdC5vbkxvYWQobi5yZWZlcmVuY2Usbi5wb3BwZXIsbi5vcHRpb25zLHQsbi5zdGF0ZSl9KSx0aGlzLnVwZGF0ZSgpO3ZhciBvPXRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO28mJnRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSx0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQ9b31yZXR1cm4gcXQocixbe2tleTpcInVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIXRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpe3ZhciB0PXtpbnN0YW5jZTp0aGlzLHN0eWxlczp7fSxhcnJvd1N0eWxlczp7fSxhdHRyaWJ1dGVzOnt9LGZsaXBwZWQ6ITEsb2Zmc2V0czp7fX07dC5vZmZzZXRzLnJlZmVyZW5jZT1adCh0aGlzLnN0YXRlLHRoaXMucG9wcGVyLHRoaXMucmVmZXJlbmNlLHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKSx0LnBsYWNlbWVudD1KdCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LHQub2Zmc2V0cy5yZWZlcmVuY2UsdGhpcy5wb3BwZXIsdGhpcy5yZWZlcmVuY2UsdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKSx0Lm9yaWdpbmFsUGxhY2VtZW50PXQucGxhY2VtZW50LHQucG9zaXRpb25GaXhlZD10aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCx0Lm9mZnNldHMucG9wcGVyPWVlKHRoaXMucG9wcGVyLHQub2Zmc2V0cy5yZWZlcmVuY2UsdC5wbGFjZW1lbnQpLHQub2Zmc2V0cy5wb3BwZXIucG9zaXRpb249dGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQ/XCJmaXhlZFwiOlwiYWJzb2x1dGVcIix0PWllKHRoaXMubW9kaWZpZXJzLHQpLHRoaXMuc3RhdGUuaXNDcmVhdGVkP3RoaXMub3B0aW9ucy5vblVwZGF0ZSh0KToodGhpcy5zdGF0ZS5pc0NyZWF0ZWQ9ITAsdGhpcy5vcHRpb25zLm9uQ3JlYXRlKHQpKX19LmNhbGwodGhpcyl9fSx7a2V5OlwiZGVzdHJveVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQ9ITAsb2UodGhpcy5tb2RpZmllcnMsXCJhcHBseVN0eWxlXCIpJiYodGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKFwieC1wbGFjZW1lbnRcIiksdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb249XCJcIix0aGlzLnBvcHBlci5zdHlsZS50b3A9XCJcIix0aGlzLnBvcHBlci5zdHlsZS5sZWZ0PVwiXCIsdGhpcy5wb3BwZXIuc3R5bGUucmlnaHQ9XCJcIix0aGlzLnBvcHBlci5zdHlsZS5ib3R0b209XCJcIix0aGlzLnBvcHBlci5zdHlsZS53aWxsQ2hhbmdlPVwiXCIsdGhpcy5wb3BwZXIuc3R5bGVbcmUoXCJ0cmFuc2Zvcm1cIildPVwiXCIpLHRoaXMuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCksdGhpcy5vcHRpb25zLnJlbW92ZU9uRGVzdHJveSYmdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlciksdGhpc30uY2FsbCh0aGlzKX19LHtrZXk6XCJlbmFibGVFdmVudExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7dGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkfHwodGhpcy5zdGF0ZT1hZSh0aGlzLnJlZmVyZW5jZSx0aGlzLm9wdGlvbnMsdGhpcy5zdGF0ZSx0aGlzLnNjaGVkdWxlVXBkYXRlKSl9LmNhbGwodGhpcyl9fSx7a2V5OlwiZGlzYWJsZUV2ZW50TGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbGUuY2FsbCh0aGlzKX19XSkscn0oKTtiZS5VdGlscz0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6Z2xvYmFsKS5Qb3BwZXJVdGlscyxiZS5wbGFjZW1lbnRzPWRlLGJlLkRlZmF1bHRzPUVlO3ZhciB3ZT1cImRyb3Bkb3duXCIsVGU9XCJicy5kcm9wZG93blwiLENlPVwiLlwiK1RlLFNlPVwiLmRhdGEtYXBpXCIsRGU9cC5mblt3ZV0sSWU9bmV3IFJlZ0V4cChcIjM4fDQwfDI3XCIpLEFlPXtISURFOlwiaGlkZVwiK0NlLEhJRERFTjpcImhpZGRlblwiK0NlLFNIT1c6XCJzaG93XCIrQ2UsU0hPV046XCJzaG93blwiK0NlLENMSUNLOlwiY2xpY2tcIitDZSxDTElDS19EQVRBX0FQSTpcImNsaWNrXCIrQ2UrU2UsS0VZRE9XTl9EQVRBX0FQSTpcImtleWRvd25cIitDZStTZSxLRVlVUF9EQVRBX0FQSTpcImtleXVwXCIrQ2UrU2V9LE9lPVwiZGlzYWJsZWRcIixOZT1cInNob3dcIixrZT1cImRyb3B1cFwiLExlPVwiZHJvcHJpZ2h0XCIsUGU9XCJkcm9wbGVmdFwiLHhlPVwiZHJvcGRvd24tbWVudS1yaWdodFwiLEhlPVwicG9zaXRpb24tc3RhdGljXCIsamU9J1tkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJdJyxSZT1cIi5kcm9wZG93biBmb3JtXCIsRmU9XCIuZHJvcGRvd24tbWVudVwiLE1lPVwiLm5hdmJhci1uYXZcIixXZT1cIi5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpXCIsVWU9XCJ0b3Atc3RhcnRcIixCZT1cInRvcC1lbmRcIixxZT1cImJvdHRvbS1zdGFydFwiLEtlPVwiYm90dG9tLWVuZFwiLFFlPVwicmlnaHQtc3RhcnRcIixZZT1cImxlZnQtc3RhcnRcIixWZT17b2Zmc2V0OjAsZmxpcDohMCxib3VuZGFyeTpcInNjcm9sbFBhcmVudFwiLHJlZmVyZW5jZTpcInRvZ2dsZVwiLGRpc3BsYXk6XCJkeW5hbWljXCJ9LFhlPXtvZmZzZXQ6XCIobnVtYmVyfHN0cmluZ3xmdW5jdGlvbilcIixmbGlwOlwiYm9vbGVhblwiLGJvdW5kYXJ5OlwiKHN0cmluZ3xlbGVtZW50KVwiLHJlZmVyZW5jZTpcIihzdHJpbmd8ZWxlbWVudClcIixkaXNwbGF5Olwic3RyaW5nXCJ9LHplPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYyh0LGUpe3RoaXMuX2VsZW1lbnQ9dCx0aGlzLl9wb3BwZXI9bnVsbCx0aGlzLl9jb25maWc9dGhpcy5fZ2V0Q29uZmlnKGUpLHRoaXMuX21lbnU9dGhpcy5fZ2V0TWVudUVsZW1lbnQoKSx0aGlzLl9pbk5hdmJhcj10aGlzLl9kZXRlY3ROYXZiYXIoKSx0aGlzLl9hZGRFdmVudExpc3RlbmVycygpfXZhciB0PWMucHJvdG90eXBlO3JldHVybiB0LnRvZ2dsZT1mdW5jdGlvbigpe2lmKCF0aGlzLl9lbGVtZW50LmRpc2FibGVkJiYhcCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhPZSkpe3ZhciB0PWMuX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpLGU9cCh0aGlzLl9tZW51KS5oYXNDbGFzcyhOZSk7aWYoYy5fY2xlYXJNZW51cygpLCFlKXt2YXIgbj17cmVsYXRlZFRhcmdldDp0aGlzLl9lbGVtZW50fSxpPXAuRXZlbnQoQWUuU0hPVyxuKTtpZihwKHQpLnRyaWdnZXIoaSksIWkuaXNEZWZhdWx0UHJldmVudGVkKCkpe2lmKCF0aGlzLl9pbk5hdmJhcil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGJlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJCb290c3RyYXAncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIuanMgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy8pXCIpO3ZhciBvPXRoaXMuX2VsZW1lbnQ7XCJwYXJlbnRcIj09PXRoaXMuX2NvbmZpZy5yZWZlcmVuY2U/bz10Om0uaXNFbGVtZW50KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpJiYobz10aGlzLl9jb25maWcucmVmZXJlbmNlLFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlLmpxdWVyeSYmKG89dGhpcy5fY29uZmlnLnJlZmVyZW5jZVswXSkpLFwic2Nyb2xsUGFyZW50XCIhPT10aGlzLl9jb25maWcuYm91bmRhcnkmJnAodCkuYWRkQ2xhc3MoSGUpLHRoaXMuX3BvcHBlcj1uZXcgYmUobyx0aGlzLl9tZW51LHRoaXMuX2dldFBvcHBlckNvbmZpZygpKX1cIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiYwPT09cCh0KS5jbG9zZXN0KE1lKS5sZW5ndGgmJnAoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vbihcIm1vdXNlb3ZlclwiLG51bGwscC5ub29wKSx0aGlzLl9lbGVtZW50LmZvY3VzKCksdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsITApLHAodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoTmUpLHAodCkudG9nZ2xlQ2xhc3MoTmUpLnRyaWdnZXIocC5FdmVudChBZS5TSE9XTixuKSl9fX19LHQuc2hvdz1mdW5jdGlvbigpe2lmKCEodGhpcy5fZWxlbWVudC5kaXNhYmxlZHx8cCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhPZSl8fHAodGhpcy5fbWVudSkuaGFzQ2xhc3MoTmUpKSl7dmFyIHQ9e3JlbGF0ZWRUYXJnZXQ6dGhpcy5fZWxlbWVudH0sZT1wLkV2ZW50KEFlLlNIT1csdCksbj1jLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtwKG4pLnRyaWdnZXIoZSksZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KHAodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoTmUpLHAobikudG9nZ2xlQ2xhc3MoTmUpLnRyaWdnZXIocC5FdmVudChBZS5TSE9XTix0KSkpfX0sdC5oaWRlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2VsZW1lbnQuZGlzYWJsZWQmJiFwKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKE9lKSYmcCh0aGlzLl9tZW51KS5oYXNDbGFzcyhOZSkpe3ZhciB0PXtyZWxhdGVkVGFyZ2V0OnRoaXMuX2VsZW1lbnR9LGU9cC5FdmVudChBZS5ISURFLHQpLG49Yy5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7cChuKS50cmlnZ2VyKGUpLGUuaXNEZWZhdWx0UHJldmVudGVkKCl8fChwKHRoaXMuX21lbnUpLnRvZ2dsZUNsYXNzKE5lKSxwKG4pLnRvZ2dsZUNsYXNzKE5lKS50cmlnZ2VyKHAuRXZlbnQoQWUuSElEREVOLHQpKSl9fSx0LmRpc3Bvc2U9ZnVuY3Rpb24oKXtwLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCxUZSkscCh0aGlzLl9lbGVtZW50KS5vZmYoQ2UpLHRoaXMuX2VsZW1lbnQ9bnVsbCwodGhpcy5fbWVudT1udWxsKSE9PXRoaXMuX3BvcHBlciYmKHRoaXMuX3BvcHBlci5kZXN0cm95KCksdGhpcy5fcG9wcGVyPW51bGwpfSx0LnVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuX2luTmF2YmFyPXRoaXMuX2RldGVjdE5hdmJhcigpLG51bGwhPT10aGlzLl9wb3BwZXImJnRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpfSx0Ll9hZGRFdmVudExpc3RlbmVycz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cCh0aGlzLl9lbGVtZW50KS5vbihBZS5DTElDSyxmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksdC5zdG9wUHJvcGFnYXRpb24oKSxlLnRvZ2dsZSgpfSl9LHQuX2dldENvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4gdD1sKHt9LHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxwKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSx0KSxtLnR5cGVDaGVja0NvbmZpZyh3ZSx0LHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLHR9LHQuX2dldE1lbnVFbGVtZW50PWZ1bmN0aW9uKCl7aWYoIXRoaXMuX21lbnUpe3ZhciB0PWMuX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO3QmJih0aGlzLl9tZW51PXQucXVlcnlTZWxlY3RvcihGZSkpfXJldHVybiB0aGlzLl9tZW51fSx0Ll9nZXRQbGFjZW1lbnQ9ZnVuY3Rpb24oKXt2YXIgdD1wKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSksZT1xZTtyZXR1cm4gdC5oYXNDbGFzcyhrZSk/KGU9VWUscCh0aGlzLl9tZW51KS5oYXNDbGFzcyh4ZSkmJihlPUJlKSk6dC5oYXNDbGFzcyhMZSk/ZT1RZTp0Lmhhc0NsYXNzKFBlKT9lPVllOnAodGhpcy5fbWVudSkuaGFzQ2xhc3MoeGUpJiYoZT1LZSksZX0sdC5fZGV0ZWN0TmF2YmFyPWZ1bmN0aW9uKCl7cmV0dXJuIDA8cCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFwiLm5hdmJhclwiKS5sZW5ndGh9LHQuX2dldFBvcHBlckNvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXRoaXMsdD17fTtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLl9jb25maWcub2Zmc2V0P3QuZm49ZnVuY3Rpb24odCl7cmV0dXJuIHQub2Zmc2V0cz1sKHt9LHQub2Zmc2V0cyxlLl9jb25maWcub2Zmc2V0KHQub2Zmc2V0cyl8fHt9KSx0fTp0Lm9mZnNldD10aGlzLl9jb25maWcub2Zmc2V0O3ZhciBuPXtwbGFjZW1lbnQ6dGhpcy5fZ2V0UGxhY2VtZW50KCksbW9kaWZpZXJzOntvZmZzZXQ6dCxmbGlwOntlbmFibGVkOnRoaXMuX2NvbmZpZy5mbGlwfSxwcmV2ZW50T3ZlcmZsb3c6e2JvdW5kYXJpZXNFbGVtZW50OnRoaXMuX2NvbmZpZy5ib3VuZGFyeX19fTtyZXR1cm5cInN0YXRpY1wiPT09dGhpcy5fY29uZmlnLmRpc3BsYXkmJihuLm1vZGlmaWVycy5hcHBseVN0eWxlPXtlbmFibGVkOiExfSksbn0sYy5falF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD1wKHRoaXMpLmRhdGEoVGUpO2lmKHR8fCh0PW5ldyBjKHRoaXMsXCJvYmplY3RcIj09dHlwZW9mIGU/ZTpudWxsKSxwKHRoaXMpLmRhdGEoVGUsdCkpLFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgdFtlXSl0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK2UrJ1wiJyk7dFtlXSgpfX0pfSxjLl9jbGVhck1lbnVzPWZ1bmN0aW9uKHQpe2lmKCF0fHwzIT09dC53aGljaCYmKFwia2V5dXBcIiE9PXQudHlwZXx8OT09PXQud2hpY2gpKWZvcih2YXIgZT1bXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoamUpKSxuPTAsaT1lLmxlbmd0aDtuPGk7bisrKXt2YXIgbz1jLl9nZXRQYXJlbnRGcm9tRWxlbWVudChlW25dKSxyPXAoZVtuXSkuZGF0YShUZSkscz17cmVsYXRlZFRhcmdldDplW25dfTtpZih0JiZcImNsaWNrXCI9PT10LnR5cGUmJihzLmNsaWNrRXZlbnQ9dCkscil7dmFyIGE9ci5fbWVudTtpZihwKG8pLmhhc0NsYXNzKE5lKSYmISh0JiYoXCJjbGlja1wiPT09dC50eXBlJiYvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpfHxcImtleXVwXCI9PT10LnR5cGUmJjk9PT10LndoaWNoKSYmcC5jb250YWlucyhvLHQudGFyZ2V0KSkpe3ZhciBsPXAuRXZlbnQoQWUuSElERSxzKTtwKG8pLnRyaWdnZXIobCksbC5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KFwib250b3VjaHN0YXJ0XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJnAoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vZmYoXCJtb3VzZW92ZXJcIixudWxsLHAubm9vcCksZVtuXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsXCJmYWxzZVwiKSxwKGEpLnJlbW92ZUNsYXNzKE5lKSxwKG8pLnJlbW92ZUNsYXNzKE5lKS50cmlnZ2VyKHAuRXZlbnQoQWUuSElEREVOLHMpKSl9fX19LGMuX2dldFBhcmVudEZyb21FbGVtZW50PWZ1bmN0aW9uKHQpe3ZhciBlLG49bS5nZXRTZWxlY3RvckZyb21FbGVtZW50KHQpO3JldHVybiBuJiYoZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKG4pKSxlfHx0LnBhcmVudE5vZGV9LGMuX2RhdGFBcGlLZXlkb3duSGFuZGxlcj1mdW5jdGlvbih0KXtpZigoL2lucHV0fHRleHRhcmVhL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKT8hKDMyPT09dC53aGljaHx8MjchPT10LndoaWNoJiYoNDAhPT10LndoaWNoJiYzOCE9PXQud2hpY2h8fHAodC50YXJnZXQpLmNsb3Nlc3QoRmUpLmxlbmd0aCkpOkllLnRlc3QodC53aGljaCkpJiYodC5wcmV2ZW50RGVmYXVsdCgpLHQuc3RvcFByb3BhZ2F0aW9uKCksIXRoaXMuZGlzYWJsZWQmJiFwKHRoaXMpLmhhc0NsYXNzKE9lKSkpe3ZhciBlPWMuX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMpLG49cChlKS5oYXNDbGFzcyhOZSk7aWYobiYmKCFufHwyNyE9PXQud2hpY2gmJjMyIT09dC53aGljaCkpe3ZhciBpPVtdLnNsaWNlLmNhbGwoZS5xdWVyeVNlbGVjdG9yQWxsKFdlKSk7aWYoMCE9PWkubGVuZ3RoKXt2YXIgbz1pLmluZGV4T2YodC50YXJnZXQpOzM4PT09dC53aGljaCYmMDxvJiZvLS0sNDA9PT10LndoaWNoJiZvPGkubGVuZ3RoLTEmJm8rKyxvPDAmJihvPTApLGlbb10uZm9jdXMoKX19ZWxzZXtpZigyNz09PXQud2hpY2gpe3ZhciByPWUucXVlcnlTZWxlY3RvcihqZSk7cChyKS50cmlnZ2VyKFwiZm9jdXNcIil9cCh0aGlzKS50cmlnZ2VyKFwiY2xpY2tcIil9fX0scyhjLG51bGwsW3trZXk6XCJWRVJTSU9OXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjIuMVwifX0se2tleTpcIkRlZmF1bHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gVmV9fSx7a2V5OlwiRGVmYXVsdFR5cGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gWGV9fV0pLGN9KCk7cChkb2N1bWVudCkub24oQWUuS0VZRE9XTl9EQVRBX0FQSSxqZSx6ZS5fZGF0YUFwaUtleWRvd25IYW5kbGVyKS5vbihBZS5LRVlET1dOX0RBVEFfQVBJLEZlLHplLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpLm9uKEFlLkNMSUNLX0RBVEFfQVBJK1wiIFwiK0FlLktFWVVQX0RBVEFfQVBJLHplLl9jbGVhck1lbnVzKS5vbihBZS5DTElDS19EQVRBX0FQSSxqZSxmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksdC5zdG9wUHJvcGFnYXRpb24oKSx6ZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwocCh0aGlzKSxcInRvZ2dsZVwiKX0pLm9uKEFlLkNMSUNLX0RBVEFfQVBJLFJlLGZ1bmN0aW9uKHQpe3Quc3RvcFByb3BhZ2F0aW9uKCl9KSxwLmZuW3dlXT16ZS5falF1ZXJ5SW50ZXJmYWNlLHAuZm5bd2VdLkNvbnN0cnVjdG9yPXplLHAuZm5bd2VdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gcC5mblt3ZV09RGUsemUuX2pRdWVyeUludGVyZmFjZX07dmFyIEdlPVwibW9kYWxcIixKZT1cImJzLm1vZGFsXCIsWmU9XCIuXCIrSmUsJGU9cC5mbltHZV0sdG49e2JhY2tkcm9wOiEwLGtleWJvYXJkOiEwLGZvY3VzOiEwLHNob3c6ITB9LGVuPXtiYWNrZHJvcDpcIihib29sZWFufHN0cmluZylcIixrZXlib2FyZDpcImJvb2xlYW5cIixmb2N1czpcImJvb2xlYW5cIixzaG93OlwiYm9vbGVhblwifSxubj17SElERTpcImhpZGVcIitaZSxISURERU46XCJoaWRkZW5cIitaZSxTSE9XOlwic2hvd1wiK1plLFNIT1dOOlwic2hvd25cIitaZSxGT0NVU0lOOlwiZm9jdXNpblwiK1plLFJFU0laRTpcInJlc2l6ZVwiK1plLENMSUNLX0RJU01JU1M6XCJjbGljay5kaXNtaXNzXCIrWmUsS0VZRE9XTl9ESVNNSVNTOlwia2V5ZG93bi5kaXNtaXNzXCIrWmUsTU9VU0VVUF9ESVNNSVNTOlwibW91c2V1cC5kaXNtaXNzXCIrWmUsTU9VU0VET1dOX0RJU01JU1M6XCJtb3VzZWRvd24uZGlzbWlzc1wiK1plLENMSUNLX0RBVEFfQVBJOlwiY2xpY2tcIitaZStcIi5kYXRhLWFwaVwifSxvbj1cIm1vZGFsLXNjcm9sbGJhci1tZWFzdXJlXCIscm49XCJtb2RhbC1iYWNrZHJvcFwiLHNuPVwibW9kYWwtb3BlblwiLGFuPVwiZmFkZVwiLGxuPVwic2hvd1wiLGNuPVwiLm1vZGFsLWRpYWxvZ1wiLGhuPSdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsdW49J1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsZm49XCIuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wXCIsZG49XCIuc3RpY2t5LXRvcFwiLHBuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbyh0LGUpe3RoaXMuX2NvbmZpZz10aGlzLl9nZXRDb25maWcoZSksdGhpcy5fZWxlbWVudD10LHRoaXMuX2RpYWxvZz10LnF1ZXJ5U2VsZWN0b3IoY24pLHRoaXMuX2JhY2tkcm9wPW51bGwsdGhpcy5faXNTaG93bj0hMSx0aGlzLl9pc0JvZHlPdmVyZmxvd2luZz0hMSx0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrPSExLHRoaXMuX2lzVHJhbnNpdGlvbmluZz0hMSx0aGlzLl9zY3JvbGxiYXJXaWR0aD0wfXZhciB0PW8ucHJvdG90eXBlO3JldHVybiB0LnRvZ2dsZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5faXNTaG93bj90aGlzLmhpZGUoKTp0aGlzLnNob3codCl9LHQuc2hvdz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKCF0aGlzLl9pc1Nob3duJiYhdGhpcy5faXNUcmFuc2l0aW9uaW5nKXtwKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKGFuKSYmKHRoaXMuX2lzVHJhbnNpdGlvbmluZz0hMCk7dmFyIG49cC5FdmVudChubi5TSE9XLHtyZWxhdGVkVGFyZ2V0OnR9KTtwKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIobiksdGhpcy5faXNTaG93bnx8bi5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KHRoaXMuX2lzU2hvd249ITAsdGhpcy5fY2hlY2tTY3JvbGxiYXIoKSx0aGlzLl9zZXRTY3JvbGxiYXIoKSx0aGlzLl9hZGp1c3REaWFsb2coKSx0aGlzLl9zZXRFc2NhcGVFdmVudCgpLHRoaXMuX3NldFJlc2l6ZUV2ZW50KCkscCh0aGlzLl9lbGVtZW50KS5vbihubi5DTElDS19ESVNNSVNTLHVuLGZ1bmN0aW9uKHQpe3JldHVybiBlLmhpZGUodCl9KSxwKHRoaXMuX2RpYWxvZykub24obm4uTU9VU0VET1dOX0RJU01JU1MsZnVuY3Rpb24oKXtwKGUuX2VsZW1lbnQpLm9uZShubi5NT1VTRVVQX0RJU01JU1MsZnVuY3Rpb24odCl7cCh0LnRhcmdldCkuaXMoZS5fZWxlbWVudCkmJihlLl9pZ25vcmVCYWNrZHJvcENsaWNrPSEwKX0pfSksdGhpcy5fc2hvd0JhY2tkcm9wKGZ1bmN0aW9uKCl7cmV0dXJuIGUuX3Nob3dFbGVtZW50KHQpfSkpfX0sdC5oaWRlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYodCYmdC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuX2lzU2hvd24mJiF0aGlzLl9pc1RyYW5zaXRpb25pbmcpe3ZhciBuPXAuRXZlbnQobm4uSElERSk7aWYocCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKG4pLHRoaXMuX2lzU2hvd24mJiFuLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt0aGlzLl9pc1Nob3duPSExO3ZhciBpPXAodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoYW4pO2lmKGkmJih0aGlzLl9pc1RyYW5zaXRpb25pbmc9ITApLHRoaXMuX3NldEVzY2FwZUV2ZW50KCksdGhpcy5fc2V0UmVzaXplRXZlbnQoKSxwKGRvY3VtZW50KS5vZmYobm4uRk9DVVNJTikscCh0aGlzLl9lbGVtZW50KS5yZW1vdmVDbGFzcyhsbikscCh0aGlzLl9lbGVtZW50KS5vZmYobm4uQ0xJQ0tfRElTTUlTUykscCh0aGlzLl9kaWFsb2cpLm9mZihubi5NT1VTRURPV05fRElTTUlTUyksaSl7dmFyIG89bS5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtwKHRoaXMuX2VsZW1lbnQpLm9uZShtLlRSQU5TSVRJT05fRU5ELGZ1bmN0aW9uKHQpe3JldHVybiBlLl9oaWRlTW9kYWwodCl9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChvKX1lbHNlIHRoaXMuX2hpZGVNb2RhbCgpfX19LHQuZGlzcG9zZT1mdW5jdGlvbigpe1t3aW5kb3csdGhpcy5fZWxlbWVudCx0aGlzLl9kaWFsb2ddLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHAodCkub2ZmKFplKX0pLHAoZG9jdW1lbnQpLm9mZihubi5GT0NVU0lOKSxwLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCxKZSksdGhpcy5fY29uZmlnPW51bGwsdGhpcy5fZWxlbWVudD1udWxsLHRoaXMuX2RpYWxvZz1udWxsLHRoaXMuX2JhY2tkcm9wPW51bGwsdGhpcy5faXNTaG93bj1udWxsLHRoaXMuX2lzQm9keU92ZXJmbG93aW5nPW51bGwsdGhpcy5faWdub3JlQmFja2Ryb3BDbGljaz1udWxsLHRoaXMuX2lzVHJhbnNpdGlvbmluZz1udWxsLHRoaXMuX3Njcm9sbGJhcldpZHRoPW51bGx9LHQuaGFuZGxlVXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5fYWRqdXN0RGlhbG9nKCl9LHQuX2dldENvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4gdD1sKHt9LHRuLHQpLG0udHlwZUNoZWNrQ29uZmlnKEdlLHQsZW4pLHR9LHQuX3Nob3dFbGVtZW50PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1wKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKGFuKTt0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUmJnRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFfHxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpLHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSx0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwhMCksdGhpcy5fZWxlbWVudC5zY3JvbGxUb3A9MCxuJiZtLnJlZmxvdyh0aGlzLl9lbGVtZW50KSxwKHRoaXMuX2VsZW1lbnQpLmFkZENsYXNzKGxuKSx0aGlzLl9jb25maWcuZm9jdXMmJnRoaXMuX2VuZm9yY2VGb2N1cygpO3ZhciBpPXAuRXZlbnQobm4uU0hPV04se3JlbGF0ZWRUYXJnZXQ6dH0pLG89ZnVuY3Rpb24oKXtlLl9jb25maWcuZm9jdXMmJmUuX2VsZW1lbnQuZm9jdXMoKSxlLl9pc1RyYW5zaXRpb25pbmc9ITEscChlLl9lbGVtZW50KS50cmlnZ2VyKGkpfTtpZihuKXt2YXIgcj1tLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2RpYWxvZyk7cCh0aGlzLl9kaWFsb2cpLm9uZShtLlRSQU5TSVRJT05fRU5ELG8pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHIpfWVsc2UgbygpfSx0Ll9lbmZvcmNlRm9jdXM9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3AoZG9jdW1lbnQpLm9mZihubi5GT0NVU0lOKS5vbihubi5GT0NVU0lOLGZ1bmN0aW9uKHQpe2RvY3VtZW50IT09dC50YXJnZXQmJmUuX2VsZW1lbnQhPT10LnRhcmdldCYmMD09PXAoZS5fZWxlbWVudCkuaGFzKHQudGFyZ2V0KS5sZW5ndGgmJmUuX2VsZW1lbnQuZm9jdXMoKX0pfSx0Ll9zZXRFc2NhcGVFdmVudD1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5faXNTaG93biYmdGhpcy5fY29uZmlnLmtleWJvYXJkP3AodGhpcy5fZWxlbWVudCkub24obm4uS0VZRE9XTl9ESVNNSVNTLGZ1bmN0aW9uKHQpezI3PT09dC53aGljaCYmKHQucHJldmVudERlZmF1bHQoKSxlLmhpZGUoKSl9KTp0aGlzLl9pc1Nob3dufHxwKHRoaXMuX2VsZW1lbnQpLm9mZihubi5LRVlET1dOX0RJU01JU1MpfSx0Ll9zZXRSZXNpemVFdmVudD1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5faXNTaG93bj9wKHdpbmRvdykub24obm4uUkVTSVpFLGZ1bmN0aW9uKHQpe3JldHVybiBlLmhhbmRsZVVwZGF0ZSh0KX0pOnAod2luZG93KS5vZmYobm4uUkVTSVpFKX0sdC5faGlkZU1vZGFsPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCEwKSx0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiksdGhpcy5faXNUcmFuc2l0aW9uaW5nPSExLHRoaXMuX3Nob3dCYWNrZHJvcChmdW5jdGlvbigpe3AoZG9jdW1lbnQuYm9keSkucmVtb3ZlQ2xhc3Moc24pLHQuX3Jlc2V0QWRqdXN0bWVudHMoKSx0Ll9yZXNldFNjcm9sbGJhcigpLHAodC5fZWxlbWVudCkudHJpZ2dlcihubi5ISURERU4pfSl9LHQuX3JlbW92ZUJhY2tkcm9wPWZ1bmN0aW9uKCl7dGhpcy5fYmFja2Ryb3AmJihwKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmUoKSx0aGlzLl9iYWNrZHJvcD1udWxsKX0sdC5fc2hvd0JhY2tkcm9wPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1wKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKGFuKT9hbjpcIlwiO2lmKHRoaXMuX2lzU2hvd24mJnRoaXMuX2NvbmZpZy5iYWNrZHJvcCl7aWYodGhpcy5fYmFja2Ryb3A9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl9iYWNrZHJvcC5jbGFzc05hbWU9cm4sbiYmdGhpcy5fYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChuKSxwKHRoaXMuX2JhY2tkcm9wKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KSxwKHRoaXMuX2VsZW1lbnQpLm9uKG5uLkNMSUNLX0RJU01JU1MsZnVuY3Rpb24odCl7ZS5faWdub3JlQmFja2Ryb3BDbGljaz9lLl9pZ25vcmVCYWNrZHJvcENsaWNrPSExOnQudGFyZ2V0PT09dC5jdXJyZW50VGFyZ2V0JiYoXCJzdGF0aWNcIj09PWUuX2NvbmZpZy5iYWNrZHJvcD9lLl9lbGVtZW50LmZvY3VzKCk6ZS5oaWRlKCkpfSksbiYmbS5yZWZsb3codGhpcy5fYmFja2Ryb3ApLHAodGhpcy5fYmFja2Ryb3ApLmFkZENsYXNzKGxuKSwhdClyZXR1cm47aWYoIW4pcmV0dXJuIHZvaWQgdCgpO3ZhciBpPW0uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fYmFja2Ryb3ApO3AodGhpcy5fYmFja2Ryb3ApLm9uZShtLlRSQU5TSVRJT05fRU5ELHQpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGkpfWVsc2UgaWYoIXRoaXMuX2lzU2hvd24mJnRoaXMuX2JhY2tkcm9wKXtwKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmVDbGFzcyhsbik7dmFyIG89ZnVuY3Rpb24oKXtlLl9yZW1vdmVCYWNrZHJvcCgpLHQmJnQoKX07aWYocCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhhbikpe3ZhciByPW0uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fYmFja2Ryb3ApO3AodGhpcy5fYmFja2Ryb3ApLm9uZShtLlRSQU5TSVRJT05fRU5ELG8pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHIpfWVsc2UgbygpfWVsc2UgdCYmdCgpfSx0Ll9hZGp1c3REaWFsb2c9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodD5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0OyF0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyYmdCYmKHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQ9dGhpcy5fc2Nyb2xsYmFyV2lkdGgrXCJweFwiKSx0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyYmIXQmJih0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodD10aGlzLl9zY3JvbGxiYXJXaWR0aCtcInB4XCIpfSx0Ll9yZXNldEFkanVzdG1lbnRzPWZ1bmN0aW9uKCl7dGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdD1cIlwiLHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0PVwiXCJ9LHQuX2NoZWNrU2Nyb2xsYmFyPWZ1bmN0aW9uKCl7dmFyIHQ9ZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0aGlzLl9pc0JvZHlPdmVyZmxvd2luZz10LmxlZnQrdC5yaWdodDx3aW5kb3cuaW5uZXJXaWR0aCx0aGlzLl9zY3JvbGxiYXJXaWR0aD10aGlzLl9nZXRTY3JvbGxiYXJXaWR0aCgpfSx0Ll9zZXRTY3JvbGxiYXI9ZnVuY3Rpb24oKXt2YXIgbz10aGlzO2lmKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nKXt2YXIgdD1bXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZm4pKSxlPVtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkbikpO3AodCkuZWFjaChmdW5jdGlvbih0LGUpe3ZhciBuPWUuc3R5bGUucGFkZGluZ1JpZ2h0LGk9cChlKS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpO3AoZSkuZGF0YShcInBhZGRpbmctcmlnaHRcIixuKS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIscGFyc2VGbG9hdChpKStvLl9zY3JvbGxiYXJXaWR0aCtcInB4XCIpfSkscChlKS5lYWNoKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zdHlsZS5tYXJnaW5SaWdodCxpPXAoZSkuY3NzKFwibWFyZ2luLXJpZ2h0XCIpO3AoZSkuZGF0YShcIm1hcmdpbi1yaWdodFwiLG4pLmNzcyhcIm1hcmdpbi1yaWdodFwiLHBhcnNlRmxvYXQoaSktby5fc2Nyb2xsYmFyV2lkdGgrXCJweFwiKX0pO3ZhciBuPWRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0LGk9cChkb2N1bWVudC5ib2R5KS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpO3AoZG9jdW1lbnQuYm9keSkuZGF0YShcInBhZGRpbmctcmlnaHRcIixuKS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIscGFyc2VGbG9hdChpKSt0aGlzLl9zY3JvbGxiYXJXaWR0aCtcInB4XCIpfXAoZG9jdW1lbnQuYm9keSkuYWRkQ2xhc3Moc24pfSx0Ll9yZXNldFNjcm9sbGJhcj1mdW5jdGlvbigpe3ZhciB0PVtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChmbikpO3AodCkuZWFjaChmdW5jdGlvbih0LGUpe3ZhciBuPXAoZSkuZGF0YShcInBhZGRpbmctcmlnaHRcIik7cChlKS5yZW1vdmVEYXRhKFwicGFkZGluZy1yaWdodFwiKSxlLnN0eWxlLnBhZGRpbmdSaWdodD1ufHxcIlwifSk7dmFyIGU9W10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiXCIrZG4pKTtwKGUpLmVhY2goZnVuY3Rpb24odCxlKXt2YXIgbj1wKGUpLmRhdGEoXCJtYXJnaW4tcmlnaHRcIik7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG4mJnAoZSkuY3NzKFwibWFyZ2luLXJpZ2h0XCIsbikucmVtb3ZlRGF0YShcIm1hcmdpbi1yaWdodFwiKX0pO3ZhciBuPXAoZG9jdW1lbnQuYm9keSkuZGF0YShcInBhZGRpbmctcmlnaHRcIik7cChkb2N1bWVudC5ib2R5KS5yZW1vdmVEYXRhKFwicGFkZGluZy1yaWdodFwiKSxkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodD1ufHxcIlwifSx0Ll9nZXRTY3JvbGxiYXJXaWR0aD1mdW5jdGlvbigpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dC5jbGFzc05hbWU9b24sZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KTt2YXIgZT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLXQuY2xpZW50V2lkdGg7cmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodCksZX0sby5falF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKG4saSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PXAodGhpcykuZGF0YShKZSksZT1sKHt9LHRuLHAodGhpcykuZGF0YSgpLFwib2JqZWN0XCI9PXR5cGVvZiBuJiZuP246e30pO2lmKHR8fCh0PW5ldyBvKHRoaXMsZSkscCh0aGlzKS5kYXRhKEplLHQpKSxcInN0cmluZ1wiPT10eXBlb2Ygbil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHRbbl0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytuKydcIicpO3Rbbl0oaSl9ZWxzZSBlLnNob3cmJnQuc2hvdyhpKX0pfSxzKG8sbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMi4xXCJ9fSx7a2V5OlwiRGVmYXVsdFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0bn19XSksb30oKTtwKGRvY3VtZW50KS5vbihubi5DTElDS19EQVRBX0FQSSxobixmdW5jdGlvbih0KXt2YXIgZSxuPXRoaXMsaT1tLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7aSYmKGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihpKSk7dmFyIG89cChlKS5kYXRhKEplKT9cInRvZ2dsZVwiOmwoe30scChlKS5kYXRhKCkscCh0aGlzKS5kYXRhKCkpO1wiQVwiIT09dGhpcy50YWdOYW1lJiZcIkFSRUFcIiE9PXRoaXMudGFnTmFtZXx8dC5wcmV2ZW50RGVmYXVsdCgpO3ZhciByPXAoZSkub25lKG5uLlNIT1csZnVuY3Rpb24odCl7dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8ci5vbmUobm4uSElEREVOLGZ1bmN0aW9uKCl7cChuKS5pcyhcIjp2aXNpYmxlXCIpJiZuLmZvY3VzKCl9KX0pO3BuLl9qUXVlcnlJbnRlcmZhY2UuY2FsbChwKGUpLG8sdGhpcyl9KSxwLmZuW0dlXT1wbi5falF1ZXJ5SW50ZXJmYWNlLHAuZm5bR2VdLkNvbnN0cnVjdG9yPXBuLHAuZm5bR2VdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gcC5mbltHZV09JGUscG4uX2pRdWVyeUludGVyZmFjZX07dmFyIG1uPVwidG9vbHRpcFwiLGduPVwiYnMudG9vbHRpcFwiLF9uPVwiLlwiK2duLHZuPXAuZm5bbW5dLHluPVwiYnMtdG9vbHRpcFwiLEVuPW5ldyBSZWdFeHAoXCIoXnxcXFxccylcIit5bitcIlxcXFxTK1wiLFwiZ1wiKSxibj17YW5pbWF0aW9uOlwiYm9vbGVhblwiLHRlbXBsYXRlOlwic3RyaW5nXCIsdGl0bGU6XCIoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pXCIsdHJpZ2dlcjpcInN0cmluZ1wiLGRlbGF5OlwiKG51bWJlcnxvYmplY3QpXCIsaHRtbDpcImJvb2xlYW5cIixzZWxlY3RvcjpcIihzdHJpbmd8Ym9vbGVhbilcIixwbGFjZW1lbnQ6XCIoc3RyaW5nfGZ1bmN0aW9uKVwiLG9mZnNldDpcIihudW1iZXJ8c3RyaW5nKVwiLGNvbnRhaW5lcjpcIihzdHJpbmd8ZWxlbWVudHxib29sZWFuKVwiLGZhbGxiYWNrUGxhY2VtZW50OlwiKHN0cmluZ3xhcnJheSlcIixib3VuZGFyeTpcIihzdHJpbmd8ZWxlbWVudClcIn0sd249e0FVVE86XCJhdXRvXCIsVE9QOlwidG9wXCIsUklHSFQ6XCJyaWdodFwiLEJPVFRPTTpcImJvdHRvbVwiLExFRlQ6XCJsZWZ0XCJ9LFRuPXthbmltYXRpb246ITAsdGVtcGxhdGU6JzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj48ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PjwvZGl2PicsdHJpZ2dlcjpcImhvdmVyIGZvY3VzXCIsdGl0bGU6XCJcIixkZWxheTowLGh0bWw6ITEsc2VsZWN0b3I6ITEscGxhY2VtZW50OlwidG9wXCIsb2Zmc2V0OjAsY29udGFpbmVyOiExLGZhbGxiYWNrUGxhY2VtZW50OlwiZmxpcFwiLGJvdW5kYXJ5Olwic2Nyb2xsUGFyZW50XCJ9LENuPVwic2hvd1wiLFNuPVwib3V0XCIsRG49e0hJREU6XCJoaWRlXCIrX24sSElEREVOOlwiaGlkZGVuXCIrX24sU0hPVzpcInNob3dcIitfbixTSE9XTjpcInNob3duXCIrX24sSU5TRVJURUQ6XCJpbnNlcnRlZFwiK19uLENMSUNLOlwiY2xpY2tcIitfbixGT0NVU0lOOlwiZm9jdXNpblwiK19uLEZPQ1VTT1VUOlwiZm9jdXNvdXRcIitfbixNT1VTRUVOVEVSOlwibW91c2VlbnRlclwiK19uLE1PVVNFTEVBVkU6XCJtb3VzZWxlYXZlXCIrX259LEluPVwiZmFkZVwiLEFuPVwic2hvd1wiLE9uPVwiLnRvb2x0aXAtaW5uZXJcIixObj1cIi5hcnJvd1wiLGtuPVwiaG92ZXJcIixMbj1cImZvY3VzXCIsUG49XCJjbGlja1wiLHhuPVwibWFudWFsXCIsSG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBpKHQsZSl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGJlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJCb290c3RyYXAncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlci5qcyAoaHR0cHM6Ly9wb3BwZXIuanMub3JnLylcIik7dGhpcy5faXNFbmFibGVkPSEwLHRoaXMuX3RpbWVvdXQ9MCx0aGlzLl9ob3ZlclN0YXRlPVwiXCIsdGhpcy5fYWN0aXZlVHJpZ2dlcj17fSx0aGlzLl9wb3BwZXI9bnVsbCx0aGlzLmVsZW1lbnQ9dCx0aGlzLmNvbmZpZz10aGlzLl9nZXRDb25maWcoZSksdGhpcy50aXA9bnVsbCx0aGlzLl9zZXRMaXN0ZW5lcnMoKX12YXIgdD1pLnByb3RvdHlwZTtyZXR1cm4gdC5lbmFibGU9ZnVuY3Rpb24oKXt0aGlzLl9pc0VuYWJsZWQ9ITB9LHQuZGlzYWJsZT1mdW5jdGlvbigpe3RoaXMuX2lzRW5hYmxlZD0hMX0sdC50b2dnbGVFbmFibGVkPWZ1bmN0aW9uKCl7dGhpcy5faXNFbmFibGVkPSF0aGlzLl9pc0VuYWJsZWR9LHQudG9nZ2xlPWZ1bmN0aW9uKHQpe2lmKHRoaXMuX2lzRW5hYmxlZClpZih0KXt2YXIgZT10aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLG49cCh0LmN1cnJlbnRUYXJnZXQpLmRhdGEoZSk7bnx8KG49bmV3IHRoaXMuY29uc3RydWN0b3IodC5jdXJyZW50VGFyZ2V0LHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpLHAodC5jdXJyZW50VGFyZ2V0KS5kYXRhKGUsbikpLG4uX2FjdGl2ZVRyaWdnZXIuY2xpY2s9IW4uX2FjdGl2ZVRyaWdnZXIuY2xpY2ssbi5faXNXaXRoQWN0aXZlVHJpZ2dlcigpP24uX2VudGVyKG51bGwsbik6bi5fbGVhdmUobnVsbCxuKX1lbHNle2lmKHAodGhpcy5nZXRUaXBFbGVtZW50KCkpLmhhc0NsYXNzKEFuKSlyZXR1cm4gdm9pZCB0aGlzLl9sZWF2ZShudWxsLHRoaXMpO3RoaXMuX2VudGVyKG51bGwsdGhpcyl9fSx0LmRpc3Bvc2U9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCkscC5yZW1vdmVEYXRhKHRoaXMuZWxlbWVudCx0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKSxwKHRoaXMuZWxlbWVudCkub2ZmKHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKSxwKHRoaXMuZWxlbWVudCkuY2xvc2VzdChcIi5tb2RhbFwiKS5vZmYoXCJoaWRlLmJzLm1vZGFsXCIpLHRoaXMudGlwJiZwKHRoaXMudGlwKS5yZW1vdmUoKSx0aGlzLl9pc0VuYWJsZWQ9bnVsbCx0aGlzLl90aW1lb3V0PW51bGwsdGhpcy5faG92ZXJTdGF0ZT1udWxsLCh0aGlzLl9hY3RpdmVUcmlnZ2VyPW51bGwpIT09dGhpcy5fcG9wcGVyJiZ0aGlzLl9wb3BwZXIuZGVzdHJveSgpLHRoaXMuX3BvcHBlcj1udWxsLHRoaXMuZWxlbWVudD1udWxsLHRoaXMuY29uZmlnPW51bGwsdGhpcy50aXA9bnVsbH0sdC5zaG93PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZihcIm5vbmVcIj09PXAodGhpcy5lbGVtZW50KS5jc3MoXCJkaXNwbGF5XCIpKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzXCIpO3ZhciB0PXAuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XKTtpZih0aGlzLmlzV2l0aENvbnRlbnQoKSYmdGhpcy5faXNFbmFibGVkKXtwKHRoaXMuZWxlbWVudCkudHJpZ2dlcih0KTt2YXIgbj1tLmZpbmRTaGFkb3dSb290KHRoaXMuZWxlbWVudCksaT1wLmNvbnRhaW5zKG51bGwhPT1uP246dGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHRoaXMuZWxlbWVudCk7aWYodC5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8IWkpcmV0dXJuO3ZhciBvPXRoaXMuZ2V0VGlwRWxlbWVudCgpLHI9bS5nZXRVSUQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKTtvLnNldEF0dHJpYnV0ZShcImlkXCIsciksdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIixyKSx0aGlzLnNldENvbnRlbnQoKSx0aGlzLmNvbmZpZy5hbmltYXRpb24mJnAobykuYWRkQ2xhc3MoSW4pO3ZhciBzPVwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuY29uZmlnLnBsYWNlbWVudD90aGlzLmNvbmZpZy5wbGFjZW1lbnQuY2FsbCh0aGlzLG8sdGhpcy5lbGVtZW50KTp0aGlzLmNvbmZpZy5wbGFjZW1lbnQsYT10aGlzLl9nZXRBdHRhY2htZW50KHMpO3RoaXMuYWRkQXR0YWNobWVudENsYXNzKGEpO3ZhciBsPXRoaXMuX2dldENvbnRhaW5lcigpO3AobykuZGF0YSh0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLHRoaXMpLHAuY29udGFpbnModGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHRoaXMudGlwKXx8cChvKS5hcHBlbmRUbyhsKSxwKHRoaXMuZWxlbWVudCkudHJpZ2dlcih0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKSx0aGlzLl9wb3BwZXI9bmV3IGJlKHRoaXMuZWxlbWVudCxvLHtwbGFjZW1lbnQ6YSxtb2RpZmllcnM6e29mZnNldDp7b2Zmc2V0OnRoaXMuY29uZmlnLm9mZnNldH0sZmxpcDp7YmVoYXZpb3I6dGhpcy5jb25maWcuZmFsbGJhY2tQbGFjZW1lbnR9LGFycm93OntlbGVtZW50Ok5ufSxwcmV2ZW50T3ZlcmZsb3c6e2JvdW5kYXJpZXNFbGVtZW50OnRoaXMuY29uZmlnLmJvdW5kYXJ5fX0sb25DcmVhdGU6ZnVuY3Rpb24odCl7dC5vcmlnaW5hbFBsYWNlbWVudCE9PXQucGxhY2VtZW50JiZlLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UodCl9LG9uVXBkYXRlOmZ1bmN0aW9uKHQpe3JldHVybiBlLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UodCl9fSkscChvKS5hZGRDbGFzcyhBbiksXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmcChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9uKFwibW91c2VvdmVyXCIsbnVsbCxwLm5vb3ApO3ZhciBjPWZ1bmN0aW9uKCl7ZS5jb25maWcuYW5pbWF0aW9uJiZlLl9maXhUcmFuc2l0aW9uKCk7dmFyIHQ9ZS5faG92ZXJTdGF0ZTtlLl9ob3ZlclN0YXRlPW51bGwscChlLmVsZW1lbnQpLnRyaWdnZXIoZS5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTiksdD09PVNuJiZlLl9sZWF2ZShudWxsLGUpfTtpZihwKHRoaXMudGlwKS5oYXNDbGFzcyhJbikpe3ZhciBoPW0uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy50aXApO3AodGhpcy50aXApLm9uZShtLlRSQU5TSVRJT05fRU5ELGMpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGgpfWVsc2UgYygpfX0sdC5oaWRlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj10aGlzLmdldFRpcEVsZW1lbnQoKSxpPXAuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFKSxvPWZ1bmN0aW9uKCl7ZS5faG92ZXJTdGF0ZSE9PUNuJiZuLnBhcmVudE5vZGUmJm4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKSxlLl9jbGVhblRpcENsYXNzKCksZS5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIikscChlLmVsZW1lbnQpLnRyaWdnZXIoZS5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pLG51bGwhPT1lLl9wb3BwZXImJmUuX3BvcHBlci5kZXN0cm95KCksdCYmdCgpfTtpZihwKHRoaXMuZWxlbWVudCkudHJpZ2dlcihpKSwhaS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSl7aWYocChuKS5yZW1vdmVDbGFzcyhBbiksXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmcChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9mZihcIm1vdXNlb3ZlclwiLG51bGwscC5ub29wKSx0aGlzLl9hY3RpdmVUcmlnZ2VyW1BuXT0hMSx0aGlzLl9hY3RpdmVUcmlnZ2VyW0xuXT0hMSx0aGlzLl9hY3RpdmVUcmlnZ2VyW2tuXT0hMSxwKHRoaXMudGlwKS5oYXNDbGFzcyhJbikpe3ZhciByPW0uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQobik7cChuKS5vbmUobS5UUkFOU0lUSU9OX0VORCxvKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChyKX1lbHNlIG8oKTt0aGlzLl9ob3ZlclN0YXRlPVwiXCJ9fSx0LnVwZGF0ZT1mdW5jdGlvbigpe251bGwhPT10aGlzLl9wb3BwZXImJnRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpfSx0LmlzV2l0aENvbnRlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbih0aGlzLmdldFRpdGxlKCkpfSx0LmFkZEF0dGFjaG1lbnRDbGFzcz1mdW5jdGlvbih0KXtwKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyh5bitcIi1cIit0KX0sdC5nZXRUaXBFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGlwPXRoaXMudGlwfHxwKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXSx0aGlzLnRpcH0sdC5zZXRDb250ZW50PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRUaXBFbGVtZW50KCk7dGhpcy5zZXRFbGVtZW50Q29udGVudChwKHQucXVlcnlTZWxlY3RvckFsbChPbikpLHRoaXMuZ2V0VGl0bGUoKSkscCh0KS5yZW1vdmVDbGFzcyhJbitcIiBcIitBbil9LHQuc2V0RWxlbWVudENvbnRlbnQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmNvbmZpZy5odG1sO1wib2JqZWN0XCI9PXR5cGVvZiBlJiYoZS5ub2RlVHlwZXx8ZS5qcXVlcnkpP24/cChlKS5wYXJlbnQoKS5pcyh0KXx8dC5lbXB0eSgpLmFwcGVuZChlKTp0LnRleHQocChlKS50ZXh0KCkpOnRbbj9cImh0bWxcIjpcInRleHRcIl0oZSl9LHQuZ2V0VGl0bGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiKTtyZXR1cm4gdHx8KHQ9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5jb25maWcudGl0bGU/dGhpcy5jb25maWcudGl0bGUuY2FsbCh0aGlzLmVsZW1lbnQpOnRoaXMuY29uZmlnLnRpdGxlKSx0fSx0Ll9nZXRDb250YWluZXI9ZnVuY3Rpb24oKXtyZXR1cm4hMT09PXRoaXMuY29uZmlnLmNvbnRhaW5lcj9kb2N1bWVudC5ib2R5Om0uaXNFbGVtZW50KHRoaXMuY29uZmlnLmNvbnRhaW5lcik/cCh0aGlzLmNvbmZpZy5jb250YWluZXIpOnAoZG9jdW1lbnQpLmZpbmQodGhpcy5jb25maWcuY29udGFpbmVyKX0sdC5fZ2V0QXR0YWNobWVudD1mdW5jdGlvbih0KXtyZXR1cm4gd25bdC50b1VwcGVyQ2FzZSgpXX0sdC5fc2V0TGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIGk9dGhpczt0aGlzLmNvbmZpZy50cmlnZ2VyLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKFwiY2xpY2tcIj09PXQpcChpLmVsZW1lbnQpLm9uKGkuY29uc3RydWN0b3IuRXZlbnQuQ0xJQ0ssaS5jb25maWcuc2VsZWN0b3IsZnVuY3Rpb24odCl7cmV0dXJuIGkudG9nZ2xlKHQpfSk7ZWxzZSBpZih0IT09eG4pe3ZhciBlPXQ9PT1rbj9pLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFRU5URVI6aS5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU0lOLG49dD09PWtuP2kuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VMRUFWRTppLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUO3AoaS5lbGVtZW50KS5vbihlLGkuY29uZmlnLnNlbGVjdG9yLGZ1bmN0aW9uKHQpe3JldHVybiBpLl9lbnRlcih0KX0pLm9uKG4saS5jb25maWcuc2VsZWN0b3IsZnVuY3Rpb24odCl7cmV0dXJuIGkuX2xlYXZlKHQpfSl9fSkscCh0aGlzLmVsZW1lbnQpLmNsb3Nlc3QoXCIubW9kYWxcIikub24oXCJoaWRlLmJzLm1vZGFsXCIsZnVuY3Rpb24oKXtpLmVsZW1lbnQmJmkuaGlkZSgpfSksdGhpcy5jb25maWcuc2VsZWN0b3I/dGhpcy5jb25maWc9bCh7fSx0aGlzLmNvbmZpZyx7dHJpZ2dlcjpcIm1hbnVhbFwiLHNlbGVjdG9yOlwiXCJ9KTp0aGlzLl9maXhUaXRsZSgpfSx0Ll9maXhUaXRsZT1mdW5jdGlvbigpe3ZhciB0PXR5cGVvZiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiKTsodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInRpdGxlXCIpfHxcInN0cmluZ1wiIT09dCkmJih0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiLHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKXx8XCJcIiksdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcInRpdGxlXCIsXCJcIikpfSx0Ll9lbnRlcj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7KGU9ZXx8cCh0LmN1cnJlbnRUYXJnZXQpLmRhdGEobikpfHwoZT1uZXcgdGhpcy5jb25zdHJ1Y3Rvcih0LmN1cnJlbnRUYXJnZXQsdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSkscCh0LmN1cnJlbnRUYXJnZXQpLmRhdGEobixlKSksdCYmKGUuX2FjdGl2ZVRyaWdnZXJbXCJmb2N1c2luXCI9PT10LnR5cGU/TG46a25dPSEwKSxwKGUuZ2V0VGlwRWxlbWVudCgpKS5oYXNDbGFzcyhBbil8fGUuX2hvdmVyU3RhdGU9PT1Dbj9lLl9ob3ZlclN0YXRlPUNuOihjbGVhclRpbWVvdXQoZS5fdGltZW91dCksZS5faG92ZXJTdGF0ZT1DbixlLmNvbmZpZy5kZWxheSYmZS5jb25maWcuZGVsYXkuc2hvdz9lLl90aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl9ob3ZlclN0YXRlPT09Q24mJmUuc2hvdygpfSxlLmNvbmZpZy5kZWxheS5zaG93KTplLnNob3coKSl9LHQuX2xlYXZlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWTsoZT1lfHxwKHQuY3VycmVudFRhcmdldCkuZGF0YShuKSl8fChlPW5ldyB0aGlzLmNvbnN0cnVjdG9yKHQuY3VycmVudFRhcmdldCx0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKSxwKHQuY3VycmVudFRhcmdldCkuZGF0YShuLGUpKSx0JiYoZS5fYWN0aXZlVHJpZ2dlcltcImZvY3Vzb3V0XCI9PT10LnR5cGU/TG46a25dPSExKSxlLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCl8fChjbGVhclRpbWVvdXQoZS5fdGltZW91dCksZS5faG92ZXJTdGF0ZT1TbixlLmNvbmZpZy5kZWxheSYmZS5jb25maWcuZGVsYXkuaGlkZT9lLl90aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl9ob3ZlclN0YXRlPT09U24mJmUuaGlkZSgpfSxlLmNvbmZpZy5kZWxheS5oaWRlKTplLmhpZGUoKSl9LHQuX2lzV2l0aEFjdGl2ZVRyaWdnZXI9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5fYWN0aXZlVHJpZ2dlcilpZih0aGlzLl9hY3RpdmVUcmlnZ2VyW3RdKXJldHVybiEwO3JldHVybiExfSx0Ll9nZXRDb25maWc9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mKHQ9bCh7fSx0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQscCh0aGlzLmVsZW1lbnQpLmRhdGEoKSxcIm9iamVjdFwiPT10eXBlb2YgdCYmdD90Ont9KSkuZGVsYXkmJih0LmRlbGF5PXtzaG93OnQuZGVsYXksaGlkZTp0LmRlbGF5fSksXCJudW1iZXJcIj09dHlwZW9mIHQudGl0bGUmJih0LnRpdGxlPXQudGl0bGUudG9TdHJpbmcoKSksXCJudW1iZXJcIj09dHlwZW9mIHQuY29udGVudCYmKHQuY29udGVudD10LmNvbnRlbnQudG9TdHJpbmcoKSksbS50eXBlQ2hlY2tDb25maWcobW4sdCx0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSx0fSx0Ll9nZXREZWxlZ2F0ZUNvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt9O2lmKHRoaXMuY29uZmlnKWZvcih2YXIgZSBpbiB0aGlzLmNvbmZpZyl0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRbZV0hPT10aGlzLmNvbmZpZ1tlXSYmKHRbZV09dGhpcy5jb25maWdbZV0pO3JldHVybiB0fSx0Ll9jbGVhblRpcENsYXNzPWZ1bmN0aW9uKCl7dmFyIHQ9cCh0aGlzLmdldFRpcEVsZW1lbnQoKSksZT10LmF0dHIoXCJjbGFzc1wiKS5tYXRjaChFbik7bnVsbCE9PWUmJmUubGVuZ3RoJiZ0LnJlbW92ZUNsYXNzKGUuam9pbihcIlwiKSl9LHQuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZT1mdW5jdGlvbih0KXt2YXIgZT10Lmluc3RhbmNlO3RoaXMudGlwPWUucG9wcGVyLHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSx0aGlzLmFkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KHQucGxhY2VtZW50KSl9LHQuX2ZpeFRyYW5zaXRpb249ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldFRpcEVsZW1lbnQoKSxlPXRoaXMuY29uZmlnLmFuaW1hdGlvbjtudWxsPT09dC5nZXRBdHRyaWJ1dGUoXCJ4LXBsYWNlbWVudFwiKSYmKHAodCkucmVtb3ZlQ2xhc3MoSW4pLHRoaXMuY29uZmlnLmFuaW1hdGlvbj0hMSx0aGlzLmhpZGUoKSx0aGlzLnNob3coKSx0aGlzLmNvbmZpZy5hbmltYXRpb249ZSl9LGkuX2pRdWVyeUludGVyZmFjZT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9cCh0aGlzKS5kYXRhKGduKSxlPVwib2JqZWN0XCI9PXR5cGVvZiBuJiZuO2lmKCh0fHwhL2Rpc3Bvc2V8aGlkZS8udGVzdChuKSkmJih0fHwodD1uZXcgaSh0aGlzLGUpLHAodGhpcykuZGF0YShnbix0KSksXCJzdHJpbmdcIj09dHlwZW9mIG4pKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgdFtuXSl0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK24rJ1wiJyk7dFtuXSgpfX0pfSxzKGksbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMi4xXCJ9fSx7a2V5OlwiRGVmYXVsdFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBUbn19LHtrZXk6XCJOQU1FXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG1ufX0se2tleTpcIkRBVEFfS0VZXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGdufX0se2tleTpcIkV2ZW50XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIERufX0se2tleTpcIkVWRU5UX0tFWVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBfbn19LHtrZXk6XCJEZWZhdWx0VHlwZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBibn19XSksaX0oKTtwLmZuW21uXT1Ibi5falF1ZXJ5SW50ZXJmYWNlLHAuZm5bbW5dLkNvbnN0cnVjdG9yPUhuLHAuZm5bbW5dLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gcC5mblttbl09dm4sSG4uX2pRdWVyeUludGVyZmFjZX07dmFyIGpuPVwicG9wb3ZlclwiLFJuPVwiYnMucG9wb3ZlclwiLEZuPVwiLlwiK1JuLE1uPXAuZm5bam5dLFduPVwiYnMtcG9wb3ZlclwiLFVuPW5ldyBSZWdFeHAoXCIoXnxcXFxccylcIitXbitcIlxcXFxTK1wiLFwiZ1wiKSxCbj1sKHt9LEhuLkRlZmF1bHQse3BsYWNlbWVudDpcInJpZ2h0XCIsdHJpZ2dlcjpcImNsaWNrXCIsY29udGVudDpcIlwiLHRlbXBsYXRlOic8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+PGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj48L2gzPjxkaXYgY2xhc3M9XCJwb3BvdmVyLWJvZHlcIj48L2Rpdj48L2Rpdj4nfSkscW49bCh7fSxIbi5EZWZhdWx0VHlwZSx7Y29udGVudDpcIihzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbilcIn0pLEtuPVwiZmFkZVwiLFFuPVwic2hvd1wiLFluPVwiLnBvcG92ZXItaGVhZGVyXCIsVm49XCIucG9wb3Zlci1ib2R5XCIsWG49e0hJREU6XCJoaWRlXCIrRm4sSElEREVOOlwiaGlkZGVuXCIrRm4sU0hPVzpcInNob3dcIitGbixTSE9XTjpcInNob3duXCIrRm4sSU5TRVJURUQ6XCJpbnNlcnRlZFwiK0ZuLENMSUNLOlwiY2xpY2tcIitGbixGT0NVU0lOOlwiZm9jdXNpblwiK0ZuLEZPQ1VTT1VUOlwiZm9jdXNvdXRcIitGbixNT1VTRUVOVEVSOlwibW91c2VlbnRlclwiK0ZuLE1PVVNFTEVBVkU6XCJtb3VzZWxlYXZlXCIrRm59LHpuPWZ1bmN0aW9uKHQpe3ZhciBlLG47ZnVuY3Rpb24gaSgpe3JldHVybiB0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31uPXQsKGU9aSkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUobi5wcm90b3R5cGUpLChlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lKS5fX3Byb3RvX189bjt2YXIgbz1pLnByb3RvdHlwZTtyZXR1cm4gby5pc1dpdGhDb250ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VGl0bGUoKXx8dGhpcy5fZ2V0Q29udGVudCgpfSxvLmFkZEF0dGFjaG1lbnRDbGFzcz1mdW5jdGlvbih0KXtwKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyhXbitcIi1cIit0KX0sby5nZXRUaXBFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGlwPXRoaXMudGlwfHxwKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXSx0aGlzLnRpcH0sby5zZXRDb250ZW50PWZ1bmN0aW9uKCl7dmFyIHQ9cCh0aGlzLmdldFRpcEVsZW1lbnQoKSk7dGhpcy5zZXRFbGVtZW50Q29udGVudCh0LmZpbmQoWW4pLHRoaXMuZ2V0VGl0bGUoKSk7dmFyIGU9dGhpcy5fZ2V0Q29udGVudCgpO1wiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihlPWUuY2FsbCh0aGlzLmVsZW1lbnQpKSx0aGlzLnNldEVsZW1lbnRDb250ZW50KHQuZmluZChWbiksZSksdC5yZW1vdmVDbGFzcyhLbitcIiBcIitRbil9LG8uX2dldENvbnRlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY29udGVudFwiKXx8dGhpcy5jb25maWcuY29udGVudH0sby5fY2xlYW5UaXBDbGFzcz1mdW5jdGlvbigpe3ZhciB0PXAodGhpcy5nZXRUaXBFbGVtZW50KCkpLGU9dC5hdHRyKFwiY2xhc3NcIikubWF0Y2goVW4pO251bGwhPT1lJiYwPGUubGVuZ3RoJiZ0LnJlbW92ZUNsYXNzKGUuam9pbihcIlwiKSl9LGkuX2pRdWVyeUludGVyZmFjZT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9cCh0aGlzKS5kYXRhKFJuKSxlPVwib2JqZWN0XCI9PXR5cGVvZiBuP246bnVsbDtpZigodHx8IS9kaXNwb3NlfGhpZGUvLnRlc3QobikpJiYodHx8KHQ9bmV3IGkodGhpcyxlKSxwKHRoaXMpLmRhdGEoUm4sdCkpLFwic3RyaW5nXCI9PXR5cGVvZiBuKSl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHRbbl0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytuKydcIicpO3Rbbl0oKX19KX0scyhpLG51bGwsW3trZXk6XCJWRVJTSU9OXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjIuMVwifX0se2tleTpcIkRlZmF1bHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm59fSx7a2V5OlwiTkFNRVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBqbn19LHtrZXk6XCJEQVRBX0tFWVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBSbn19LHtrZXk6XCJFdmVudFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBYbn19LHtrZXk6XCJFVkVOVF9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gRm59fSx7a2V5OlwiRGVmYXVsdFR5cGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcW59fV0pLGl9KEhuKTtwLmZuW2puXT16bi5falF1ZXJ5SW50ZXJmYWNlLHAuZm5bam5dLkNvbnN0cnVjdG9yPXpuLHAuZm5bam5dLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gcC5mbltqbl09TW4sem4uX2pRdWVyeUludGVyZmFjZX07dmFyIEduPVwic2Nyb2xsc3B5XCIsSm49XCJicy5zY3JvbGxzcHlcIixabj1cIi5cIitKbiwkbj1wLmZuW0duXSx0aT17b2Zmc2V0OjEwLG1ldGhvZDpcImF1dG9cIix0YXJnZXQ6XCJcIn0sZWk9e29mZnNldDpcIm51bWJlclwiLG1ldGhvZDpcInN0cmluZ1wiLHRhcmdldDpcIihzdHJpbmd8ZWxlbWVudClcIn0sbmk9e0FDVElWQVRFOlwiYWN0aXZhdGVcIitabixTQ1JPTEw6XCJzY3JvbGxcIitabixMT0FEX0RBVEFfQVBJOlwibG9hZFwiK1puK1wiLmRhdGEtYXBpXCJ9LGlpPVwiZHJvcGRvd24taXRlbVwiLG9pPVwiYWN0aXZlXCIscmk9J1tkYXRhLXNweT1cInNjcm9sbFwiXScsc2k9XCIubmF2LCAubGlzdC1ncm91cFwiLGFpPVwiLm5hdi1saW5rXCIsbGk9XCIubmF2LWl0ZW1cIixjaT1cIi5saXN0LWdyb3VwLWl0ZW1cIixoaT1cIi5kcm9wZG93blwiLHVpPVwiLmRyb3Bkb3duLWl0ZW1cIixmaT1cIi5kcm9wZG93bi10b2dnbGVcIixkaT1cIm9mZnNldFwiLHBpPVwicG9zaXRpb25cIixtaT1mdW5jdGlvbigpe2Z1bmN0aW9uIG4odCxlKXt2YXIgbj10aGlzO3RoaXMuX2VsZW1lbnQ9dCx0aGlzLl9zY3JvbGxFbGVtZW50PVwiQk9EWVwiPT09dC50YWdOYW1lP3dpbmRvdzp0LHRoaXMuX2NvbmZpZz10aGlzLl9nZXRDb25maWcoZSksdGhpcy5fc2VsZWN0b3I9dGhpcy5fY29uZmlnLnRhcmdldCtcIiBcIithaStcIixcIit0aGlzLl9jb25maWcudGFyZ2V0K1wiIFwiK2NpK1wiLFwiK3RoaXMuX2NvbmZpZy50YXJnZXQrXCIgXCIrdWksdGhpcy5fb2Zmc2V0cz1bXSx0aGlzLl90YXJnZXRzPVtdLHRoaXMuX2FjdGl2ZVRhcmdldD1udWxsLHRoaXMuX3Njcm9sbEhlaWdodD0wLHAodGhpcy5fc2Nyb2xsRWxlbWVudCkub24obmkuU0NST0xMLGZ1bmN0aW9uKHQpe3JldHVybiBuLl9wcm9jZXNzKHQpfSksdGhpcy5yZWZyZXNoKCksdGhpcy5fcHJvY2VzcygpfXZhciB0PW4ucHJvdG90eXBlO3JldHVybiB0LnJlZnJlc2g9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9dGhpcy5fc2Nyb2xsRWxlbWVudD09PXRoaXMuX3Njcm9sbEVsZW1lbnQud2luZG93P2RpOnBpLG89XCJhdXRvXCI9PT10aGlzLl9jb25maWcubWV0aG9kP3Q6dGhpcy5fY29uZmlnLm1ldGhvZCxyPW89PT1waT90aGlzLl9nZXRTY3JvbGxUb3AoKTowO3RoaXMuX29mZnNldHM9W10sdGhpcy5fdGFyZ2V0cz1bXSx0aGlzLl9zY3JvbGxIZWlnaHQ9dGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCksW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuX3NlbGVjdG9yKSkubWFwKGZ1bmN0aW9uKHQpe3ZhciBlLG49bS5nZXRTZWxlY3RvckZyb21FbGVtZW50KHQpO2lmKG4mJihlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobikpLGUpe3ZhciBpPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aWYoaS53aWR0aHx8aS5oZWlnaHQpcmV0dXJuW3AoZSlbb10oKS50b3ArcixuXX1yZXR1cm4gbnVsbH0pLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdH0pLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFswXS1lWzBdfSkuZm9yRWFjaChmdW5jdGlvbih0KXtlLl9vZmZzZXRzLnB1c2godFswXSksZS5fdGFyZ2V0cy5wdXNoKHRbMV0pfSl9LHQuZGlzcG9zZT1mdW5jdGlvbigpe3AucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LEpuKSxwKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9mZihabiksdGhpcy5fZWxlbWVudD1udWxsLHRoaXMuX3Njcm9sbEVsZW1lbnQ9bnVsbCx0aGlzLl9jb25maWc9bnVsbCx0aGlzLl9zZWxlY3Rvcj1udWxsLHRoaXMuX29mZnNldHM9bnVsbCx0aGlzLl90YXJnZXRzPW51bGwsdGhpcy5fYWN0aXZlVGFyZ2V0PW51bGwsdGhpcy5fc2Nyb2xsSGVpZ2h0PW51bGx9LHQuX2dldENvbmZpZz1mdW5jdGlvbih0KXtpZihcInN0cmluZ1wiIT10eXBlb2YodD1sKHt9LHRpLFwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0P3Q6e30pKS50YXJnZXQpe3ZhciBlPXAodC50YXJnZXQpLmF0dHIoXCJpZFwiKTtlfHwoZT1tLmdldFVJRChHbikscCh0LnRhcmdldCkuYXR0cihcImlkXCIsZSkpLHQudGFyZ2V0PVwiI1wiK2V9cmV0dXJuIG0udHlwZUNoZWNrQ29uZmlnKEduLHQsZWkpLHR9LHQuX2dldFNjcm9sbFRvcD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50PT09d2luZG93P3RoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQ6dGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3B9LHQuX2dldFNjcm9sbEhlaWdodD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodHx8TWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCl9LHQuX2dldE9mZnNldEhlaWdodD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50PT09d2luZG93P3dpbmRvdy5pbm5lckhlaWdodDp0aGlzLl9zY3JvbGxFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodH0sdC5fcHJvY2Vzcz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX2dldFNjcm9sbFRvcCgpK3RoaXMuX2NvbmZpZy5vZmZzZXQsZT10aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSxuPXRoaXMuX2NvbmZpZy5vZmZzZXQrZS10aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtpZih0aGlzLl9zY3JvbGxIZWlnaHQhPT1lJiZ0aGlzLnJlZnJlc2goKSxuPD10KXt2YXIgaT10aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoLTFdO3RoaXMuX2FjdGl2ZVRhcmdldCE9PWkmJnRoaXMuX2FjdGl2YXRlKGkpfWVsc2V7aWYodGhpcy5fYWN0aXZlVGFyZ2V0JiZ0PHRoaXMuX29mZnNldHNbMF0mJjA8dGhpcy5fb2Zmc2V0c1swXSlyZXR1cm4gdGhpcy5fYWN0aXZlVGFyZ2V0PW51bGwsdm9pZCB0aGlzLl9jbGVhcigpO2Zvcih2YXIgbz10aGlzLl9vZmZzZXRzLmxlbmd0aDtvLS07KXt0aGlzLl9hY3RpdmVUYXJnZXQhPT10aGlzLl90YXJnZXRzW29dJiZ0Pj10aGlzLl9vZmZzZXRzW29dJiYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHRoaXMuX29mZnNldHNbbysxXXx8dDx0aGlzLl9vZmZzZXRzW28rMV0pJiZ0aGlzLl9hY3RpdmF0ZSh0aGlzLl90YXJnZXRzW29dKX19fSx0Ll9hY3RpdmF0ZT1mdW5jdGlvbihlKXt0aGlzLl9hY3RpdmVUYXJnZXQ9ZSx0aGlzLl9jbGVhcigpO3ZhciB0PXRoaXMuX3NlbGVjdG9yLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQrJ1tkYXRhLXRhcmdldD1cIicrZSsnXCJdLCcrdCsnW2hyZWY9XCInK2UrJ1wiXSd9KSxuPXAoW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQuam9pbihcIixcIikpKSk7bi5oYXNDbGFzcyhpaSk/KG4uY2xvc2VzdChoaSkuZmluZChmaSkuYWRkQ2xhc3Mob2kpLG4uYWRkQ2xhc3Mob2kpKToobi5hZGRDbGFzcyhvaSksbi5wYXJlbnRzKHNpKS5wcmV2KGFpK1wiLCBcIitjaSkuYWRkQ2xhc3Mob2kpLG4ucGFyZW50cyhzaSkucHJldihsaSkuY2hpbGRyZW4oYWkpLmFkZENsYXNzKG9pKSkscCh0aGlzLl9zY3JvbGxFbGVtZW50KS50cmlnZ2VyKG5pLkFDVElWQVRFLHtyZWxhdGVkVGFyZ2V0OmV9KX0sdC5fY2xlYXI9ZnVuY3Rpb24oKXtbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5fc2VsZWN0b3IpKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2xhc3NMaXN0LmNvbnRhaW5zKG9pKX0pLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQuY2xhc3NMaXN0LnJlbW92ZShvaSl9KX0sbi5falF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD1wKHRoaXMpLmRhdGEoSm4pO2lmKHR8fCh0PW5ldyBuKHRoaXMsXCJvYmplY3RcIj09dHlwZW9mIGUmJmUpLHAodGhpcykuZGF0YShKbix0KSksXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB0W2VdKXRocm93IG5ldyBUeXBlRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicrZSsnXCInKTt0W2VdKCl9fSl9LHMobixudWxsLFt7a2V5OlwiVkVSU0lPTlwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiNC4yLjFcIn19LHtrZXk6XCJEZWZhdWx0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRpfX1dKSxufSgpO3Aod2luZG93KS5vbihuaS5MT0FEX0RBVEFfQVBJLGZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChyaSkpLGU9dC5sZW5ndGg7ZS0tOyl7dmFyIG49cCh0W2VdKTttaS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwobixuLmRhdGEoKSl9fSkscC5mbltHbl09bWkuX2pRdWVyeUludGVyZmFjZSxwLmZuW0duXS5Db25zdHJ1Y3Rvcj1taSxwLmZuW0duXS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHAuZm5bR25dPSRuLG1pLl9qUXVlcnlJbnRlcmZhY2V9O3ZhciBnaT1cImJzLnRhYlwiLF9pPVwiLlwiK2dpLHZpPXAuZm4udGFiLHlpPXtISURFOlwiaGlkZVwiK19pLEhJRERFTjpcImhpZGRlblwiK19pLFNIT1c6XCJzaG93XCIrX2ksU0hPV046XCJzaG93blwiK19pLENMSUNLX0RBVEFfQVBJOlwiY2xpY2tcIitfaStcIi5kYXRhLWFwaVwifSxFaT1cImRyb3Bkb3duLW1lbnVcIixiaT1cImFjdGl2ZVwiLHdpPVwiZGlzYWJsZWRcIixUaT1cImZhZGVcIixDaT1cInNob3dcIixTaT1cIi5kcm9wZG93blwiLERpPVwiLm5hdiwgLmxpc3QtZ3JvdXBcIixJaT1cIi5hY3RpdmVcIixBaT1cIj4gbGkgPiAuYWN0aXZlXCIsT2k9J1tkYXRhLXRvZ2dsZT1cInRhYlwiXSwgW2RhdGEtdG9nZ2xlPVwicGlsbFwiXSwgW2RhdGEtdG9nZ2xlPVwibGlzdFwiXScsTmk9XCIuZHJvcGRvd24tdG9nZ2xlXCIsa2k9XCI+IC5kcm9wZG93bi1tZW51IC5hY3RpdmVcIixMaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGkodCl7dGhpcy5fZWxlbWVudD10fXZhciB0PWkucHJvdG90eXBlO3JldHVybiB0LnNob3c9ZnVuY3Rpb24oKXt2YXIgbj10aGlzO2lmKCEodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlJiZ0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSYmcCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhiaSl8fHAodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3Mod2kpKSl7dmFyIHQsaSxlPXAodGhpcy5fZWxlbWVudCkuY2xvc2VzdChEaSlbMF0sbz1tLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7aWYoZSl7dmFyIHI9XCJVTFwiPT09ZS5ub2RlTmFtZXx8XCJPTFwiPT09ZS5ub2RlTmFtZT9BaTpJaTtpPShpPXAubWFrZUFycmF5KHAoZSkuZmluZChyKSkpW2kubGVuZ3RoLTFdfXZhciBzPXAuRXZlbnQoeWkuSElERSx7cmVsYXRlZFRhcmdldDp0aGlzLl9lbGVtZW50fSksYT1wLkV2ZW50KHlpLlNIT1cse3JlbGF0ZWRUYXJnZXQ6aX0pO2lmKGkmJnAoaSkudHJpZ2dlcihzKSxwKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoYSksIWEuaXNEZWZhdWx0UHJldmVudGVkKCkmJiFzLmlzRGVmYXVsdFByZXZlbnRlZCgpKXtvJiYodD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKG8pKSx0aGlzLl9hY3RpdmF0ZSh0aGlzLl9lbGVtZW50LGUpO3ZhciBsPWZ1bmN0aW9uKCl7dmFyIHQ9cC5FdmVudCh5aS5ISURERU4se3JlbGF0ZWRUYXJnZXQ6bi5fZWxlbWVudH0pLGU9cC5FdmVudCh5aS5TSE9XTix7cmVsYXRlZFRhcmdldDppfSk7cChpKS50cmlnZ2VyKHQpLHAobi5fZWxlbWVudCkudHJpZ2dlcihlKX07dD90aGlzLl9hY3RpdmF0ZSh0LHQucGFyZW50Tm9kZSxsKTpsKCl9fX0sdC5kaXNwb3NlPWZ1bmN0aW9uKCl7cC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsZ2kpLHRoaXMuX2VsZW1lbnQ9bnVsbH0sdC5fYWN0aXZhdGU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXRoaXMsbz0oIWV8fFwiVUxcIiE9PWUubm9kZU5hbWUmJlwiT0xcIiE9PWUubm9kZU5hbWU/cChlKS5jaGlsZHJlbihJaSk6cChlKS5maW5kKEFpKSlbMF0scj1uJiZvJiZwKG8pLmhhc0NsYXNzKFRpKSxzPWZ1bmN0aW9uKCl7cmV0dXJuIGkuX3RyYW5zaXRpb25Db21wbGV0ZSh0LG8sbil9O2lmKG8mJnIpe3ZhciBhPW0uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQobyk7cChvKS5yZW1vdmVDbGFzcyhDaSkub25lKG0uVFJBTlNJVElPTl9FTkQscykuZW11bGF0ZVRyYW5zaXRpb25FbmQoYSl9ZWxzZSBzKCl9LHQuX3RyYW5zaXRpb25Db21wbGV0ZT1mdW5jdGlvbih0LGUsbil7aWYoZSl7cChlKS5yZW1vdmVDbGFzcyhiaSk7dmFyIGk9cChlLnBhcmVudE5vZGUpLmZpbmQoa2kpWzBdO2kmJnAoaSkucmVtb3ZlQ2xhc3MoYmkpLFwidGFiXCI9PT1lLmdldEF0dHJpYnV0ZShcInJvbGVcIikmJmUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCExKX1pZihwKHQpLmFkZENsYXNzKGJpKSxcInRhYlwiPT09dC5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpJiZ0LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwhMCksbS5yZWZsb3codCkscCh0KS5hZGRDbGFzcyhDaSksdC5wYXJlbnROb2RlJiZwKHQucGFyZW50Tm9kZSkuaGFzQ2xhc3MoRWkpKXt2YXIgbz1wKHQpLmNsb3Nlc3QoU2kpWzBdO2lmKG8pe3ZhciByPVtdLnNsaWNlLmNhbGwoby5xdWVyeVNlbGVjdG9yQWxsKE5pKSk7cChyKS5hZGRDbGFzcyhiaSl9dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsITApfW4mJm4oKX0saS5falF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD1wKHRoaXMpLGU9dC5kYXRhKGdpKTtpZihlfHwoZT1uZXcgaSh0aGlzKSx0LmRhdGEoZ2ksZSkpLFwic3RyaW5nXCI9PXR5cGVvZiBuKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZVtuXSl0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK24rJ1wiJyk7ZVtuXSgpfX0pfSxzKGksbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMi4xXCJ9fV0pLGl9KCk7cChkb2N1bWVudCkub24oeWkuQ0xJQ0tfREFUQV9BUEksT2ksZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLExpLl9qUXVlcnlJbnRlcmZhY2UuY2FsbChwKHRoaXMpLFwic2hvd1wiKX0pLHAuZm4udGFiPUxpLl9qUXVlcnlJbnRlcmZhY2UscC5mbi50YWIuQ29uc3RydWN0b3I9TGkscC5mbi50YWIubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBwLmZuLnRhYj12aSxMaS5falF1ZXJ5SW50ZXJmYWNlfTt2YXIgUGk9XCJ0b2FzdFwiLHhpPVwiYnMudG9hc3RcIixIaT1cIi5cIit4aSxqaT1wLmZuW1BpXSxSaT17Q0xJQ0tfRElTTUlTUzpcImNsaWNrLmRpc21pc3NcIitIaSxISURFOlwiaGlkZVwiK0hpLEhJRERFTjpcImhpZGRlblwiK0hpLFNIT1c6XCJzaG93XCIrSGksU0hPV046XCJzaG93blwiK0hpfSxGaT1cImZhZGVcIixNaT1cImhpZGVcIixXaT1cInNob3dcIixVaT1cInNob3dpbmdcIixCaT17YW5pbWF0aW9uOlwiYm9vbGVhblwiLGF1dG9oaWRlOlwiYm9vbGVhblwiLGRlbGF5OlwibnVtYmVyXCJ9LHFpPXthbmltYXRpb246ITAsYXV0b2hpZGU6ITAsZGVsYXk6NTAwfSxLaT0nW2RhdGEtZGlzbWlzcz1cInRvYXN0XCJdJyxRaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGkodCxlKXt0aGlzLl9lbGVtZW50PXQsdGhpcy5fY29uZmlnPXRoaXMuX2dldENvbmZpZyhlKSx0aGlzLl90aW1lb3V0PW51bGwsdGhpcy5fc2V0TGlzdGVuZXJzKCl9dmFyIHQ9aS5wcm90b3R5cGU7cmV0dXJuIHQuc2hvdz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7cCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKFJpLlNIT1cpLHRoaXMuX2NvbmZpZy5hbmltYXRpb24mJnRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChGaSk7dmFyIGU9ZnVuY3Rpb24oKXt0Ll9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoVWkpLHQuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChXaSkscCh0Ll9lbGVtZW50KS50cmlnZ2VyKFJpLlNIT1dOKSx0Ll9jb25maWcuYXV0b2hpZGUmJnQuaGlkZSgpfTtpZih0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoTWkpLHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChVaSksdGhpcy5fY29uZmlnLmFuaW1hdGlvbil7dmFyIG49bS5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtwKHRoaXMuX2VsZW1lbnQpLm9uZShtLlRSQU5TSVRJT05fRU5ELGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKG4pfWVsc2UgZSgpfSx0LmhpZGU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhXaSkmJihwKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoUmkuSElERSksdD90aGlzLl9jbG9zZSgpOnRoaXMuX3RpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2UuX2Nsb3NlKCl9LHRoaXMuX2NvbmZpZy5kZWxheSkpfSx0LmRpc3Bvc2U9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksdGhpcy5fdGltZW91dD1udWxsLHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFdpKSYmdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFdpKSxwKHRoaXMuX2VsZW1lbnQpLm9mZihSaS5DTElDS19ESVNNSVNTKSxwLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCx4aSksdGhpcy5fZWxlbWVudD1udWxsLHRoaXMuX2NvbmZpZz1udWxsfSx0Ll9nZXRDb25maWc9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9bCh7fSxxaSxwKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSxcIm9iamVjdFwiPT10eXBlb2YgdCYmdD90Ont9KSxtLnR5cGVDaGVja0NvbmZpZyhQaSx0LHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLHR9LHQuX3NldExpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7cCh0aGlzLl9lbGVtZW50KS5vbihSaS5DTElDS19ESVNNSVNTLEtpLGZ1bmN0aW9uKCl7cmV0dXJuIHQuaGlkZSghMCl9KX0sdC5fY2xvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9ZnVuY3Rpb24oKXt0Ll9lbGVtZW50LmNsYXNzTGlzdC5hZGQoTWkpLHAodC5fZWxlbWVudCkudHJpZ2dlcihSaS5ISURERU4pfTtpZih0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoV2kpLHRoaXMuX2NvbmZpZy5hbmltYXRpb24pe3ZhciBuPW0uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7cCh0aGlzLl9lbGVtZW50KS5vbmUobS5UUkFOU0lUSU9OX0VORCxlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChuKX1lbHNlIGUoKX0saS5falF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD1wKHRoaXMpLGU9dC5kYXRhKHhpKTtpZihlfHwoZT1uZXcgaSh0aGlzLFwib2JqZWN0XCI9PXR5cGVvZiBuJiZuKSx0LmRhdGEoeGksZSkpLFwic3RyaW5nXCI9PXR5cGVvZiBuKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZVtuXSl0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK24rJ1wiJyk7ZVtuXSh0aGlzKX19KX0scyhpLG51bGwsW3trZXk6XCJWRVJTSU9OXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjIuMVwifX0se2tleTpcIkRlZmF1bHRUeXBlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJpfX1dKSxpfSgpO3AuZm5bUGldPVFpLl9qUXVlcnlJbnRlcmZhY2UscC5mbltQaV0uQ29uc3RydWN0b3I9UWkscC5mbltQaV0ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBwLmZuW1BpXT1qaSxRaS5falF1ZXJ5SW50ZXJmYWNlfSxmdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBwKXRocm93IG5ldyBUeXBlRXJyb3IoXCJCb290c3RyYXAncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeS4galF1ZXJ5IG11c3QgYmUgaW5jbHVkZWQgYmVmb3JlIEJvb3RzdHJhcCdzIEphdmFTY3JpcHQuXCIpO3ZhciB0PXAuZm4uanF1ZXJ5LnNwbGl0KFwiIFwiKVswXS5zcGxpdChcIi5cIik7aWYodFswXTwyJiZ0WzFdPDl8fDE9PT10WzBdJiY5PT09dFsxXSYmdFsyXTwxfHw0PD10WzBdKXRocm93IG5ldyBFcnJvcihcIkJvb3RzdHJhcCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgYXQgbGVhc3QgalF1ZXJ5IHYxLjkuMSBidXQgbGVzcyB0aGFuIHY0LjAuMFwiKX0oKSx0LlV0aWw9bSx0LkFsZXJ0PWcsdC5CdXR0b249ayx0LkNhcm91c2VsPWF0LHQuQ29sbGFwc2U9VHQsdC5Ecm9wZG93bj16ZSx0Lk1vZGFsPXBuLHQuUG9wb3Zlcj16bix0LlNjcm9sbHNweT1taSx0LlRhYj1MaSx0LlRvYXN0PVFpLHQuVG9vbHRpcD1IbixPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pO1xuIiwiLyohXG4gICogQm9vdHN0cmFwIHY0LjIuMSAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcbiAgKiBDb3B5cmlnaHQgMjAxMS0yMDE4IFRoZSBCb290c3RyYXAgQXV0aG9ycyAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2dyYXBocy9jb250cmlidXRvcnMpXG4gICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAgKi9cbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP2UoZXhwb3J0cyxyZXF1aXJlKFwicG9wcGVyLmpzXCIpLHJlcXVpcmUoXCJqcXVlcnlcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiLFwicG9wcGVyLmpzXCIsXCJqcXVlcnlcIl0sZSk6ZSh0LmJvb3RzdHJhcD17fSx0LlBvcHBlcix0LmpRdWVyeSl9KHRoaXMsZnVuY3Rpb24odCx1LGcpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIGk9ZVtuXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fWZ1bmN0aW9uIHModCxlLG4pe3JldHVybiBlJiZpKHQucHJvdG90eXBlLGUpLG4mJmkodCxuKSx0fWZ1bmN0aW9uIGwobyl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIHI9bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fSxlPU9iamVjdC5rZXlzKHIpO1wiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJihlPWUuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocikuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsdCkuZW51bWVyYWJsZX0pKSksZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlLG4saTtlPW8saT1yW249dF0sbiBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se3ZhbHVlOmksZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW25dPWl9KX1yZXR1cm4gb311PXUmJnUuaGFzT3duUHJvcGVydHkoXCJkZWZhdWx0XCIpP3UuZGVmYXVsdDp1LGc9ZyYmZy5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRcIik/Zy5kZWZhdWx0Omc7dmFyIGU9XCJ0cmFuc2l0aW9uZW5kXCI7ZnVuY3Rpb24gbih0KXt2YXIgZT10aGlzLG49ITE7cmV0dXJuIGcodGhpcykub25lKF8uVFJBTlNJVElPTl9FTkQsZnVuY3Rpb24oKXtuPSEwfSksc2V0VGltZW91dChmdW5jdGlvbigpe258fF8udHJpZ2dlclRyYW5zaXRpb25FbmQoZSl9LHQpLHRoaXN9dmFyIF89e1RSQU5TSVRJT05fRU5EOlwiYnNUcmFuc2l0aW9uRW5kXCIsZ2V0VUlEOmZ1bmN0aW9uKHQpe2Zvcig7dCs9fn4oMWU2Kk1hdGgucmFuZG9tKCkpLGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQpOyk7cmV0dXJuIHR9LGdldFNlbGVjdG9yRnJvbUVsZW1lbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRhcmdldFwiKTtpZighZXx8XCIjXCI9PT1lKXt2YXIgbj10LmdldEF0dHJpYnV0ZShcImhyZWZcIik7ZT1uJiZcIiNcIiE9PW4/bi50cmltKCk6XCJcIn1yZXR1cm4gZSYmZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKT9lOm51bGx9LGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50OmZ1bmN0aW9uKHQpe2lmKCF0KXJldHVybiAwO3ZhciBlPWcodCkuY3NzKFwidHJhbnNpdGlvbi1kdXJhdGlvblwiKSxuPWcodCkuY3NzKFwidHJhbnNpdGlvbi1kZWxheVwiKSxpPXBhcnNlRmxvYXQoZSksbz1wYXJzZUZsb2F0KG4pO3JldHVybiBpfHxvPyhlPWUuc3BsaXQoXCIsXCIpWzBdLG49bi5zcGxpdChcIixcIilbMF0sMWUzKihwYXJzZUZsb2F0KGUpK3BhcnNlRmxvYXQobikpKTowfSxyZWZsb3c6ZnVuY3Rpb24odCl7cmV0dXJuIHQub2Zmc2V0SGVpZ2h0fSx0cmlnZ2VyVHJhbnNpdGlvbkVuZDpmdW5jdGlvbih0KXtnKHQpLnRyaWdnZXIoZSl9LHN1cHBvcnRzVHJhbnNpdGlvbkVuZDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKGUpfSxpc0VsZW1lbnQ6ZnVuY3Rpb24odCl7cmV0dXJuKHRbMF18fHQpLm5vZGVUeXBlfSx0eXBlQ2hlY2tDb25maWc6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaSBpbiBuKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLGkpKXt2YXIgbz1uW2ldLHI9ZVtpXSxzPXImJl8uaXNFbGVtZW50KHIpP1wiZWxlbWVudFwiOihhPXIse30udG9TdHJpbmcuY2FsbChhKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKSk7aWYoIW5ldyBSZWdFeHAobykudGVzdChzKSl0aHJvdyBuZXcgRXJyb3IodC50b1VwcGVyQ2FzZSgpKyc6IE9wdGlvbiBcIicraSsnXCIgcHJvdmlkZWQgdHlwZSBcIicrcysnXCIgYnV0IGV4cGVjdGVkIHR5cGUgXCInK28rJ1wiLicpfXZhciBhfSxmaW5kU2hhZG93Um9vdDpmdW5jdGlvbih0KXtpZighZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaFNoYWRvdylyZXR1cm4gbnVsbDtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0LmdldFJvb3ROb2RlKXJldHVybiB0IGluc3RhbmNlb2YgU2hhZG93Um9vdD90OnQucGFyZW50Tm9kZT9fLmZpbmRTaGFkb3dSb290KHQucGFyZW50Tm9kZSk6bnVsbDt2YXIgZT10LmdldFJvb3ROb2RlKCk7cmV0dXJuIGUgaW5zdGFuY2VvZiBTaGFkb3dSb290P2U6bnVsbH19O2cuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQ9bixnLmV2ZW50LnNwZWNpYWxbXy5UUkFOU0lUSU9OX0VORF09e2JpbmRUeXBlOmUsZGVsZWdhdGVUeXBlOmUsaGFuZGxlOmZ1bmN0aW9uKHQpe2lmKGcodC50YXJnZXQpLmlzKHRoaXMpKXJldHVybiB0LmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19O3ZhciBvPVwiYWxlcnRcIixyPVwiYnMuYWxlcnRcIixhPVwiLlwiK3IsYz1nLmZuW29dLGg9e0NMT1NFOlwiY2xvc2VcIithLENMT1NFRDpcImNsb3NlZFwiK2EsQ0xJQ0tfREFUQV9BUEk6XCJjbGlja1wiK2ErXCIuZGF0YS1hcGlcIn0sZj1cImFsZXJ0XCIsZD1cImZhZGVcIixtPVwic2hvd1wiLHA9ZnVuY3Rpb24oKXtmdW5jdGlvbiBpKHQpe3RoaXMuX2VsZW1lbnQ9dH12YXIgdD1pLnByb3RvdHlwZTtyZXR1cm4gdC5jbG9zZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9lbGVtZW50O3QmJihlPXRoaXMuX2dldFJvb3RFbGVtZW50KHQpKSx0aGlzLl90cmlnZ2VyQ2xvc2VFdmVudChlKS5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8dGhpcy5fcmVtb3ZlRWxlbWVudChlKX0sdC5kaXNwb3NlPWZ1bmN0aW9uKCl7Zy5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsciksdGhpcy5fZWxlbWVudD1udWxsfSx0Ll9nZXRSb290RWxlbWVudD1mdW5jdGlvbih0KXt2YXIgZT1fLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodCksbj0hMTtyZXR1cm4gZSYmKG49ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKSksbnx8KG49Zyh0KS5jbG9zZXN0KFwiLlwiK2YpWzBdKSxufSx0Ll90cmlnZ2VyQ2xvc2VFdmVudD1mdW5jdGlvbih0KXt2YXIgZT1nLkV2ZW50KGguQ0xPU0UpO3JldHVybiBnKHQpLnRyaWdnZXIoZSksZX0sdC5fcmVtb3ZlRWxlbWVudD1mdW5jdGlvbihlKXt2YXIgbj10aGlzO2lmKGcoZSkucmVtb3ZlQ2xhc3MobSksZyhlKS5oYXNDbGFzcyhkKSl7dmFyIHQ9Xy5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChlKTtnKGUpLm9uZShfLlRSQU5TSVRJT05fRU5ELGZ1bmN0aW9uKHQpe3JldHVybiBuLl9kZXN0cm95RWxlbWVudChlLHQpfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodCl9ZWxzZSB0aGlzLl9kZXN0cm95RWxlbWVudChlKX0sdC5fZGVzdHJveUVsZW1lbnQ9ZnVuY3Rpb24odCl7Zyh0KS5kZXRhY2goKS50cmlnZ2VyKGguQ0xPU0VEKS5yZW1vdmUoKX0saS5falF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD1nKHRoaXMpLGU9dC5kYXRhKHIpO2V8fChlPW5ldyBpKHRoaXMpLHQuZGF0YShyLGUpKSxcImNsb3NlXCI9PT1uJiZlW25dKHRoaXMpfSl9LGkuX2hhbmRsZURpc21pc3M9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3QmJnQucHJldmVudERlZmF1bHQoKSxlLmNsb3NlKHRoaXMpfX0scyhpLG51bGwsW3trZXk6XCJWRVJTSU9OXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjIuMVwifX1dKSxpfSgpO2coZG9jdW1lbnQpLm9uKGguQ0xJQ0tfREFUQV9BUEksJ1tkYXRhLWRpc21pc3M9XCJhbGVydFwiXScscC5faGFuZGxlRGlzbWlzcyhuZXcgcCkpLGcuZm5bb109cC5falF1ZXJ5SW50ZXJmYWNlLGcuZm5bb10uQ29uc3RydWN0b3I9cCxnLmZuW29dLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gZy5mbltvXT1jLHAuX2pRdWVyeUludGVyZmFjZX07dmFyIHY9XCJidXR0b25cIixFPVwiYnMuYnV0dG9uXCIseT1cIi5cIitFLEM9XCIuZGF0YS1hcGlcIixUPWcuZm5bdl0sUz1cImFjdGl2ZVwiLGI9XCJidG5cIixJPVwiZm9jdXNcIixEPSdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJyx3PSdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJyxBPSdpbnB1dDpub3QoW3R5cGU9XCJoaWRkZW5cIl0pJyxOPVwiLmFjdGl2ZVwiLE89XCIuYnRuXCIsaz17Q0xJQ0tfREFUQV9BUEk6XCJjbGlja1wiK3krQyxGT0NVU19CTFVSX0RBVEFfQVBJOlwiZm9jdXNcIit5K0MrXCIgYmx1clwiK3krQ30sUD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4odCl7dGhpcy5fZWxlbWVudD10fXZhciB0PW4ucHJvdG90eXBlO3JldHVybiB0LnRvZ2dsZT1mdW5jdGlvbigpe3ZhciB0PSEwLGU9ITAsbj1nKHRoaXMuX2VsZW1lbnQpLmNsb3Nlc3QodylbMF07aWYobil7dmFyIGk9dGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKEEpO2lmKGkpe2lmKFwicmFkaW9cIj09PWkudHlwZSlpZihpLmNoZWNrZWQmJnRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFMpKXQ9ITE7ZWxzZXt2YXIgbz1uLnF1ZXJ5U2VsZWN0b3IoTik7byYmZyhvKS5yZW1vdmVDbGFzcyhTKX1pZih0KXtpZihpLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpfHxuLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpfHxpLmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpfHxuLmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpKXJldHVybjtpLmNoZWNrZWQ9IXRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFMpLGcoaSkudHJpZ2dlcihcImNoYW5nZVwiKX1pLmZvY3VzKCksZT0hMX19ZSYmdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXByZXNzZWRcIiwhdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoUykpLHQmJmcodGhpcy5fZWxlbWVudCkudG9nZ2xlQ2xhc3MoUyl9LHQuZGlzcG9zZT1mdW5jdGlvbigpe2cucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LEUpLHRoaXMuX2VsZW1lbnQ9bnVsbH0sbi5falF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD1nKHRoaXMpLmRhdGEoRSk7dHx8KHQ9bmV3IG4odGhpcyksZyh0aGlzKS5kYXRhKEUsdCkpLFwidG9nZ2xlXCI9PT1lJiZ0W2VdKCl9KX0scyhuLG51bGwsW3trZXk6XCJWRVJTSU9OXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjIuMVwifX1dKSxufSgpO2coZG9jdW1lbnQpLm9uKGsuQ0xJQ0tfREFUQV9BUEksRCxmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCk7dmFyIGU9dC50YXJnZXQ7ZyhlKS5oYXNDbGFzcyhiKXx8KGU9ZyhlKS5jbG9zZXN0KE8pKSxQLl9qUXVlcnlJbnRlcmZhY2UuY2FsbChnKGUpLFwidG9nZ2xlXCIpfSkub24oay5GT0NVU19CTFVSX0RBVEFfQVBJLEQsZnVuY3Rpb24odCl7dmFyIGU9Zyh0LnRhcmdldCkuY2xvc2VzdChPKVswXTtnKGUpLnRvZ2dsZUNsYXNzKEksL15mb2N1cyhpbik/JC8udGVzdCh0LnR5cGUpKX0pLGcuZm5bdl09UC5falF1ZXJ5SW50ZXJmYWNlLGcuZm5bdl0uQ29uc3RydWN0b3I9UCxnLmZuW3ZdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gZy5mblt2XT1ULFAuX2pRdWVyeUludGVyZmFjZX07dmFyIEw9XCJjYXJvdXNlbFwiLGo9XCJicy5jYXJvdXNlbFwiLEg9XCIuXCIraixSPVwiLmRhdGEtYXBpXCIsVT1nLmZuW0xdLFc9e2ludGVydmFsOjVlMyxrZXlib2FyZDohMCxzbGlkZTohMSxwYXVzZTpcImhvdmVyXCIsd3JhcDohMCx0b3VjaDohMH0seD17aW50ZXJ2YWw6XCIobnVtYmVyfGJvb2xlYW4pXCIsa2V5Ym9hcmQ6XCJib29sZWFuXCIsc2xpZGU6XCIoYm9vbGVhbnxzdHJpbmcpXCIscGF1c2U6XCIoc3RyaW5nfGJvb2xlYW4pXCIsd3JhcDpcImJvb2xlYW5cIix0b3VjaDpcImJvb2xlYW5cIn0sRj1cIm5leHRcIixxPVwicHJldlwiLE09XCJsZWZ0XCIsSz1cInJpZ2h0XCIsUT17U0xJREU6XCJzbGlkZVwiK0gsU0xJRDpcInNsaWRcIitILEtFWURPV046XCJrZXlkb3duXCIrSCxNT1VTRUVOVEVSOlwibW91c2VlbnRlclwiK0gsTU9VU0VMRUFWRTpcIm1vdXNlbGVhdmVcIitILFRPVUNIU1RBUlQ6XCJ0b3VjaHN0YXJ0XCIrSCxUT1VDSE1PVkU6XCJ0b3VjaG1vdmVcIitILFRPVUNIRU5EOlwidG91Y2hlbmRcIitILFBPSU5URVJET1dOOlwicG9pbnRlcmRvd25cIitILFBPSU5URVJVUDpcInBvaW50ZXJ1cFwiK0gsRFJBR19TVEFSVDpcImRyYWdzdGFydFwiK0gsTE9BRF9EQVRBX0FQSTpcImxvYWRcIitIK1IsQ0xJQ0tfREFUQV9BUEk6XCJjbGlja1wiK0grUn0sQj1cImNhcm91c2VsXCIsVj1cImFjdGl2ZVwiLFk9XCJzbGlkZVwiLFg9XCJjYXJvdXNlbC1pdGVtLXJpZ2h0XCIsej1cImNhcm91c2VsLWl0ZW0tbGVmdFwiLEc9XCJjYXJvdXNlbC1pdGVtLW5leHRcIixKPVwiY2Fyb3VzZWwtaXRlbS1wcmV2XCIsWj1cInBvaW50ZXItZXZlbnRcIiwkPVwiLmFjdGl2ZVwiLHR0PVwiLmFjdGl2ZS5jYXJvdXNlbC1pdGVtXCIsZXQ9XCIuY2Fyb3VzZWwtaXRlbVwiLG50PVwiLmNhcm91c2VsLWl0ZW0gaW1nXCIsaXQ9XCIuY2Fyb3VzZWwtaXRlbS1uZXh0LCAuY2Fyb3VzZWwtaXRlbS1wcmV2XCIsb3Q9XCIuY2Fyb3VzZWwtaW5kaWNhdG9yc1wiLHJ0PVwiW2RhdGEtc2xpZGVdLCBbZGF0YS1zbGlkZS10b11cIixzdD0nW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJyxhdD17VE9VQ0g6XCJ0b3VjaFwiLFBFTjpcInBlblwifSxsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHIodCxlKXt0aGlzLl9pdGVtcz1udWxsLHRoaXMuX2ludGVydmFsPW51bGwsdGhpcy5fYWN0aXZlRWxlbWVudD1udWxsLHRoaXMuX2lzUGF1c2VkPSExLHRoaXMuX2lzU2xpZGluZz0hMSx0aGlzLnRvdWNoVGltZW91dD1udWxsLHRoaXMudG91Y2hTdGFydFg9MCx0aGlzLnRvdWNoRGVsdGFYPTAsdGhpcy5fY29uZmlnPXRoaXMuX2dldENvbmZpZyhlKSx0aGlzLl9lbGVtZW50PXQsdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQ9dGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKG90KSx0aGlzLl90b3VjaFN1cHBvcnRlZD1cIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fHwwPG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyx0aGlzLl9wb2ludGVyRXZlbnQ9Qm9vbGVhbih3aW5kb3cuUG9pbnRlckV2ZW50fHx3aW5kb3cuTVNQb2ludGVyRXZlbnQpLHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCl9dmFyIHQ9ci5wcm90b3R5cGU7cmV0dXJuIHQubmV4dD1mdW5jdGlvbigpe3RoaXMuX2lzU2xpZGluZ3x8dGhpcy5fc2xpZGUoRil9LHQubmV4dFdoZW5WaXNpYmxlPWZ1bmN0aW9uKCl7IWRvY3VtZW50LmhpZGRlbiYmZyh0aGlzLl9lbGVtZW50KS5pcyhcIjp2aXNpYmxlXCIpJiZcImhpZGRlblwiIT09Zyh0aGlzLl9lbGVtZW50KS5jc3MoXCJ2aXNpYmlsaXR5XCIpJiZ0aGlzLm5leHQoKX0sdC5wcmV2PWZ1bmN0aW9uKCl7dGhpcy5faXNTbGlkaW5nfHx0aGlzLl9zbGlkZShxKX0sdC5wYXVzZT1mdW5jdGlvbih0KXt0fHwodGhpcy5faXNQYXVzZWQ9ITApLHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihpdCkmJihfLnRyaWdnZXJUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQpLHRoaXMuY3ljbGUoITApKSxjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSx0aGlzLl9pbnRlcnZhbD1udWxsfSx0LmN5Y2xlPWZ1bmN0aW9uKHQpe3R8fCh0aGlzLl9pc1BhdXNlZD0hMSksdGhpcy5faW50ZXJ2YWwmJihjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSx0aGlzLl9pbnRlcnZhbD1udWxsKSx0aGlzLl9jb25maWcuaW50ZXJ2YWwmJiF0aGlzLl9pc1BhdXNlZCYmKHRoaXMuX2ludGVydmFsPXNldEludGVydmFsKChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU/dGhpcy5uZXh0V2hlblZpc2libGU6dGhpcy5uZXh0KS5iaW5kKHRoaXMpLHRoaXMuX2NvbmZpZy5pbnRlcnZhbCkpfSx0LnRvPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy5fYWN0aXZlRWxlbWVudD10aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodHQpO3ZhciBuPXRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtpZighKHQ+dGhpcy5faXRlbXMubGVuZ3RoLTF8fHQ8MCkpaWYodGhpcy5faXNTbGlkaW5nKWcodGhpcy5fZWxlbWVudCkub25lKFEuU0xJRCxmdW5jdGlvbigpe3JldHVybiBlLnRvKHQpfSk7ZWxzZXtpZihuPT09dClyZXR1cm4gdGhpcy5wYXVzZSgpLHZvaWQgdGhpcy5jeWNsZSgpO3ZhciBpPW48dD9GOnE7dGhpcy5fc2xpZGUoaSx0aGlzLl9pdGVtc1t0XSl9fSx0LmRpc3Bvc2U9ZnVuY3Rpb24oKXtnKHRoaXMuX2VsZW1lbnQpLm9mZihIKSxnLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCxqKSx0aGlzLl9pdGVtcz1udWxsLHRoaXMuX2NvbmZpZz1udWxsLHRoaXMuX2VsZW1lbnQ9bnVsbCx0aGlzLl9pbnRlcnZhbD1udWxsLHRoaXMuX2lzUGF1c2VkPW51bGwsdGhpcy5faXNTbGlkaW5nPW51bGwsdGhpcy5fYWN0aXZlRWxlbWVudD1udWxsLHRoaXMuX2luZGljYXRvcnNFbGVtZW50PW51bGx9LHQuX2dldENvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4gdD1sKHt9LFcsdCksXy50eXBlQ2hlY2tDb25maWcoTCx0LHgpLHR9LHQuX2hhbmRsZVN3aXBlPWZ1bmN0aW9uKCl7dmFyIHQ9TWF0aC5hYnModGhpcy50b3VjaERlbHRhWCk7aWYoISh0PD00MCkpe3ZhciBlPXQvdGhpcy50b3VjaERlbHRhWDswPGUmJnRoaXMucHJldigpLGU8MCYmdGhpcy5uZXh0KCl9fSx0Ll9hZGRFdmVudExpc3RlbmVycz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5fY29uZmlnLmtleWJvYXJkJiZnKHRoaXMuX2VsZW1lbnQpLm9uKFEuS0VZRE9XTixmdW5jdGlvbih0KXtyZXR1cm4gZS5fa2V5ZG93bih0KX0pLFwiaG92ZXJcIj09PXRoaXMuX2NvbmZpZy5wYXVzZSYmZyh0aGlzLl9lbGVtZW50KS5vbihRLk1PVVNFRU5URVIsZnVuY3Rpb24odCl7cmV0dXJuIGUucGF1c2UodCl9KS5vbihRLk1PVVNFTEVBVkUsZnVuY3Rpb24odCl7cmV0dXJuIGUuY3ljbGUodCl9KSx0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCl9LHQuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgbj10aGlzO2lmKHRoaXMuX3RvdWNoU3VwcG9ydGVkKXt2YXIgZT1mdW5jdGlvbih0KXtuLl9wb2ludGVyRXZlbnQmJmF0W3Qub3JpZ2luYWxFdmVudC5wb2ludGVyVHlwZS50b1VwcGVyQ2FzZSgpXT9uLnRvdWNoU3RhcnRYPXQub3JpZ2luYWxFdmVudC5jbGllbnRYOm4uX3BvaW50ZXJFdmVudHx8KG4udG91Y2hTdGFydFg9dC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCl9LGk9ZnVuY3Rpb24odCl7bi5fcG9pbnRlckV2ZW50JiZhdFt0Lm9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUudG9VcHBlckNhc2UoKV0mJihuLnRvdWNoRGVsdGFYPXQub3JpZ2luYWxFdmVudC5jbGllbnRYLW4udG91Y2hTdGFydFgpLG4uX2hhbmRsZVN3aXBlKCksXCJob3ZlclwiPT09bi5fY29uZmlnLnBhdXNlJiYobi5wYXVzZSgpLG4udG91Y2hUaW1lb3V0JiZjbGVhclRpbWVvdXQobi50b3VjaFRpbWVvdXQpLG4udG91Y2hUaW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24odCl7cmV0dXJuIG4uY3ljbGUodCl9LDUwMCtuLl9jb25maWcuaW50ZXJ2YWwpKX07Zyh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwobnQpKS5vbihRLkRSQUdfU1RBUlQsZnVuY3Rpb24odCl7cmV0dXJuIHQucHJldmVudERlZmF1bHQoKX0pLHRoaXMuX3BvaW50ZXJFdmVudD8oZyh0aGlzLl9lbGVtZW50KS5vbihRLlBPSU5URVJET1dOLGZ1bmN0aW9uKHQpe3JldHVybiBlKHQpfSksZyh0aGlzLl9lbGVtZW50KS5vbihRLlBPSU5URVJVUCxmdW5jdGlvbih0KXtyZXR1cm4gaSh0KX0pLHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChaKSk6KGcodGhpcy5fZWxlbWVudCkub24oUS5UT1VDSFNUQVJULGZ1bmN0aW9uKHQpe3JldHVybiBlKHQpfSksZyh0aGlzLl9lbGVtZW50KS5vbihRLlRPVUNITU9WRSxmdW5jdGlvbih0KXt2YXIgZTsoZT10KS5vcmlnaW5hbEV2ZW50LnRvdWNoZXMmJjE8ZS5vcmlnaW5hbEV2ZW50LnRvdWNoZXMubGVuZ3RoP24udG91Y2hEZWx0YVg9MDpuLnRvdWNoRGVsdGFYPWUub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdLmNsaWVudFgtbi50b3VjaFN0YXJ0WH0pLGcodGhpcy5fZWxlbWVudCkub24oUS5UT1VDSEVORCxmdW5jdGlvbih0KXtyZXR1cm4gaSh0KX0pKX19LHQuX2tleWRvd249ZnVuY3Rpb24odCl7aWYoIS9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkpc3dpdGNoKHQud2hpY2gpe2Nhc2UgMzc6dC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMucHJldigpO2JyZWFrO2Nhc2UgMzk6dC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMubmV4dCgpfX0sdC5fZ2V0SXRlbUluZGV4PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9pdGVtcz10JiZ0LnBhcmVudE5vZGU/W10uc2xpY2UuY2FsbCh0LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChldCkpOltdLHRoaXMuX2l0ZW1zLmluZGV4T2YodCl9LHQuX2dldEl0ZW1CeURpcmVjdGlvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXQ9PT1GLGk9dD09PXEsbz10aGlzLl9nZXRJdGVtSW5kZXgoZSkscj10aGlzLl9pdGVtcy5sZW5ndGgtMTtpZigoaSYmMD09PW98fG4mJm89PT1yKSYmIXRoaXMuX2NvbmZpZy53cmFwKXJldHVybiBlO3ZhciBzPShvKyh0PT09cT8tMToxKSkldGhpcy5faXRlbXMubGVuZ3RoO3JldHVybi0xPT09cz90aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGgtMV06dGhpcy5faXRlbXNbc119LHQuX3RyaWdnZXJTbGlkZUV2ZW50PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fZ2V0SXRlbUluZGV4KHQpLGk9dGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3Rvcih0dCkpLG89Zy5FdmVudChRLlNMSURFLHtyZWxhdGVkVGFyZ2V0OnQsZGlyZWN0aW9uOmUsZnJvbTppLHRvOm59KTtyZXR1cm4gZyh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKG8pLG99LHQuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQ9ZnVuY3Rpb24odCl7aWYodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpe3ZhciBlPVtdLnNsaWNlLmNhbGwodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgkKSk7ZyhlKS5yZW1vdmVDbGFzcyhWKTt2YXIgbj10aGlzLl9pbmRpY2F0b3JzRWxlbWVudC5jaGlsZHJlblt0aGlzLl9nZXRJdGVtSW5kZXgodCldO24mJmcobikuYWRkQ2xhc3MoVil9fSx0Ll9zbGlkZT1mdW5jdGlvbih0LGUpe3ZhciBuLGksbyxyPXRoaXMscz10aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IodHQpLGE9dGhpcy5fZ2V0SXRlbUluZGV4KHMpLGw9ZXx8cyYmdGhpcy5fZ2V0SXRlbUJ5RGlyZWN0aW9uKHQscyksYz10aGlzLl9nZXRJdGVtSW5kZXgobCksaD1Cb29sZWFuKHRoaXMuX2ludGVydmFsKTtpZihvPXQ9PT1GPyhuPXosaT1HLE0pOihuPVgsaT1KLEspLGwmJmcobCkuaGFzQ2xhc3MoVikpdGhpcy5faXNTbGlkaW5nPSExO2Vsc2UgaWYoIXRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KGwsbykuaXNEZWZhdWx0UHJldmVudGVkKCkmJnMmJmwpe3RoaXMuX2lzU2xpZGluZz0hMCxoJiZ0aGlzLnBhdXNlKCksdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChsKTt2YXIgdT1nLkV2ZW50KFEuU0xJRCx7cmVsYXRlZFRhcmdldDpsLGRpcmVjdGlvbjpvLGZyb206YSx0bzpjfSk7aWYoZyh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhZKSl7ZyhsKS5hZGRDbGFzcyhpKSxfLnJlZmxvdyhsKSxnKHMpLmFkZENsYXNzKG4pLGcobCkuYWRkQ2xhc3Mobik7dmFyIGY9cGFyc2VJbnQobC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWludGVydmFsXCIpLDEwKTt0aGlzLl9jb25maWcuaW50ZXJ2YWw9Zj8odGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbD10aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsfHx0aGlzLl9jb25maWcuaW50ZXJ2YWwsZik6dGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbHx8dGhpcy5fY29uZmlnLmludGVydmFsO3ZhciBkPV8uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQocyk7ZyhzKS5vbmUoXy5UUkFOU0lUSU9OX0VORCxmdW5jdGlvbigpe2cobCkucmVtb3ZlQ2xhc3MobitcIiBcIitpKS5hZGRDbGFzcyhWKSxnKHMpLnJlbW92ZUNsYXNzKFYrXCIgXCIraStcIiBcIituKSxyLl9pc1NsaWRpbmc9ITEsc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBnKHIuX2VsZW1lbnQpLnRyaWdnZXIodSl9LDApfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoZCl9ZWxzZSBnKHMpLnJlbW92ZUNsYXNzKFYpLGcobCkuYWRkQ2xhc3MoViksdGhpcy5faXNTbGlkaW5nPSExLGcodGhpcy5fZWxlbWVudCkudHJpZ2dlcih1KTtoJiZ0aGlzLmN5Y2xlKCl9fSxyLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PWcodGhpcykuZGF0YShqKSxlPWwoe30sVyxnKHRoaXMpLmRhdGEoKSk7XCJvYmplY3RcIj09dHlwZW9mIGkmJihlPWwoe30sZSxpKSk7dmFyIG49XCJzdHJpbmdcIj09dHlwZW9mIGk/aTplLnNsaWRlO2lmKHR8fCh0PW5ldyByKHRoaXMsZSksZyh0aGlzKS5kYXRhKGosdCkpLFwibnVtYmVyXCI9PXR5cGVvZiBpKXQudG8oaSk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2Ygbil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHRbbl0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytuKydcIicpO3Rbbl0oKX1lbHNlIGUuaW50ZXJ2YWwmJih0LnBhdXNlKCksdC5jeWNsZSgpKX0pfSxyLl9kYXRhQXBpQ2xpY2tIYW5kbGVyPWZ1bmN0aW9uKHQpe3ZhciBlPV8uZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtpZihlKXt2YXIgbj1nKGUpWzBdO2lmKG4mJmcobikuaGFzQ2xhc3MoQikpe3ZhciBpPWwoe30sZyhuKS5kYXRhKCksZyh0aGlzKS5kYXRhKCkpLG89dGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXNsaWRlLXRvXCIpO28mJihpLmludGVydmFsPSExKSxyLl9qUXVlcnlJbnRlcmZhY2UuY2FsbChnKG4pLGkpLG8mJmcobikuZGF0YShqKS50byhvKSx0LnByZXZlbnREZWZhdWx0KCl9fX0scyhyLG51bGwsW3trZXk6XCJWRVJTSU9OXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjIuMVwifX0se2tleTpcIkRlZmF1bHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gV319XSkscn0oKTtnKGRvY3VtZW50KS5vbihRLkNMSUNLX0RBVEFfQVBJLHJ0LGx0Ll9kYXRhQXBpQ2xpY2tIYW5kbGVyKSxnKHdpbmRvdykub24oUS5MT0FEX0RBVEFfQVBJLGZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzdCkpLGU9MCxuPXQubGVuZ3RoO2U8bjtlKyspe3ZhciBpPWcodFtlXSk7bHQuX2pRdWVyeUludGVyZmFjZS5jYWxsKGksaS5kYXRhKCkpfX0pLGcuZm5bTF09bHQuX2pRdWVyeUludGVyZmFjZSxnLmZuW0xdLkNvbnN0cnVjdG9yPWx0LGcuZm5bTF0ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBnLmZuW0xdPVUsbHQuX2pRdWVyeUludGVyZmFjZX07dmFyIGN0PVwiY29sbGFwc2VcIixodD1cImJzLmNvbGxhcHNlXCIsdXQ9XCIuXCIraHQsZnQ9Zy5mbltjdF0sZHQ9e3RvZ2dsZTohMCxwYXJlbnQ6XCJcIn0sZ3Q9e3RvZ2dsZTpcImJvb2xlYW5cIixwYXJlbnQ6XCIoc3RyaW5nfGVsZW1lbnQpXCJ9LF90PXtTSE9XOlwic2hvd1wiK3V0LFNIT1dOOlwic2hvd25cIit1dCxISURFOlwiaGlkZVwiK3V0LEhJRERFTjpcImhpZGRlblwiK3V0LENMSUNLX0RBVEFfQVBJOlwiY2xpY2tcIit1dCtcIi5kYXRhLWFwaVwifSxtdD1cInNob3dcIixwdD1cImNvbGxhcHNlXCIsdnQ9XCJjb2xsYXBzaW5nXCIsRXQ9XCJjb2xsYXBzZWRcIix5dD1cIndpZHRoXCIsQ3Q9XCJoZWlnaHRcIixUdD1cIi5zaG93LCAuY29sbGFwc2luZ1wiLFN0PSdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXScsYnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGUsdCl7dGhpcy5faXNUcmFuc2l0aW9uaW5nPSExLHRoaXMuX2VsZW1lbnQ9ZSx0aGlzLl9jb25maWc9dGhpcy5fZ2V0Q29uZmlnKHQpLHRoaXMuX3RyaWdnZXJBcnJheT1bXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2hyZWY9XCIjJytlLmlkKydcIl0sW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS10YXJnZXQ9XCIjJytlLmlkKydcIl0nKSk7Zm9yKHZhciBuPVtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTdCkpLGk9MCxvPW4ubGVuZ3RoO2k8bztpKyspe3ZhciByPW5baV0scz1fLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQociksYT1bXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocykpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdD09PWV9KTtudWxsIT09cyYmMDxhLmxlbmd0aCYmKHRoaXMuX3NlbGVjdG9yPXMsdGhpcy5fdHJpZ2dlckFycmF5LnB1c2gocikpfXRoaXMuX3BhcmVudD10aGlzLl9jb25maWcucGFyZW50P3RoaXMuX2dldFBhcmVudCgpOm51bGwsdGhpcy5fY29uZmlnLnBhcmVudHx8dGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX2VsZW1lbnQsdGhpcy5fdHJpZ2dlckFycmF5KSx0aGlzLl9jb25maWcudG9nZ2xlJiZ0aGlzLnRvZ2dsZSgpfXZhciB0PWEucHJvdG90eXBlO3JldHVybiB0LnRvZ2dsZT1mdW5jdGlvbigpe2codGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MobXQpP3RoaXMuaGlkZSgpOnRoaXMuc2hvdygpfSx0LnNob3c9ZnVuY3Rpb24oKXt2YXIgdCxlLG49dGhpcztpZighdGhpcy5faXNUcmFuc2l0aW9uaW5nJiYhZyh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhtdCkmJih0aGlzLl9wYXJlbnQmJjA9PT0odD1bXS5zbGljZS5jYWxsKHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKFR0KSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBuLl9jb25maWcucGFyZW50P3QuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYXJlbnRcIik9PT1uLl9jb25maWcucGFyZW50OnQuY2xhc3NMaXN0LmNvbnRhaW5zKHB0KX0pKS5sZW5ndGgmJih0PW51bGwpLCEodCYmKGU9Zyh0KS5ub3QodGhpcy5fc2VsZWN0b3IpLmRhdGEoaHQpKSYmZS5faXNUcmFuc2l0aW9uaW5nKSkpe3ZhciBpPWcuRXZlbnQoX3QuU0hPVyk7aWYoZyh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKGkpLCFpLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt0JiYoYS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoZyh0KS5ub3QodGhpcy5fc2VsZWN0b3IpLFwiaGlkZVwiKSxlfHxnKHQpLmRhdGEoaHQsbnVsbCkpO3ZhciBvPXRoaXMuX2dldERpbWVuc2lvbigpO2codGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MocHQpLmFkZENsYXNzKHZ0KSx0aGlzLl9lbGVtZW50LnN0eWxlW29dPTAsdGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aCYmZyh0aGlzLl90cmlnZ2VyQXJyYXkpLnJlbW92ZUNsYXNzKEV0KS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSx0aGlzLnNldFRyYW5zaXRpb25pbmcoITApO3ZhciByPVwic2Nyb2xsXCIrKG9bMF0udG9VcHBlckNhc2UoKStvLnNsaWNlKDEpKSxzPV8uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7Zyh0aGlzLl9lbGVtZW50KS5vbmUoXy5UUkFOU0lUSU9OX0VORCxmdW5jdGlvbigpe2cobi5fZWxlbWVudCkucmVtb3ZlQ2xhc3ModnQpLmFkZENsYXNzKHB0KS5hZGRDbGFzcyhtdCksbi5fZWxlbWVudC5zdHlsZVtvXT1cIlwiLG4uc2V0VHJhbnNpdGlvbmluZyghMSksZyhuLl9lbGVtZW50KS50cmlnZ2VyKF90LlNIT1dOKX0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHMpLHRoaXMuX2VsZW1lbnQuc3R5bGVbb109dGhpcy5fZWxlbWVudFtyXStcInB4XCJ9fX0sdC5oaWRlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZighdGhpcy5faXNUcmFuc2l0aW9uaW5nJiZnKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKG10KSl7dmFyIGU9Zy5FdmVudChfdC5ISURFKTtpZihnKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoZSksIWUuaXNEZWZhdWx0UHJldmVudGVkKCkpe3ZhciBuPXRoaXMuX2dldERpbWVuc2lvbigpO3RoaXMuX2VsZW1lbnQuc3R5bGVbbl09dGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtuXStcInB4XCIsXy5yZWZsb3codGhpcy5fZWxlbWVudCksZyh0aGlzLl9lbGVtZW50KS5hZGRDbGFzcyh2dCkucmVtb3ZlQ2xhc3MocHQpLnJlbW92ZUNsYXNzKG10KTt2YXIgaT10aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoO2lmKDA8aSlmb3IodmFyIG89MDtvPGk7bysrKXt2YXIgcj10aGlzLl90cmlnZ2VyQXJyYXlbb10scz1fLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQocik7aWYobnVsbCE9PXMpZyhbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocykpKS5oYXNDbGFzcyhtdCl8fGcocikuYWRkQ2xhc3MoRXQpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITEpfXRoaXMuc2V0VHJhbnNpdGlvbmluZyghMCk7dGhpcy5fZWxlbWVudC5zdHlsZVtuXT1cIlwiO3ZhciBhPV8uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7Zyh0aGlzLl9lbGVtZW50KS5vbmUoXy5UUkFOU0lUSU9OX0VORCxmdW5jdGlvbigpe3Quc2V0VHJhbnNpdGlvbmluZyghMSksZyh0Ll9lbGVtZW50KS5yZW1vdmVDbGFzcyh2dCkuYWRkQ2xhc3MocHQpLnRyaWdnZXIoX3QuSElEREVOKX0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGEpfX19LHQuc2V0VHJhbnNpdGlvbmluZz1mdW5jdGlvbih0KXt0aGlzLl9pc1RyYW5zaXRpb25pbmc9dH0sdC5kaXNwb3NlPWZ1bmN0aW9uKCl7Zy5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsaHQpLHRoaXMuX2NvbmZpZz1udWxsLHRoaXMuX3BhcmVudD1udWxsLHRoaXMuX2VsZW1lbnQ9bnVsbCx0aGlzLl90cmlnZ2VyQXJyYXk9bnVsbCx0aGlzLl9pc1RyYW5zaXRpb25pbmc9bnVsbH0sdC5fZ2V0Q29uZmlnPWZ1bmN0aW9uKHQpe3JldHVybih0PWwoe30sZHQsdCkpLnRvZ2dsZT1Cb29sZWFuKHQudG9nZ2xlKSxfLnR5cGVDaGVja0NvbmZpZyhjdCx0LGd0KSx0fSx0Ll9nZXREaW1lbnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gZyh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyh5dCk/eXQ6Q3R9LHQuX2dldFBhcmVudD1mdW5jdGlvbigpe3ZhciB0LG49dGhpcztfLmlzRWxlbWVudCh0aGlzLl9jb25maWcucGFyZW50KT8odD10aGlzLl9jb25maWcucGFyZW50LFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0aGlzLl9jb25maWcucGFyZW50LmpxdWVyeSYmKHQ9dGhpcy5fY29uZmlnLnBhcmVudFswXSkpOnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9jb25maWcucGFyZW50KTt2YXIgZT0nW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1wYXJlbnQ9XCInK3RoaXMuX2NvbmZpZy5wYXJlbnQrJ1wiXScsaT1bXS5zbGljZS5jYWxsKHQucXVlcnlTZWxlY3RvckFsbChlKSk7cmV0dXJuIGcoaSkuZWFjaChmdW5jdGlvbih0LGUpe24uX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhhLl9nZXRUYXJnZXRGcm9tRWxlbWVudChlKSxbZV0pfSksdH0sdC5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzPWZ1bmN0aW9uKHQsZSl7dmFyIG49Zyh0KS5oYXNDbGFzcyhtdCk7ZS5sZW5ndGgmJmcoZSkudG9nZ2xlQ2xhc3MoRXQsIW4pLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsbil9LGEuX2dldFRhcmdldEZyb21FbGVtZW50PWZ1bmN0aW9uKHQpe3ZhciBlPV8uZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0KTtyZXR1cm4gZT9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGUpOm51bGx9LGEuX2pRdWVyeUludGVyZmFjZT1mdW5jdGlvbihpKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9Zyh0aGlzKSxlPXQuZGF0YShodCksbj1sKHt9LGR0LHQuZGF0YSgpLFwib2JqZWN0XCI9PXR5cGVvZiBpJiZpP2k6e30pO2lmKCFlJiZuLnRvZ2dsZSYmL3Nob3d8aGlkZS8udGVzdChpKSYmKG4udG9nZ2xlPSExKSxlfHwoZT1uZXcgYSh0aGlzLG4pLHQuZGF0YShodCxlKSksXCJzdHJpbmdcIj09dHlwZW9mIGkpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBlW2ldKXRocm93IG5ldyBUeXBlRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicraSsnXCInKTtlW2ldKCl9fSl9LHMoYSxudWxsLFt7a2V5OlwiVkVSU0lPTlwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiNC4yLjFcIn19LHtrZXk6XCJEZWZhdWx0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGR0fX1dKSxhfSgpO2coZG9jdW1lbnQpLm9uKF90LkNMSUNLX0RBVEFfQVBJLFN0LGZ1bmN0aW9uKHQpe1wiQVwiPT09dC5jdXJyZW50VGFyZ2V0LnRhZ05hbWUmJnQucHJldmVudERlZmF1bHQoKTt2YXIgbj1nKHRoaXMpLGU9Xy5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpLGk9W10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGUpKTtnKGkpLmVhY2goZnVuY3Rpb24oKXt2YXIgdD1nKHRoaXMpLGU9dC5kYXRhKGh0KT9cInRvZ2dsZVwiOm4uZGF0YSgpO2J0Ll9qUXVlcnlJbnRlcmZhY2UuY2FsbCh0LGUpfSl9KSxnLmZuW2N0XT1idC5falF1ZXJ5SW50ZXJmYWNlLGcuZm5bY3RdLkNvbnN0cnVjdG9yPWJ0LGcuZm5bY3RdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gZy5mbltjdF09ZnQsYnQuX2pRdWVyeUludGVyZmFjZX07dmFyIEl0PVwiZHJvcGRvd25cIixEdD1cImJzLmRyb3Bkb3duXCIsd3Q9XCIuXCIrRHQsQXQ9XCIuZGF0YS1hcGlcIixOdD1nLmZuW0l0XSxPdD1uZXcgUmVnRXhwKFwiMzh8NDB8MjdcIiksa3Q9e0hJREU6XCJoaWRlXCIrd3QsSElEREVOOlwiaGlkZGVuXCIrd3QsU0hPVzpcInNob3dcIit3dCxTSE9XTjpcInNob3duXCIrd3QsQ0xJQ0s6XCJjbGlja1wiK3d0LENMSUNLX0RBVEFfQVBJOlwiY2xpY2tcIit3dCtBdCxLRVlET1dOX0RBVEFfQVBJOlwia2V5ZG93blwiK3d0K0F0LEtFWVVQX0RBVEFfQVBJOlwia2V5dXBcIit3dCtBdH0sUHQ9XCJkaXNhYmxlZFwiLEx0PVwic2hvd1wiLGp0PVwiZHJvcHVwXCIsSHQ9XCJkcm9wcmlnaHRcIixSdD1cImRyb3BsZWZ0XCIsVXQ9XCJkcm9wZG93bi1tZW51LXJpZ2h0XCIsV3Q9XCJwb3NpdGlvbi1zdGF0aWNcIix4dD0nW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nLEZ0PVwiLmRyb3Bkb3duIGZvcm1cIixxdD1cIi5kcm9wZG93bi1tZW51XCIsTXQ9XCIubmF2YmFyLW5hdlwiLEt0PVwiLmRyb3Bkb3duLW1lbnUgLmRyb3Bkb3duLWl0ZW06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZClcIixRdD1cInRvcC1zdGFydFwiLEJ0PVwidG9wLWVuZFwiLFZ0PVwiYm90dG9tLXN0YXJ0XCIsWXQ9XCJib3R0b20tZW5kXCIsWHQ9XCJyaWdodC1zdGFydFwiLHp0PVwibGVmdC1zdGFydFwiLEd0PXtvZmZzZXQ6MCxmbGlwOiEwLGJvdW5kYXJ5Olwic2Nyb2xsUGFyZW50XCIscmVmZXJlbmNlOlwidG9nZ2xlXCIsZGlzcGxheTpcImR5bmFtaWNcIn0sSnQ9e29mZnNldDpcIihudW1iZXJ8c3RyaW5nfGZ1bmN0aW9uKVwiLGZsaXA6XCJib29sZWFuXCIsYm91bmRhcnk6XCIoc3RyaW5nfGVsZW1lbnQpXCIscmVmZXJlbmNlOlwiKHN0cmluZ3xlbGVtZW50KVwiLGRpc3BsYXk6XCJzdHJpbmdcIn0sWnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBjKHQsZSl7dGhpcy5fZWxlbWVudD10LHRoaXMuX3BvcHBlcj1udWxsLHRoaXMuX2NvbmZpZz10aGlzLl9nZXRDb25maWcoZSksdGhpcy5fbWVudT10aGlzLl9nZXRNZW51RWxlbWVudCgpLHRoaXMuX2luTmF2YmFyPXRoaXMuX2RldGVjdE5hdmJhcigpLHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCl9dmFyIHQ9Yy5wcm90b3R5cGU7cmV0dXJuIHQudG9nZ2xlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2VsZW1lbnQuZGlzYWJsZWQmJiFnKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKFB0KSl7dmFyIHQ9Yy5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCksZT1nKHRoaXMuX21lbnUpLmhhc0NsYXNzKEx0KTtpZihjLl9jbGVhck1lbnVzKCksIWUpe3ZhciBuPXtyZWxhdGVkVGFyZ2V0OnRoaXMuX2VsZW1lbnR9LGk9Zy5FdmVudChrdC5TSE9XLG4pO2lmKGcodCkudHJpZ2dlcihpKSwhaS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSl7aWYoIXRoaXMuX2luTmF2YmFyKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgdSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQm9vdHN0cmFwJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyLmpzIChodHRwczovL3BvcHBlci5qcy5vcmcvKVwiKTt2YXIgbz10aGlzLl9lbGVtZW50O1wicGFyZW50XCI9PT10aGlzLl9jb25maWcucmVmZXJlbmNlP289dDpfLmlzRWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKSYmKG89dGhpcy5fY29uZmlnLnJlZmVyZW5jZSxcInVuZGVmaW5lZFwiIT10eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZS5qcXVlcnkmJihvPXRoaXMuX2NvbmZpZy5yZWZlcmVuY2VbMF0pKSxcInNjcm9sbFBhcmVudFwiIT09dGhpcy5fY29uZmlnLmJvdW5kYXJ5JiZnKHQpLmFkZENsYXNzKFd0KSx0aGlzLl9wb3BwZXI9bmV3IHUobyx0aGlzLl9tZW51LHRoaXMuX2dldFBvcHBlckNvbmZpZygpKX1cIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiYwPT09Zyh0KS5jbG9zZXN0KE10KS5sZW5ndGgmJmcoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vbihcIm1vdXNlb3ZlclwiLG51bGwsZy5ub29wKSx0aGlzLl9lbGVtZW50LmZvY3VzKCksdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsITApLGcodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoTHQpLGcodCkudG9nZ2xlQ2xhc3MoTHQpLnRyaWdnZXIoZy5FdmVudChrdC5TSE9XTixuKSl9fX19LHQuc2hvdz1mdW5jdGlvbigpe2lmKCEodGhpcy5fZWxlbWVudC5kaXNhYmxlZHx8Zyh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhQdCl8fGcodGhpcy5fbWVudSkuaGFzQ2xhc3MoTHQpKSl7dmFyIHQ9e3JlbGF0ZWRUYXJnZXQ6dGhpcy5fZWxlbWVudH0sZT1nLkV2ZW50KGt0LlNIT1csdCksbj1jLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtnKG4pLnRyaWdnZXIoZSksZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KGcodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoTHQpLGcobikudG9nZ2xlQ2xhc3MoTHQpLnRyaWdnZXIoZy5FdmVudChrdC5TSE9XTix0KSkpfX0sdC5oaWRlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2VsZW1lbnQuZGlzYWJsZWQmJiFnKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKFB0KSYmZyh0aGlzLl9tZW51KS5oYXNDbGFzcyhMdCkpe3ZhciB0PXtyZWxhdGVkVGFyZ2V0OnRoaXMuX2VsZW1lbnR9LGU9Zy5FdmVudChrdC5ISURFLHQpLG49Yy5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7ZyhuKS50cmlnZ2VyKGUpLGUuaXNEZWZhdWx0UHJldmVudGVkKCl8fChnKHRoaXMuX21lbnUpLnRvZ2dsZUNsYXNzKEx0KSxnKG4pLnRvZ2dsZUNsYXNzKEx0KS50cmlnZ2VyKGcuRXZlbnQoa3QuSElEREVOLHQpKSl9fSx0LmRpc3Bvc2U9ZnVuY3Rpb24oKXtnLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCxEdCksZyh0aGlzLl9lbGVtZW50KS5vZmYod3QpLHRoaXMuX2VsZW1lbnQ9bnVsbCwodGhpcy5fbWVudT1udWxsKSE9PXRoaXMuX3BvcHBlciYmKHRoaXMuX3BvcHBlci5kZXN0cm95KCksdGhpcy5fcG9wcGVyPW51bGwpfSx0LnVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuX2luTmF2YmFyPXRoaXMuX2RldGVjdE5hdmJhcigpLG51bGwhPT10aGlzLl9wb3BwZXImJnRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpfSx0Ll9hZGRFdmVudExpc3RlbmVycz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7Zyh0aGlzLl9lbGVtZW50KS5vbihrdC5DTElDSyxmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksdC5zdG9wUHJvcGFnYXRpb24oKSxlLnRvZ2dsZSgpfSl9LHQuX2dldENvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4gdD1sKHt9LHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxnKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSx0KSxfLnR5cGVDaGVja0NvbmZpZyhJdCx0LHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLHR9LHQuX2dldE1lbnVFbGVtZW50PWZ1bmN0aW9uKCl7aWYoIXRoaXMuX21lbnUpe3ZhciB0PWMuX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO3QmJih0aGlzLl9tZW51PXQucXVlcnlTZWxlY3RvcihxdCkpfXJldHVybiB0aGlzLl9tZW51fSx0Ll9nZXRQbGFjZW1lbnQ9ZnVuY3Rpb24oKXt2YXIgdD1nKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSksZT1WdDtyZXR1cm4gdC5oYXNDbGFzcyhqdCk/KGU9UXQsZyh0aGlzLl9tZW51KS5oYXNDbGFzcyhVdCkmJihlPUJ0KSk6dC5oYXNDbGFzcyhIdCk/ZT1YdDp0Lmhhc0NsYXNzKFJ0KT9lPXp0OmcodGhpcy5fbWVudSkuaGFzQ2xhc3MoVXQpJiYoZT1ZdCksZX0sdC5fZGV0ZWN0TmF2YmFyPWZ1bmN0aW9uKCl7cmV0dXJuIDA8Zyh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFwiLm5hdmJhclwiKS5sZW5ndGh9LHQuX2dldFBvcHBlckNvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXRoaXMsdD17fTtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLl9jb25maWcub2Zmc2V0P3QuZm49ZnVuY3Rpb24odCl7cmV0dXJuIHQub2Zmc2V0cz1sKHt9LHQub2Zmc2V0cyxlLl9jb25maWcub2Zmc2V0KHQub2Zmc2V0cyl8fHt9KSx0fTp0Lm9mZnNldD10aGlzLl9jb25maWcub2Zmc2V0O3ZhciBuPXtwbGFjZW1lbnQ6dGhpcy5fZ2V0UGxhY2VtZW50KCksbW9kaWZpZXJzOntvZmZzZXQ6dCxmbGlwOntlbmFibGVkOnRoaXMuX2NvbmZpZy5mbGlwfSxwcmV2ZW50T3ZlcmZsb3c6e2JvdW5kYXJpZXNFbGVtZW50OnRoaXMuX2NvbmZpZy5ib3VuZGFyeX19fTtyZXR1cm5cInN0YXRpY1wiPT09dGhpcy5fY29uZmlnLmRpc3BsYXkmJihuLm1vZGlmaWVycy5hcHBseVN0eWxlPXtlbmFibGVkOiExfSksbn0sYy5falF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD1nKHRoaXMpLmRhdGEoRHQpO2lmKHR8fCh0PW5ldyBjKHRoaXMsXCJvYmplY3RcIj09dHlwZW9mIGU/ZTpudWxsKSxnKHRoaXMpLmRhdGEoRHQsdCkpLFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgdFtlXSl0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK2UrJ1wiJyk7dFtlXSgpfX0pfSxjLl9jbGVhck1lbnVzPWZ1bmN0aW9uKHQpe2lmKCF0fHwzIT09dC53aGljaCYmKFwia2V5dXBcIiE9PXQudHlwZXx8OT09PXQud2hpY2gpKWZvcih2YXIgZT1bXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoeHQpKSxuPTAsaT1lLmxlbmd0aDtuPGk7bisrKXt2YXIgbz1jLl9nZXRQYXJlbnRGcm9tRWxlbWVudChlW25dKSxyPWcoZVtuXSkuZGF0YShEdCkscz17cmVsYXRlZFRhcmdldDplW25dfTtpZih0JiZcImNsaWNrXCI9PT10LnR5cGUmJihzLmNsaWNrRXZlbnQ9dCkscil7dmFyIGE9ci5fbWVudTtpZihnKG8pLmhhc0NsYXNzKEx0KSYmISh0JiYoXCJjbGlja1wiPT09dC50eXBlJiYvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpfHxcImtleXVwXCI9PT10LnR5cGUmJjk9PT10LndoaWNoKSYmZy5jb250YWlucyhvLHQudGFyZ2V0KSkpe3ZhciBsPWcuRXZlbnQoa3QuSElERSxzKTtnKG8pLnRyaWdnZXIobCksbC5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KFwib250b3VjaHN0YXJ0XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJmcoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vZmYoXCJtb3VzZW92ZXJcIixudWxsLGcubm9vcCksZVtuXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsXCJmYWxzZVwiKSxnKGEpLnJlbW92ZUNsYXNzKEx0KSxnKG8pLnJlbW92ZUNsYXNzKEx0KS50cmlnZ2VyKGcuRXZlbnQoa3QuSElEREVOLHMpKSl9fX19LGMuX2dldFBhcmVudEZyb21FbGVtZW50PWZ1bmN0aW9uKHQpe3ZhciBlLG49Xy5nZXRTZWxlY3RvckZyb21FbGVtZW50KHQpO3JldHVybiBuJiYoZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKG4pKSxlfHx0LnBhcmVudE5vZGV9LGMuX2RhdGFBcGlLZXlkb3duSGFuZGxlcj1mdW5jdGlvbih0KXtpZigoL2lucHV0fHRleHRhcmVhL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKT8hKDMyPT09dC53aGljaHx8MjchPT10LndoaWNoJiYoNDAhPT10LndoaWNoJiYzOCE9PXQud2hpY2h8fGcodC50YXJnZXQpLmNsb3Nlc3QocXQpLmxlbmd0aCkpOk90LnRlc3QodC53aGljaCkpJiYodC5wcmV2ZW50RGVmYXVsdCgpLHQuc3RvcFByb3BhZ2F0aW9uKCksIXRoaXMuZGlzYWJsZWQmJiFnKHRoaXMpLmhhc0NsYXNzKFB0KSkpe3ZhciBlPWMuX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMpLG49ZyhlKS5oYXNDbGFzcyhMdCk7aWYobiYmKCFufHwyNyE9PXQud2hpY2gmJjMyIT09dC53aGljaCkpe3ZhciBpPVtdLnNsaWNlLmNhbGwoZS5xdWVyeVNlbGVjdG9yQWxsKEt0KSk7aWYoMCE9PWkubGVuZ3RoKXt2YXIgbz1pLmluZGV4T2YodC50YXJnZXQpOzM4PT09dC53aGljaCYmMDxvJiZvLS0sNDA9PT10LndoaWNoJiZvPGkubGVuZ3RoLTEmJm8rKyxvPDAmJihvPTApLGlbb10uZm9jdXMoKX19ZWxzZXtpZigyNz09PXQud2hpY2gpe3ZhciByPWUucXVlcnlTZWxlY3Rvcih4dCk7ZyhyKS50cmlnZ2VyKFwiZm9jdXNcIil9Zyh0aGlzKS50cmlnZ2VyKFwiY2xpY2tcIil9fX0scyhjLG51bGwsW3trZXk6XCJWRVJTSU9OXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjIuMVwifX0se2tleTpcIkRlZmF1bHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gR3R9fSx7a2V5OlwiRGVmYXVsdFR5cGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gSnR9fV0pLGN9KCk7Zyhkb2N1bWVudCkub24oa3QuS0VZRE9XTl9EQVRBX0FQSSx4dCxadC5fZGF0YUFwaUtleWRvd25IYW5kbGVyKS5vbihrdC5LRVlET1dOX0RBVEFfQVBJLHF0LFp0Ll9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpLm9uKGt0LkNMSUNLX0RBVEFfQVBJK1wiIFwiK2t0LktFWVVQX0RBVEFfQVBJLFp0Ll9jbGVhck1lbnVzKS5vbihrdC5DTElDS19EQVRBX0FQSSx4dCxmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksdC5zdG9wUHJvcGFnYXRpb24oKSxadC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoZyh0aGlzKSxcInRvZ2dsZVwiKX0pLm9uKGt0LkNMSUNLX0RBVEFfQVBJLEZ0LGZ1bmN0aW9uKHQpe3Quc3RvcFByb3BhZ2F0aW9uKCl9KSxnLmZuW0l0XT1adC5falF1ZXJ5SW50ZXJmYWNlLGcuZm5bSXRdLkNvbnN0cnVjdG9yPVp0LGcuZm5bSXRdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gZy5mbltJdF09TnQsWnQuX2pRdWVyeUludGVyZmFjZX07dmFyICR0PVwibW9kYWxcIix0ZT1cImJzLm1vZGFsXCIsZWU9XCIuXCIrdGUsbmU9Zy5mblskdF0saWU9e2JhY2tkcm9wOiEwLGtleWJvYXJkOiEwLGZvY3VzOiEwLHNob3c6ITB9LG9lPXtiYWNrZHJvcDpcIihib29sZWFufHN0cmluZylcIixrZXlib2FyZDpcImJvb2xlYW5cIixmb2N1czpcImJvb2xlYW5cIixzaG93OlwiYm9vbGVhblwifSxyZT17SElERTpcImhpZGVcIitlZSxISURERU46XCJoaWRkZW5cIitlZSxTSE9XOlwic2hvd1wiK2VlLFNIT1dOOlwic2hvd25cIitlZSxGT0NVU0lOOlwiZm9jdXNpblwiK2VlLFJFU0laRTpcInJlc2l6ZVwiK2VlLENMSUNLX0RJU01JU1M6XCJjbGljay5kaXNtaXNzXCIrZWUsS0VZRE9XTl9ESVNNSVNTOlwia2V5ZG93bi5kaXNtaXNzXCIrZWUsTU9VU0VVUF9ESVNNSVNTOlwibW91c2V1cC5kaXNtaXNzXCIrZWUsTU9VU0VET1dOX0RJU01JU1M6XCJtb3VzZWRvd24uZGlzbWlzc1wiK2VlLENMSUNLX0RBVEFfQVBJOlwiY2xpY2tcIitlZStcIi5kYXRhLWFwaVwifSxzZT1cIm1vZGFsLXNjcm9sbGJhci1tZWFzdXJlXCIsYWU9XCJtb2RhbC1iYWNrZHJvcFwiLGxlPVwibW9kYWwtb3BlblwiLGNlPVwiZmFkZVwiLGhlPVwic2hvd1wiLHVlPVwiLm1vZGFsLWRpYWxvZ1wiLGZlPSdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsZGU9J1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsZ2U9XCIuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wXCIsX2U9XCIuc3RpY2t5LXRvcFwiLG1lPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbyh0LGUpe3RoaXMuX2NvbmZpZz10aGlzLl9nZXRDb25maWcoZSksdGhpcy5fZWxlbWVudD10LHRoaXMuX2RpYWxvZz10LnF1ZXJ5U2VsZWN0b3IodWUpLHRoaXMuX2JhY2tkcm9wPW51bGwsdGhpcy5faXNTaG93bj0hMSx0aGlzLl9pc0JvZHlPdmVyZmxvd2luZz0hMSx0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrPSExLHRoaXMuX2lzVHJhbnNpdGlvbmluZz0hMSx0aGlzLl9zY3JvbGxiYXJXaWR0aD0wfXZhciB0PW8ucHJvdG90eXBlO3JldHVybiB0LnRvZ2dsZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5faXNTaG93bj90aGlzLmhpZGUoKTp0aGlzLnNob3codCl9LHQuc2hvdz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKCF0aGlzLl9pc1Nob3duJiYhdGhpcy5faXNUcmFuc2l0aW9uaW5nKXtnKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKGNlKSYmKHRoaXMuX2lzVHJhbnNpdGlvbmluZz0hMCk7dmFyIG49Zy5FdmVudChyZS5TSE9XLHtyZWxhdGVkVGFyZ2V0OnR9KTtnKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIobiksdGhpcy5faXNTaG93bnx8bi5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KHRoaXMuX2lzU2hvd249ITAsdGhpcy5fY2hlY2tTY3JvbGxiYXIoKSx0aGlzLl9zZXRTY3JvbGxiYXIoKSx0aGlzLl9hZGp1c3REaWFsb2coKSx0aGlzLl9zZXRFc2NhcGVFdmVudCgpLHRoaXMuX3NldFJlc2l6ZUV2ZW50KCksZyh0aGlzLl9lbGVtZW50KS5vbihyZS5DTElDS19ESVNNSVNTLGRlLGZ1bmN0aW9uKHQpe3JldHVybiBlLmhpZGUodCl9KSxnKHRoaXMuX2RpYWxvZykub24ocmUuTU9VU0VET1dOX0RJU01JU1MsZnVuY3Rpb24oKXtnKGUuX2VsZW1lbnQpLm9uZShyZS5NT1VTRVVQX0RJU01JU1MsZnVuY3Rpb24odCl7Zyh0LnRhcmdldCkuaXMoZS5fZWxlbWVudCkmJihlLl9pZ25vcmVCYWNrZHJvcENsaWNrPSEwKX0pfSksdGhpcy5fc2hvd0JhY2tkcm9wKGZ1bmN0aW9uKCl7cmV0dXJuIGUuX3Nob3dFbGVtZW50KHQpfSkpfX0sdC5oaWRlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYodCYmdC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuX2lzU2hvd24mJiF0aGlzLl9pc1RyYW5zaXRpb25pbmcpe3ZhciBuPWcuRXZlbnQocmUuSElERSk7aWYoZyh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKG4pLHRoaXMuX2lzU2hvd24mJiFuLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt0aGlzLl9pc1Nob3duPSExO3ZhciBpPWcodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoY2UpO2lmKGkmJih0aGlzLl9pc1RyYW5zaXRpb25pbmc9ITApLHRoaXMuX3NldEVzY2FwZUV2ZW50KCksdGhpcy5fc2V0UmVzaXplRXZlbnQoKSxnKGRvY3VtZW50KS5vZmYocmUuRk9DVVNJTiksZyh0aGlzLl9lbGVtZW50KS5yZW1vdmVDbGFzcyhoZSksZyh0aGlzLl9lbGVtZW50KS5vZmYocmUuQ0xJQ0tfRElTTUlTUyksZyh0aGlzLl9kaWFsb2cpLm9mZihyZS5NT1VTRURPV05fRElTTUlTUyksaSl7dmFyIG89Xy5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtnKHRoaXMuX2VsZW1lbnQpLm9uZShfLlRSQU5TSVRJT05fRU5ELGZ1bmN0aW9uKHQpe3JldHVybiBlLl9oaWRlTW9kYWwodCl9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChvKX1lbHNlIHRoaXMuX2hpZGVNb2RhbCgpfX19LHQuZGlzcG9zZT1mdW5jdGlvbigpe1t3aW5kb3csdGhpcy5fZWxlbWVudCx0aGlzLl9kaWFsb2ddLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGcodCkub2ZmKGVlKX0pLGcoZG9jdW1lbnQpLm9mZihyZS5GT0NVU0lOKSxnLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCx0ZSksdGhpcy5fY29uZmlnPW51bGwsdGhpcy5fZWxlbWVudD1udWxsLHRoaXMuX2RpYWxvZz1udWxsLHRoaXMuX2JhY2tkcm9wPW51bGwsdGhpcy5faXNTaG93bj1udWxsLHRoaXMuX2lzQm9keU92ZXJmbG93aW5nPW51bGwsdGhpcy5faWdub3JlQmFja2Ryb3BDbGljaz1udWxsLHRoaXMuX2lzVHJhbnNpdGlvbmluZz1udWxsLHRoaXMuX3Njcm9sbGJhcldpZHRoPW51bGx9LHQuaGFuZGxlVXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5fYWRqdXN0RGlhbG9nKCl9LHQuX2dldENvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4gdD1sKHt9LGllLHQpLF8udHlwZUNoZWNrQ29uZmlnKCR0LHQsb2UpLHR9LHQuX3Nob3dFbGVtZW50PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1nKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKGNlKTt0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUmJnRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFfHxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpLHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSx0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwhMCksdGhpcy5fZWxlbWVudC5zY3JvbGxUb3A9MCxuJiZfLnJlZmxvdyh0aGlzLl9lbGVtZW50KSxnKHRoaXMuX2VsZW1lbnQpLmFkZENsYXNzKGhlKSx0aGlzLl9jb25maWcuZm9jdXMmJnRoaXMuX2VuZm9yY2VGb2N1cygpO3ZhciBpPWcuRXZlbnQocmUuU0hPV04se3JlbGF0ZWRUYXJnZXQ6dH0pLG89ZnVuY3Rpb24oKXtlLl9jb25maWcuZm9jdXMmJmUuX2VsZW1lbnQuZm9jdXMoKSxlLl9pc1RyYW5zaXRpb25pbmc9ITEsZyhlLl9lbGVtZW50KS50cmlnZ2VyKGkpfTtpZihuKXt2YXIgcj1fLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2RpYWxvZyk7Zyh0aGlzLl9kaWFsb2cpLm9uZShfLlRSQU5TSVRJT05fRU5ELG8pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHIpfWVsc2UgbygpfSx0Ll9lbmZvcmNlRm9jdXM9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2coZG9jdW1lbnQpLm9mZihyZS5GT0NVU0lOKS5vbihyZS5GT0NVU0lOLGZ1bmN0aW9uKHQpe2RvY3VtZW50IT09dC50YXJnZXQmJmUuX2VsZW1lbnQhPT10LnRhcmdldCYmMD09PWcoZS5fZWxlbWVudCkuaGFzKHQudGFyZ2V0KS5sZW5ndGgmJmUuX2VsZW1lbnQuZm9jdXMoKX0pfSx0Ll9zZXRFc2NhcGVFdmVudD1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5faXNTaG93biYmdGhpcy5fY29uZmlnLmtleWJvYXJkP2codGhpcy5fZWxlbWVudCkub24ocmUuS0VZRE9XTl9ESVNNSVNTLGZ1bmN0aW9uKHQpezI3PT09dC53aGljaCYmKHQucHJldmVudERlZmF1bHQoKSxlLmhpZGUoKSl9KTp0aGlzLl9pc1Nob3dufHxnKHRoaXMuX2VsZW1lbnQpLm9mZihyZS5LRVlET1dOX0RJU01JU1MpfSx0Ll9zZXRSZXNpemVFdmVudD1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5faXNTaG93bj9nKHdpbmRvdykub24ocmUuUkVTSVpFLGZ1bmN0aW9uKHQpe3JldHVybiBlLmhhbmRsZVVwZGF0ZSh0KX0pOmcod2luZG93KS5vZmYocmUuUkVTSVpFKX0sdC5faGlkZU1vZGFsPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCEwKSx0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiksdGhpcy5faXNUcmFuc2l0aW9uaW5nPSExLHRoaXMuX3Nob3dCYWNrZHJvcChmdW5jdGlvbigpe2coZG9jdW1lbnQuYm9keSkucmVtb3ZlQ2xhc3MobGUpLHQuX3Jlc2V0QWRqdXN0bWVudHMoKSx0Ll9yZXNldFNjcm9sbGJhcigpLGcodC5fZWxlbWVudCkudHJpZ2dlcihyZS5ISURERU4pfSl9LHQuX3JlbW92ZUJhY2tkcm9wPWZ1bmN0aW9uKCl7dGhpcy5fYmFja2Ryb3AmJihnKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmUoKSx0aGlzLl9iYWNrZHJvcD1udWxsKX0sdC5fc2hvd0JhY2tkcm9wPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1nKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKGNlKT9jZTpcIlwiO2lmKHRoaXMuX2lzU2hvd24mJnRoaXMuX2NvbmZpZy5iYWNrZHJvcCl7aWYodGhpcy5fYmFja2Ryb3A9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl9iYWNrZHJvcC5jbGFzc05hbWU9YWUsbiYmdGhpcy5fYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChuKSxnKHRoaXMuX2JhY2tkcm9wKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KSxnKHRoaXMuX2VsZW1lbnQpLm9uKHJlLkNMSUNLX0RJU01JU1MsZnVuY3Rpb24odCl7ZS5faWdub3JlQmFja2Ryb3BDbGljaz9lLl9pZ25vcmVCYWNrZHJvcENsaWNrPSExOnQudGFyZ2V0PT09dC5jdXJyZW50VGFyZ2V0JiYoXCJzdGF0aWNcIj09PWUuX2NvbmZpZy5iYWNrZHJvcD9lLl9lbGVtZW50LmZvY3VzKCk6ZS5oaWRlKCkpfSksbiYmXy5yZWZsb3codGhpcy5fYmFja2Ryb3ApLGcodGhpcy5fYmFja2Ryb3ApLmFkZENsYXNzKGhlKSwhdClyZXR1cm47aWYoIW4pcmV0dXJuIHZvaWQgdCgpO3ZhciBpPV8uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fYmFja2Ryb3ApO2codGhpcy5fYmFja2Ryb3ApLm9uZShfLlRSQU5TSVRJT05fRU5ELHQpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGkpfWVsc2UgaWYoIXRoaXMuX2lzU2hvd24mJnRoaXMuX2JhY2tkcm9wKXtnKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmVDbGFzcyhoZSk7dmFyIG89ZnVuY3Rpb24oKXtlLl9yZW1vdmVCYWNrZHJvcCgpLHQmJnQoKX07aWYoZyh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhjZSkpe3ZhciByPV8uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fYmFja2Ryb3ApO2codGhpcy5fYmFja2Ryb3ApLm9uZShfLlRSQU5TSVRJT05fRU5ELG8pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHIpfWVsc2UgbygpfWVsc2UgdCYmdCgpfSx0Ll9hZGp1c3REaWFsb2c9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodD5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0OyF0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyYmdCYmKHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQ9dGhpcy5fc2Nyb2xsYmFyV2lkdGgrXCJweFwiKSx0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyYmIXQmJih0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodD10aGlzLl9zY3JvbGxiYXJXaWR0aCtcInB4XCIpfSx0Ll9yZXNldEFkanVzdG1lbnRzPWZ1bmN0aW9uKCl7dGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdD1cIlwiLHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0PVwiXCJ9LHQuX2NoZWNrU2Nyb2xsYmFyPWZ1bmN0aW9uKCl7dmFyIHQ9ZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0aGlzLl9pc0JvZHlPdmVyZmxvd2luZz10LmxlZnQrdC5yaWdodDx3aW5kb3cuaW5uZXJXaWR0aCx0aGlzLl9zY3JvbGxiYXJXaWR0aD10aGlzLl9nZXRTY3JvbGxiYXJXaWR0aCgpfSx0Ll9zZXRTY3JvbGxiYXI9ZnVuY3Rpb24oKXt2YXIgbz10aGlzO2lmKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nKXt2YXIgdD1bXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZ2UpKSxlPVtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChfZSkpO2codCkuZWFjaChmdW5jdGlvbih0LGUpe3ZhciBuPWUuc3R5bGUucGFkZGluZ1JpZ2h0LGk9ZyhlKS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpO2coZSkuZGF0YShcInBhZGRpbmctcmlnaHRcIixuKS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIscGFyc2VGbG9hdChpKStvLl9zY3JvbGxiYXJXaWR0aCtcInB4XCIpfSksZyhlKS5lYWNoKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zdHlsZS5tYXJnaW5SaWdodCxpPWcoZSkuY3NzKFwibWFyZ2luLXJpZ2h0XCIpO2coZSkuZGF0YShcIm1hcmdpbi1yaWdodFwiLG4pLmNzcyhcIm1hcmdpbi1yaWdodFwiLHBhcnNlRmxvYXQoaSktby5fc2Nyb2xsYmFyV2lkdGgrXCJweFwiKX0pO3ZhciBuPWRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0LGk9Zyhkb2N1bWVudC5ib2R5KS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpO2coZG9jdW1lbnQuYm9keSkuZGF0YShcInBhZGRpbmctcmlnaHRcIixuKS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIscGFyc2VGbG9hdChpKSt0aGlzLl9zY3JvbGxiYXJXaWR0aCtcInB4XCIpfWcoZG9jdW1lbnQuYm9keSkuYWRkQ2xhc3MobGUpfSx0Ll9yZXNldFNjcm9sbGJhcj1mdW5jdGlvbigpe3ZhciB0PVtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChnZSkpO2codCkuZWFjaChmdW5jdGlvbih0LGUpe3ZhciBuPWcoZSkuZGF0YShcInBhZGRpbmctcmlnaHRcIik7ZyhlKS5yZW1vdmVEYXRhKFwicGFkZGluZy1yaWdodFwiKSxlLnN0eWxlLnBhZGRpbmdSaWdodD1ufHxcIlwifSk7dmFyIGU9W10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiXCIrX2UpKTtnKGUpLmVhY2goZnVuY3Rpb24odCxlKXt2YXIgbj1nKGUpLmRhdGEoXCJtYXJnaW4tcmlnaHRcIik7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG4mJmcoZSkuY3NzKFwibWFyZ2luLXJpZ2h0XCIsbikucmVtb3ZlRGF0YShcIm1hcmdpbi1yaWdodFwiKX0pO3ZhciBuPWcoZG9jdW1lbnQuYm9keSkuZGF0YShcInBhZGRpbmctcmlnaHRcIik7Zyhkb2N1bWVudC5ib2R5KS5yZW1vdmVEYXRhKFwicGFkZGluZy1yaWdodFwiKSxkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodD1ufHxcIlwifSx0Ll9nZXRTY3JvbGxiYXJXaWR0aD1mdW5jdGlvbigpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dC5jbGFzc05hbWU9c2UsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KTt2YXIgZT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLXQuY2xpZW50V2lkdGg7cmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodCksZX0sby5falF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKG4saSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PWcodGhpcykuZGF0YSh0ZSksZT1sKHt9LGllLGcodGhpcykuZGF0YSgpLFwib2JqZWN0XCI9PXR5cGVvZiBuJiZuP246e30pO2lmKHR8fCh0PW5ldyBvKHRoaXMsZSksZyh0aGlzKS5kYXRhKHRlLHQpKSxcInN0cmluZ1wiPT10eXBlb2Ygbil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHRbbl0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytuKydcIicpO3Rbbl0oaSl9ZWxzZSBlLnNob3cmJnQuc2hvdyhpKX0pfSxzKG8sbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMi4xXCJ9fSx7a2V5OlwiRGVmYXVsdFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBpZX19XSksb30oKTtnKGRvY3VtZW50KS5vbihyZS5DTElDS19EQVRBX0FQSSxmZSxmdW5jdGlvbih0KXt2YXIgZSxuPXRoaXMsaT1fLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7aSYmKGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihpKSk7dmFyIG89ZyhlKS5kYXRhKHRlKT9cInRvZ2dsZVwiOmwoe30sZyhlKS5kYXRhKCksZyh0aGlzKS5kYXRhKCkpO1wiQVwiIT09dGhpcy50YWdOYW1lJiZcIkFSRUFcIiE9PXRoaXMudGFnTmFtZXx8dC5wcmV2ZW50RGVmYXVsdCgpO3ZhciByPWcoZSkub25lKHJlLlNIT1csZnVuY3Rpb24odCl7dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8ci5vbmUocmUuSElEREVOLGZ1bmN0aW9uKCl7ZyhuKS5pcyhcIjp2aXNpYmxlXCIpJiZuLmZvY3VzKCl9KX0pO21lLl9qUXVlcnlJbnRlcmZhY2UuY2FsbChnKGUpLG8sdGhpcyl9KSxnLmZuWyR0XT1tZS5falF1ZXJ5SW50ZXJmYWNlLGcuZm5bJHRdLkNvbnN0cnVjdG9yPW1lLGcuZm5bJHRdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gZy5mblskdF09bmUsbWUuX2pRdWVyeUludGVyZmFjZX07dmFyIHBlPVwidG9vbHRpcFwiLHZlPVwiYnMudG9vbHRpcFwiLEVlPVwiLlwiK3ZlLHllPWcuZm5bcGVdLENlPVwiYnMtdG9vbHRpcFwiLFRlPW5ldyBSZWdFeHAoXCIoXnxcXFxccylcIitDZStcIlxcXFxTK1wiLFwiZ1wiKSxTZT17YW5pbWF0aW9uOlwiYm9vbGVhblwiLHRlbXBsYXRlOlwic3RyaW5nXCIsdGl0bGU6XCIoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pXCIsdHJpZ2dlcjpcInN0cmluZ1wiLGRlbGF5OlwiKG51bWJlcnxvYmplY3QpXCIsaHRtbDpcImJvb2xlYW5cIixzZWxlY3RvcjpcIihzdHJpbmd8Ym9vbGVhbilcIixwbGFjZW1lbnQ6XCIoc3RyaW5nfGZ1bmN0aW9uKVwiLG9mZnNldDpcIihudW1iZXJ8c3RyaW5nKVwiLGNvbnRhaW5lcjpcIihzdHJpbmd8ZWxlbWVudHxib29sZWFuKVwiLGZhbGxiYWNrUGxhY2VtZW50OlwiKHN0cmluZ3xhcnJheSlcIixib3VuZGFyeTpcIihzdHJpbmd8ZWxlbWVudClcIn0sYmU9e0FVVE86XCJhdXRvXCIsVE9QOlwidG9wXCIsUklHSFQ6XCJyaWdodFwiLEJPVFRPTTpcImJvdHRvbVwiLExFRlQ6XCJsZWZ0XCJ9LEllPXthbmltYXRpb246ITAsdGVtcGxhdGU6JzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj48ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PjwvZGl2PicsdHJpZ2dlcjpcImhvdmVyIGZvY3VzXCIsdGl0bGU6XCJcIixkZWxheTowLGh0bWw6ITEsc2VsZWN0b3I6ITEscGxhY2VtZW50OlwidG9wXCIsb2Zmc2V0OjAsY29udGFpbmVyOiExLGZhbGxiYWNrUGxhY2VtZW50OlwiZmxpcFwiLGJvdW5kYXJ5Olwic2Nyb2xsUGFyZW50XCJ9LERlPVwic2hvd1wiLHdlPVwib3V0XCIsQWU9e0hJREU6XCJoaWRlXCIrRWUsSElEREVOOlwiaGlkZGVuXCIrRWUsU0hPVzpcInNob3dcIitFZSxTSE9XTjpcInNob3duXCIrRWUsSU5TRVJURUQ6XCJpbnNlcnRlZFwiK0VlLENMSUNLOlwiY2xpY2tcIitFZSxGT0NVU0lOOlwiZm9jdXNpblwiK0VlLEZPQ1VTT1VUOlwiZm9jdXNvdXRcIitFZSxNT1VTRUVOVEVSOlwibW91c2VlbnRlclwiK0VlLE1PVVNFTEVBVkU6XCJtb3VzZWxlYXZlXCIrRWV9LE5lPVwiZmFkZVwiLE9lPVwic2hvd1wiLGtlPVwiLnRvb2x0aXAtaW5uZXJcIixQZT1cIi5hcnJvd1wiLExlPVwiaG92ZXJcIixqZT1cImZvY3VzXCIsSGU9XCJjbGlja1wiLFJlPVwibWFudWFsXCIsVWU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBpKHQsZSl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkJvb3RzdHJhcCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyLmpzIChodHRwczovL3BvcHBlci5qcy5vcmcvKVwiKTt0aGlzLl9pc0VuYWJsZWQ9ITAsdGhpcy5fdGltZW91dD0wLHRoaXMuX2hvdmVyU3RhdGU9XCJcIix0aGlzLl9hY3RpdmVUcmlnZ2VyPXt9LHRoaXMuX3BvcHBlcj1udWxsLHRoaXMuZWxlbWVudD10LHRoaXMuY29uZmlnPXRoaXMuX2dldENvbmZpZyhlKSx0aGlzLnRpcD1udWxsLHRoaXMuX3NldExpc3RlbmVycygpfXZhciB0PWkucHJvdG90eXBlO3JldHVybiB0LmVuYWJsZT1mdW5jdGlvbigpe3RoaXMuX2lzRW5hYmxlZD0hMH0sdC5kaXNhYmxlPWZ1bmN0aW9uKCl7dGhpcy5faXNFbmFibGVkPSExfSx0LnRvZ2dsZUVuYWJsZWQ9ZnVuY3Rpb24oKXt0aGlzLl9pc0VuYWJsZWQ9IXRoaXMuX2lzRW5hYmxlZH0sdC50b2dnbGU9ZnVuY3Rpb24odCl7aWYodGhpcy5faXNFbmFibGVkKWlmKHQpe3ZhciBlPXRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksbj1nKHQuY3VycmVudFRhcmdldCkuZGF0YShlKTtufHwobj1uZXcgdGhpcy5jb25zdHJ1Y3Rvcih0LmN1cnJlbnRUYXJnZXQsdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSksZyh0LmN1cnJlbnRUYXJnZXQpLmRhdGEoZSxuKSksbi5fYWN0aXZlVHJpZ2dlci5jbGljaz0hbi5fYWN0aXZlVHJpZ2dlci5jbGljayxuLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCk/bi5fZW50ZXIobnVsbCxuKTpuLl9sZWF2ZShudWxsLG4pfWVsc2V7aWYoZyh0aGlzLmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoT2UpKXJldHVybiB2b2lkIHRoaXMuX2xlYXZlKG51bGwsdGhpcyk7dGhpcy5fZW50ZXIobnVsbCx0aGlzKX19LHQuZGlzcG9zZT1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSxnLnJlbW92ZURhdGEodGhpcy5lbGVtZW50LHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpLGcodGhpcy5lbGVtZW50KS5vZmYodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpLGcodGhpcy5lbGVtZW50KS5jbG9zZXN0KFwiLm1vZGFsXCIpLm9mZihcImhpZGUuYnMubW9kYWxcIiksdGhpcy50aXAmJmcodGhpcy50aXApLnJlbW92ZSgpLHRoaXMuX2lzRW5hYmxlZD1udWxsLHRoaXMuX3RpbWVvdXQ9bnVsbCx0aGlzLl9ob3ZlclN0YXRlPW51bGwsKHRoaXMuX2FjdGl2ZVRyaWdnZXI9bnVsbCkhPT10aGlzLl9wb3BwZXImJnRoaXMuX3BvcHBlci5kZXN0cm95KCksdGhpcy5fcG9wcGVyPW51bGwsdGhpcy5lbGVtZW50PW51bGwsdGhpcy5jb25maWc9bnVsbCx0aGlzLnRpcD1udWxsfSx0LnNob3c9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKFwibm9uZVwiPT09Zyh0aGlzLmVsZW1lbnQpLmNzcyhcImRpc3BsYXlcIikpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHNcIik7dmFyIHQ9Zy5FdmVudCh0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpO2lmKHRoaXMuaXNXaXRoQ29udGVudCgpJiZ0aGlzLl9pc0VuYWJsZWQpe2codGhpcy5lbGVtZW50KS50cmlnZ2VyKHQpO3ZhciBuPV8uZmluZFNoYWRvd1Jvb3QodGhpcy5lbGVtZW50KSxpPWcuY29udGFpbnMobnVsbCE9PW4/bjp0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsdGhpcy5lbGVtZW50KTtpZih0LmlzRGVmYXVsdFByZXZlbnRlZCgpfHwhaSlyZXR1cm47dmFyIG89dGhpcy5nZXRUaXBFbGVtZW50KCkscj1fLmdldFVJRCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpO28uc2V0QXR0cmlidXRlKFwiaWRcIixyKSx0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLHIpLHRoaXMuc2V0Q29udGVudCgpLHRoaXMuY29uZmlnLmFuaW1hdGlvbiYmZyhvKS5hZGRDbGFzcyhOZSk7dmFyIHM9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5jb25maWcucGxhY2VtZW50P3RoaXMuY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsbyx0aGlzLmVsZW1lbnQpOnRoaXMuY29uZmlnLnBsYWNlbWVudCxhPXRoaXMuX2dldEF0dGFjaG1lbnQocyk7dGhpcy5hZGRBdHRhY2htZW50Q2xhc3MoYSk7dmFyIGw9dGhpcy5fZ2V0Q29udGFpbmVyKCk7ZyhvKS5kYXRhKHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksdGhpcyksZy5jb250YWlucyh0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsdGhpcy50aXApfHxnKG8pLmFwcGVuZFRvKGwpLGcodGhpcy5lbGVtZW50KS50cmlnZ2VyKHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSU5TRVJURUQpLHRoaXMuX3BvcHBlcj1uZXcgdSh0aGlzLmVsZW1lbnQsbyx7cGxhY2VtZW50OmEsbW9kaWZpZXJzOntvZmZzZXQ6e29mZnNldDp0aGlzLmNvbmZpZy5vZmZzZXR9LGZsaXA6e2JlaGF2aW9yOnRoaXMuY29uZmlnLmZhbGxiYWNrUGxhY2VtZW50fSxhcnJvdzp7ZWxlbWVudDpQZX0scHJldmVudE92ZXJmbG93Ontib3VuZGFyaWVzRWxlbWVudDp0aGlzLmNvbmZpZy5ib3VuZGFyeX19LG9uQ3JlYXRlOmZ1bmN0aW9uKHQpe3Qub3JpZ2luYWxQbGFjZW1lbnQhPT10LnBsYWNlbWVudCYmZS5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHQpfSxvblVwZGF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gZS5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHQpfX0pLGcobykuYWRkQ2xhc3MoT2UpLFwib250b3VjaHN0YXJ0XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJmcoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vbihcIm1vdXNlb3ZlclwiLG51bGwsZy5ub29wKTt2YXIgYz1mdW5jdGlvbigpe2UuY29uZmlnLmFuaW1hdGlvbiYmZS5fZml4VHJhbnNpdGlvbigpO3ZhciB0PWUuX2hvdmVyU3RhdGU7ZS5faG92ZXJTdGF0ZT1udWxsLGcoZS5lbGVtZW50KS50cmlnZ2VyKGUuY29uc3RydWN0b3IuRXZlbnQuU0hPV04pLHQ9PT13ZSYmZS5fbGVhdmUobnVsbCxlKX07aWYoZyh0aGlzLnRpcCkuaGFzQ2xhc3MoTmUpKXt2YXIgaD1fLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMudGlwKTtnKHRoaXMudGlwKS5vbmUoXy5UUkFOU0lUSU9OX0VORCxjKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChoKX1lbHNlIGMoKX19LHQuaGlkZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy5nZXRUaXBFbGVtZW50KCksaT1nLkV2ZW50KHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElERSksbz1mdW5jdGlvbigpe2UuX2hvdmVyU3RhdGUhPT1EZSYmbi5wYXJlbnROb2RlJiZuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobiksZS5fY2xlYW5UaXBDbGFzcygpLGUuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpLGcoZS5lbGVtZW50KS50cmlnZ2VyKGUuY29uc3RydWN0b3IuRXZlbnQuSElEREVOKSxudWxsIT09ZS5fcG9wcGVyJiZlLl9wb3BwZXIuZGVzdHJveSgpLHQmJnQoKX07aWYoZyh0aGlzLmVsZW1lbnQpLnRyaWdnZXIoaSksIWkuaXNEZWZhdWx0UHJldmVudGVkKCkpe2lmKGcobikucmVtb3ZlQ2xhc3MoT2UpLFwib250b3VjaHN0YXJ0XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJmcoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vZmYoXCJtb3VzZW92ZXJcIixudWxsLGcubm9vcCksdGhpcy5fYWN0aXZlVHJpZ2dlcltIZV09ITEsdGhpcy5fYWN0aXZlVHJpZ2dlcltqZV09ITEsdGhpcy5fYWN0aXZlVHJpZ2dlcltMZV09ITEsZyh0aGlzLnRpcCkuaGFzQ2xhc3MoTmUpKXt2YXIgcj1fLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KG4pO2cobikub25lKF8uVFJBTlNJVElPTl9FTkQsbykuZW11bGF0ZVRyYW5zaXRpb25FbmQocil9ZWxzZSBvKCk7dGhpcy5faG92ZXJTdGF0ZT1cIlwifX0sdC51cGRhdGU9ZnVuY3Rpb24oKXtudWxsIT09dGhpcy5fcG9wcGVyJiZ0aGlzLl9wb3BwZXIuc2NoZWR1bGVVcGRhdGUoKX0sdC5pc1dpdGhDb250ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4odGhpcy5nZXRUaXRsZSgpKX0sdC5hZGRBdHRhY2htZW50Q2xhc3M9ZnVuY3Rpb24odCl7Zyh0aGlzLmdldFRpcEVsZW1lbnQoKSkuYWRkQ2xhc3MoQ2UrXCItXCIrdCl9LHQuZ2V0VGlwRWxlbWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRpcD10aGlzLnRpcHx8Zyh0aGlzLmNvbmZpZy50ZW1wbGF0ZSlbMF0sdGhpcy50aXB9LHQuc2V0Q29udGVudD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0VGlwRWxlbWVudCgpO3RoaXMuc2V0RWxlbWVudENvbnRlbnQoZyh0LnF1ZXJ5U2VsZWN0b3JBbGwoa2UpKSx0aGlzLmdldFRpdGxlKCkpLGcodCkucmVtb3ZlQ2xhc3MoTmUrXCIgXCIrT2UpfSx0LnNldEVsZW1lbnRDb250ZW50PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5jb25maWcuaHRtbDtcIm9iamVjdFwiPT10eXBlb2YgZSYmKGUubm9kZVR5cGV8fGUuanF1ZXJ5KT9uP2coZSkucGFyZW50KCkuaXModCl8fHQuZW1wdHkoKS5hcHBlbmQoZSk6dC50ZXh0KGcoZSkudGV4dCgpKTp0W24/XCJodG1sXCI6XCJ0ZXh0XCJdKGUpfSx0LmdldFRpdGxlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtb3JpZ2luYWwtdGl0bGVcIik7cmV0dXJuIHR8fCh0PVwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuY29uZmlnLnRpdGxlP3RoaXMuY29uZmlnLnRpdGxlLmNhbGwodGhpcy5lbGVtZW50KTp0aGlzLmNvbmZpZy50aXRsZSksdH0sdC5fZ2V0Q29udGFpbmVyPWZ1bmN0aW9uKCl7cmV0dXJuITE9PT10aGlzLmNvbmZpZy5jb250YWluZXI/ZG9jdW1lbnQuYm9keTpfLmlzRWxlbWVudCh0aGlzLmNvbmZpZy5jb250YWluZXIpP2codGhpcy5jb25maWcuY29udGFpbmVyKTpnKGRvY3VtZW50KS5maW5kKHRoaXMuY29uZmlnLmNvbnRhaW5lcil9LHQuX2dldEF0dGFjaG1lbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGJlW3QudG9VcHBlckNhc2UoKV19LHQuX3NldExpc3RlbmVycz1mdW5jdGlvbigpe3ZhciBpPXRoaXM7dGhpcy5jb25maWcudHJpZ2dlci5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbih0KXtpZihcImNsaWNrXCI9PT10KWcoaS5lbGVtZW50KS5vbihpLmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLGkuY29uZmlnLnNlbGVjdG9yLGZ1bmN0aW9uKHQpe3JldHVybiBpLnRvZ2dsZSh0KX0pO2Vsc2UgaWYodCE9PVJlKXt2YXIgZT10PT09TGU/aS5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUVOVEVSOmkuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTixuPXQ9PT1MZT9pLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFTEVBVkU6aS5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVDtnKGkuZWxlbWVudCkub24oZSxpLmNvbmZpZy5zZWxlY3RvcixmdW5jdGlvbih0KXtyZXR1cm4gaS5fZW50ZXIodCl9KS5vbihuLGkuY29uZmlnLnNlbGVjdG9yLGZ1bmN0aW9uKHQpe3JldHVybiBpLl9sZWF2ZSh0KX0pfX0pLGcodGhpcy5lbGVtZW50KS5jbG9zZXN0KFwiLm1vZGFsXCIpLm9uKFwiaGlkZS5icy5tb2RhbFwiLGZ1bmN0aW9uKCl7aS5lbGVtZW50JiZpLmhpZGUoKX0pLHRoaXMuY29uZmlnLnNlbGVjdG9yP3RoaXMuY29uZmlnPWwoe30sdGhpcy5jb25maWcse3RyaWdnZXI6XCJtYW51YWxcIixzZWxlY3RvcjpcIlwifSk6dGhpcy5fZml4VGl0bGUoKX0sdC5fZml4VGl0bGU9ZnVuY3Rpb24oKXt2YXIgdD10eXBlb2YgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtb3JpZ2luYWwtdGl0bGVcIik7KHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKXx8XCJzdHJpbmdcIiE9PXQpJiYodGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtb3JpZ2luYWwtdGl0bGVcIix0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGl0bGVcIil8fFwiXCIpLHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLFwiXCIpKX0sdC5fZW50ZXI9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZOyhlPWV8fGcodC5jdXJyZW50VGFyZ2V0KS5kYXRhKG4pKXx8KGU9bmV3IHRoaXMuY29uc3RydWN0b3IodC5jdXJyZW50VGFyZ2V0LHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpLGcodC5jdXJyZW50VGFyZ2V0KS5kYXRhKG4sZSkpLHQmJihlLl9hY3RpdmVUcmlnZ2VyW1wiZm9jdXNpblwiPT09dC50eXBlP2plOkxlXT0hMCksZyhlLmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoT2UpfHxlLl9ob3ZlclN0YXRlPT09RGU/ZS5faG92ZXJTdGF0ZT1EZTooY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLGUuX2hvdmVyU3RhdGU9RGUsZS5jb25maWcuZGVsYXkmJmUuY29uZmlnLmRlbGF5LnNob3c/ZS5fdGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5faG92ZXJTdGF0ZT09PURlJiZlLnNob3coKX0sZS5jb25maWcuZGVsYXkuc2hvdyk6ZS5zaG93KCkpfSx0Ll9sZWF2ZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7KGU9ZXx8Zyh0LmN1cnJlbnRUYXJnZXQpLmRhdGEobikpfHwoZT1uZXcgdGhpcy5jb25zdHJ1Y3Rvcih0LmN1cnJlbnRUYXJnZXQsdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSksZyh0LmN1cnJlbnRUYXJnZXQpLmRhdGEobixlKSksdCYmKGUuX2FjdGl2ZVRyaWdnZXJbXCJmb2N1c291dFwiPT09dC50eXBlP2plOkxlXT0hMSksZS5faXNXaXRoQWN0aXZlVHJpZ2dlcigpfHwoY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLGUuX2hvdmVyU3RhdGU9d2UsZS5jb25maWcuZGVsYXkmJmUuY29uZmlnLmRlbGF5LmhpZGU/ZS5fdGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5faG92ZXJTdGF0ZT09PXdlJiZlLmhpZGUoKX0sZS5jb25maWcuZGVsYXkuaGlkZSk6ZS5oaWRlKCkpfSx0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyPWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpaWYodGhpcy5fYWN0aXZlVHJpZ2dlclt0XSlyZXR1cm4hMDtyZXR1cm4hMX0sdC5fZ2V0Q29uZmlnPWZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZih0PWwoe30sdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LGcodGhpcy5lbGVtZW50KS5kYXRhKCksXCJvYmplY3RcIj09dHlwZW9mIHQmJnQ/dDp7fSkpLmRlbGF5JiYodC5kZWxheT17c2hvdzp0LmRlbGF5LGhpZGU6dC5kZWxheX0pLFwibnVtYmVyXCI9PXR5cGVvZiB0LnRpdGxlJiYodC50aXRsZT10LnRpdGxlLnRvU3RyaW5nKCkpLFwibnVtYmVyXCI9PXR5cGVvZiB0LmNvbnRlbnQmJih0LmNvbnRlbnQ9dC5jb250ZW50LnRvU3RyaW5nKCkpLF8udHlwZUNoZWNrQ29uZmlnKHBlLHQsdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksdH0sdC5fZ2V0RGVsZWdhdGVDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17fTtpZih0aGlzLmNvbmZpZylmb3IodmFyIGUgaW4gdGhpcy5jb25maWcpdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VdIT09dGhpcy5jb25maWdbZV0mJih0W2VdPXRoaXMuY29uZmlnW2VdKTtyZXR1cm4gdH0sdC5fY2xlYW5UaXBDbGFzcz1mdW5jdGlvbigpe3ZhciB0PWcodGhpcy5nZXRUaXBFbGVtZW50KCkpLGU9dC5hdHRyKFwiY2xhc3NcIikubWF0Y2goVGUpO251bGwhPT1lJiZlLmxlbmd0aCYmdC5yZW1vdmVDbGFzcyhlLmpvaW4oXCJcIikpfSx0Ll9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2U9ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnN0YW5jZTt0aGlzLnRpcD1lLnBvcHBlcix0aGlzLl9jbGVhblRpcENsYXNzKCksdGhpcy5hZGRBdHRhY2htZW50Q2xhc3ModGhpcy5fZ2V0QXR0YWNobWVudCh0LnBsYWNlbWVudCkpfSx0Ll9maXhUcmFuc2l0aW9uPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRUaXBFbGVtZW50KCksZT10aGlzLmNvbmZpZy5hbmltYXRpb247bnVsbD09PXQuZ2V0QXR0cmlidXRlKFwieC1wbGFjZW1lbnRcIikmJihnKHQpLnJlbW92ZUNsYXNzKE5lKSx0aGlzLmNvbmZpZy5hbmltYXRpb249ITEsdGhpcy5oaWRlKCksdGhpcy5zaG93KCksdGhpcy5jb25maWcuYW5pbWF0aW9uPWUpfSxpLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PWcodGhpcykuZGF0YSh2ZSksZT1cIm9iamVjdFwiPT10eXBlb2YgbiYmbjtpZigodHx8IS9kaXNwb3NlfGhpZGUvLnRlc3QobikpJiYodHx8KHQ9bmV3IGkodGhpcyxlKSxnKHRoaXMpLmRhdGEodmUsdCkpLFwic3RyaW5nXCI9PXR5cGVvZiBuKSl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHRbbl0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytuKydcIicpO3Rbbl0oKX19KX0scyhpLG51bGwsW3trZXk6XCJWRVJTSU9OXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjIuMVwifX0se2tleTpcIkRlZmF1bHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gSWV9fSx7a2V5OlwiTkFNRVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBwZX19LHtrZXk6XCJEQVRBX0tFWVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB2ZX19LHtrZXk6XCJFdmVudFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBBZX19LHtrZXk6XCJFVkVOVF9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gRWV9fSx7a2V5OlwiRGVmYXVsdFR5cGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gU2V9fV0pLGl9KCk7Zy5mbltwZV09VWUuX2pRdWVyeUludGVyZmFjZSxnLmZuW3BlXS5Db25zdHJ1Y3Rvcj1VZSxnLmZuW3BlXS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGcuZm5bcGVdPXllLFVlLl9qUXVlcnlJbnRlcmZhY2V9O3ZhciBXZT1cInBvcG92ZXJcIix4ZT1cImJzLnBvcG92ZXJcIixGZT1cIi5cIit4ZSxxZT1nLmZuW1dlXSxNZT1cImJzLXBvcG92ZXJcIixLZT1uZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIrTWUrXCJcXFxcUytcIixcImdcIiksUWU9bCh7fSxVZS5EZWZhdWx0LHtwbGFjZW1lbnQ6XCJyaWdodFwiLHRyaWdnZXI6XCJjbGlja1wiLGNvbnRlbnQ6XCJcIix0ZW1wbGF0ZTonPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PjxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+PC9kaXY+J30pLEJlPWwoe30sVWUuRGVmYXVsdFR5cGUse2NvbnRlbnQ6XCIoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pXCJ9KSxWZT1cImZhZGVcIixZZT1cInNob3dcIixYZT1cIi5wb3BvdmVyLWhlYWRlclwiLHplPVwiLnBvcG92ZXItYm9keVwiLEdlPXtISURFOlwiaGlkZVwiK0ZlLEhJRERFTjpcImhpZGRlblwiK0ZlLFNIT1c6XCJzaG93XCIrRmUsU0hPV046XCJzaG93blwiK0ZlLElOU0VSVEVEOlwiaW5zZXJ0ZWRcIitGZSxDTElDSzpcImNsaWNrXCIrRmUsRk9DVVNJTjpcImZvY3VzaW5cIitGZSxGT0NVU09VVDpcImZvY3Vzb3V0XCIrRmUsTU9VU0VFTlRFUjpcIm1vdXNlZW50ZXJcIitGZSxNT1VTRUxFQVZFOlwibW91c2VsZWF2ZVwiK0ZlfSxKZT1mdW5jdGlvbih0KXt2YXIgZSxuO2Z1bmN0aW9uIGkoKXtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9bj10LChlPWkpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKG4ucHJvdG90eXBlKSwoZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSkuX19wcm90b19fPW47dmFyIG89aS5wcm90b3R5cGU7cmV0dXJuIG8uaXNXaXRoQ29udGVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFRpdGxlKCl8fHRoaXMuX2dldENvbnRlbnQoKX0sby5hZGRBdHRhY2htZW50Q2xhc3M9ZnVuY3Rpb24odCl7Zyh0aGlzLmdldFRpcEVsZW1lbnQoKSkuYWRkQ2xhc3MoTWUrXCItXCIrdCl9LG8uZ2V0VGlwRWxlbWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRpcD10aGlzLnRpcHx8Zyh0aGlzLmNvbmZpZy50ZW1wbGF0ZSlbMF0sdGhpcy50aXB9LG8uc2V0Q29udGVudD1mdW5jdGlvbigpe3ZhciB0PWcodGhpcy5nZXRUaXBFbGVtZW50KCkpO3RoaXMuc2V0RWxlbWVudENvbnRlbnQodC5maW5kKFhlKSx0aGlzLmdldFRpdGxlKCkpO3ZhciBlPXRoaXMuX2dldENvbnRlbnQoKTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYoZT1lLmNhbGwodGhpcy5lbGVtZW50KSksdGhpcy5zZXRFbGVtZW50Q29udGVudCh0LmZpbmQoemUpLGUpLHQucmVtb3ZlQ2xhc3MoVmUrXCIgXCIrWWUpfSxvLl9nZXRDb250ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbnRlbnRcIil8fHRoaXMuY29uZmlnLmNvbnRlbnR9LG8uX2NsZWFuVGlwQ2xhc3M9ZnVuY3Rpb24oKXt2YXIgdD1nKHRoaXMuZ2V0VGlwRWxlbWVudCgpKSxlPXQuYXR0cihcImNsYXNzXCIpLm1hdGNoKEtlKTtudWxsIT09ZSYmMDxlLmxlbmd0aCYmdC5yZW1vdmVDbGFzcyhlLmpvaW4oXCJcIikpfSxpLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciB0PWcodGhpcykuZGF0YSh4ZSksZT1cIm9iamVjdFwiPT10eXBlb2Ygbj9uOm51bGw7aWYoKHR8fCEvZGlzcG9zZXxoaWRlLy50ZXN0KG4pKSYmKHR8fCh0PW5ldyBpKHRoaXMsZSksZyh0aGlzKS5kYXRhKHhlLHQpKSxcInN0cmluZ1wiPT10eXBlb2Ygbikpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB0W25dKXRocm93IG5ldyBUeXBlRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicrbisnXCInKTt0W25dKCl9fSl9LHMoaSxudWxsLFt7a2V5OlwiVkVSU0lPTlwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiNC4yLjFcIn19LHtrZXk6XCJEZWZhdWx0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFFlfX0se2tleTpcIk5BTUVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gV2V9fSx7a2V5OlwiREFUQV9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4geGV9fSx7a2V5OlwiRXZlbnRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gR2V9fSx7a2V5OlwiRVZFTlRfS0VZXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEZlfX0se2tleTpcIkRlZmF1bHRUeXBlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJlfX1dKSxpfShVZSk7Zy5mbltXZV09SmUuX2pRdWVyeUludGVyZmFjZSxnLmZuW1dlXS5Db25zdHJ1Y3Rvcj1KZSxnLmZuW1dlXS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGcuZm5bV2VdPXFlLEplLl9qUXVlcnlJbnRlcmZhY2V9O3ZhciBaZT1cInNjcm9sbHNweVwiLCRlPVwiYnMuc2Nyb2xsc3B5XCIsdG49XCIuXCIrJGUsZW49Zy5mbltaZV0sbm49e29mZnNldDoxMCxtZXRob2Q6XCJhdXRvXCIsdGFyZ2V0OlwiXCJ9LG9uPXtvZmZzZXQ6XCJudW1iZXJcIixtZXRob2Q6XCJzdHJpbmdcIix0YXJnZXQ6XCIoc3RyaW5nfGVsZW1lbnQpXCJ9LHJuPXtBQ1RJVkFURTpcImFjdGl2YXRlXCIrdG4sU0NST0xMOlwic2Nyb2xsXCIrdG4sTE9BRF9EQVRBX0FQSTpcImxvYWRcIit0bitcIi5kYXRhLWFwaVwifSxzbj1cImRyb3Bkb3duLWl0ZW1cIixhbj1cImFjdGl2ZVwiLGxuPSdbZGF0YS1zcHk9XCJzY3JvbGxcIl0nLGNuPVwiLm5hdiwgLmxpc3QtZ3JvdXBcIixobj1cIi5uYXYtbGlua1wiLHVuPVwiLm5hdi1pdGVtXCIsZm49XCIubGlzdC1ncm91cC1pdGVtXCIsZG49XCIuZHJvcGRvd25cIixnbj1cIi5kcm9wZG93bi1pdGVtXCIsX249XCIuZHJvcGRvd24tdG9nZ2xlXCIsbW49XCJvZmZzZXRcIixwbj1cInBvc2l0aW9uXCIsdm49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHQsZSl7dmFyIG49dGhpczt0aGlzLl9lbGVtZW50PXQsdGhpcy5fc2Nyb2xsRWxlbWVudD1cIkJPRFlcIj09PXQudGFnTmFtZT93aW5kb3c6dCx0aGlzLl9jb25maWc9dGhpcy5fZ2V0Q29uZmlnKGUpLHRoaXMuX3NlbGVjdG9yPXRoaXMuX2NvbmZpZy50YXJnZXQrXCIgXCIraG4rXCIsXCIrdGhpcy5fY29uZmlnLnRhcmdldCtcIiBcIitmbitcIixcIit0aGlzLl9jb25maWcudGFyZ2V0K1wiIFwiK2duLHRoaXMuX29mZnNldHM9W10sdGhpcy5fdGFyZ2V0cz1bXSx0aGlzLl9hY3RpdmVUYXJnZXQ9bnVsbCx0aGlzLl9zY3JvbGxIZWlnaHQ9MCxnKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9uKHJuLlNDUk9MTCxmdW5jdGlvbih0KXtyZXR1cm4gbi5fcHJvY2Vzcyh0KX0pLHRoaXMucmVmcmVzaCgpLHRoaXMuX3Byb2Nlc3MoKX12YXIgdD1uLnByb3RvdHlwZTtyZXR1cm4gdC5yZWZyZXNoPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMuX3Njcm9sbEVsZW1lbnQ9PT10aGlzLl9zY3JvbGxFbGVtZW50LndpbmRvdz9tbjpwbixvPVwiYXV0b1wiPT09dGhpcy5fY29uZmlnLm1ldGhvZD90OnRoaXMuX2NvbmZpZy5tZXRob2Qscj1vPT09cG4/dGhpcy5fZ2V0U2Nyb2xsVG9wKCk6MDt0aGlzLl9vZmZzZXRzPVtdLHRoaXMuX3RhcmdldHM9W10sdGhpcy5fc2Nyb2xsSGVpZ2h0PXRoaXMuX2dldFNjcm9sbEhlaWdodCgpLFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLl9zZWxlY3RvcikpLm1hcChmdW5jdGlvbih0KXt2YXIgZSxuPV8uZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0KTtpZihuJiYoZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKG4pKSxlKXt2YXIgaT1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKGkud2lkdGh8fGkuaGVpZ2h0KXJldHVybltnKGUpW29dKCkudG9wK3Isbl19cmV0dXJuIG51bGx9KS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHR9KS5zb3J0KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbMF0tZVswXX0pLmZvckVhY2goZnVuY3Rpb24odCl7ZS5fb2Zmc2V0cy5wdXNoKHRbMF0pLGUuX3RhcmdldHMucHVzaCh0WzFdKX0pfSx0LmRpc3Bvc2U9ZnVuY3Rpb24oKXtnLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwkZSksZyh0aGlzLl9zY3JvbGxFbGVtZW50KS5vZmYodG4pLHRoaXMuX2VsZW1lbnQ9bnVsbCx0aGlzLl9zY3JvbGxFbGVtZW50PW51bGwsdGhpcy5fY29uZmlnPW51bGwsdGhpcy5fc2VsZWN0b3I9bnVsbCx0aGlzLl9vZmZzZXRzPW51bGwsdGhpcy5fdGFyZ2V0cz1udWxsLHRoaXMuX2FjdGl2ZVRhcmdldD1udWxsLHRoaXMuX3Njcm9sbEhlaWdodD1udWxsfSx0Ll9nZXRDb25maWc9ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mKHQ9bCh7fSxubixcIm9iamVjdFwiPT10eXBlb2YgdCYmdD90Ont9KSkudGFyZ2V0KXt2YXIgZT1nKHQudGFyZ2V0KS5hdHRyKFwiaWRcIik7ZXx8KGU9Xy5nZXRVSUQoWmUpLGcodC50YXJnZXQpLmF0dHIoXCJpZFwiLGUpKSx0LnRhcmdldD1cIiNcIitlfXJldHVybiBfLnR5cGVDaGVja0NvbmZpZyhaZSx0LG9uKSx0fSx0Ll9nZXRTY3JvbGxUb3A9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudD09PXdpbmRvdz90aGlzLl9zY3JvbGxFbGVtZW50LnBhZ2VZT2Zmc2V0OnRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsVG9wfSx0Ll9nZXRTY3JvbGxIZWlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxIZWlnaHR8fE1hdGgubWF4KGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpfSx0Ll9nZXRPZmZzZXRIZWlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudD09PXdpbmRvdz93aW5kb3cuaW5uZXJIZWlnaHQ6dGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHR9LHQuX3Byb2Nlc3M9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9nZXRTY3JvbGxUb3AoKSt0aGlzLl9jb25maWcub2Zmc2V0LGU9dGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCksbj10aGlzLl9jb25maWcub2Zmc2V0K2UtdGhpcy5fZ2V0T2Zmc2V0SGVpZ2h0KCk7aWYodGhpcy5fc2Nyb2xsSGVpZ2h0IT09ZSYmdGhpcy5yZWZyZXNoKCksbjw9dCl7dmFyIGk9dGhpcy5fdGFyZ2V0c1t0aGlzLl90YXJnZXRzLmxlbmd0aC0xXTt0aGlzLl9hY3RpdmVUYXJnZXQhPT1pJiZ0aGlzLl9hY3RpdmF0ZShpKX1lbHNle2lmKHRoaXMuX2FjdGl2ZVRhcmdldCYmdDx0aGlzLl9vZmZzZXRzWzBdJiYwPHRoaXMuX29mZnNldHNbMF0pcmV0dXJuIHRoaXMuX2FjdGl2ZVRhcmdldD1udWxsLHZvaWQgdGhpcy5fY2xlYXIoKTtmb3IodmFyIG89dGhpcy5fb2Zmc2V0cy5sZW5ndGg7by0tOyl7dGhpcy5fYWN0aXZlVGFyZ2V0IT09dGhpcy5fdGFyZ2V0c1tvXSYmdD49dGhpcy5fb2Zmc2V0c1tvXSYmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB0aGlzLl9vZmZzZXRzW28rMV18fHQ8dGhpcy5fb2Zmc2V0c1tvKzFdKSYmdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tvXSl9fX0sdC5fYWN0aXZhdGU9ZnVuY3Rpb24oZSl7dGhpcy5fYWN0aXZlVGFyZ2V0PWUsdGhpcy5fY2xlYXIoKTt2YXIgdD10aGlzLl9zZWxlY3Rvci5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0KydbZGF0YS10YXJnZXQ9XCInK2UrJ1wiXSwnK3QrJ1tocmVmPVwiJytlKydcIl0nfSksbj1nKFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0LmpvaW4oXCIsXCIpKSkpO24uaGFzQ2xhc3Moc24pPyhuLmNsb3Nlc3QoZG4pLmZpbmQoX24pLmFkZENsYXNzKGFuKSxuLmFkZENsYXNzKGFuKSk6KG4uYWRkQ2xhc3MoYW4pLG4ucGFyZW50cyhjbikucHJldihobitcIiwgXCIrZm4pLmFkZENsYXNzKGFuKSxuLnBhcmVudHMoY24pLnByZXYodW4pLmNoaWxkcmVuKGhuKS5hZGRDbGFzcyhhbikpLGcodGhpcy5fc2Nyb2xsRWxlbWVudCkudHJpZ2dlcihybi5BQ1RJVkFURSx7cmVsYXRlZFRhcmdldDplfSl9LHQuX2NsZWFyPWZ1bmN0aW9uKCl7W10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuX3NlbGVjdG9yKSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNsYXNzTGlzdC5jb250YWlucyhhbil9KS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNsYXNzTGlzdC5yZW1vdmUoYW4pfSl9LG4uX2pRdWVyeUludGVyZmFjZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9Zyh0aGlzKS5kYXRhKCRlKTtpZih0fHwodD1uZXcgbih0aGlzLFwib2JqZWN0XCI9PXR5cGVvZiBlJiZlKSxnKHRoaXMpLmRhdGEoJGUsdCkpLFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgdFtlXSl0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK2UrJ1wiJyk7dFtlXSgpfX0pfSxzKG4sbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMi4xXCJ9fSx7a2V5OlwiRGVmYXVsdFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBubn19XSksbn0oKTtnKHdpbmRvdykub24ocm4uTE9BRF9EQVRBX0FQSSxmdW5jdGlvbigpe2Zvcih2YXIgdD1bXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwobG4pKSxlPXQubGVuZ3RoO2UtLTspe3ZhciBuPWcodFtlXSk7dm4uX2pRdWVyeUludGVyZmFjZS5jYWxsKG4sbi5kYXRhKCkpfX0pLGcuZm5bWmVdPXZuLl9qUXVlcnlJbnRlcmZhY2UsZy5mbltaZV0uQ29uc3RydWN0b3I9dm4sZy5mbltaZV0ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBnLmZuW1plXT1lbix2bi5falF1ZXJ5SW50ZXJmYWNlfTt2YXIgRW49XCJicy50YWJcIix5bj1cIi5cIitFbixDbj1nLmZuLnRhYixUbj17SElERTpcImhpZGVcIit5bixISURERU46XCJoaWRkZW5cIit5bixTSE9XOlwic2hvd1wiK3luLFNIT1dOOlwic2hvd25cIit5bixDTElDS19EQVRBX0FQSTpcImNsaWNrXCIreW4rXCIuZGF0YS1hcGlcIn0sU249XCJkcm9wZG93bi1tZW51XCIsYm49XCJhY3RpdmVcIixJbj1cImRpc2FibGVkXCIsRG49XCJmYWRlXCIsd249XCJzaG93XCIsQW49XCIuZHJvcGRvd25cIixObj1cIi5uYXYsIC5saXN0LWdyb3VwXCIsT249XCIuYWN0aXZlXCIsa249XCI+IGxpID4gLmFjdGl2ZVwiLFBuPSdbZGF0YS10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLXRvZ2dsZT1cImxpc3RcIl0nLExuPVwiLmRyb3Bkb3duLXRvZ2dsZVwiLGpuPVwiPiAuZHJvcGRvd24tbWVudSAuYWN0aXZlXCIsSG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBpKHQpe3RoaXMuX2VsZW1lbnQ9dH12YXIgdD1pLnByb3RvdHlwZTtyZXR1cm4gdC5zaG93PWZ1bmN0aW9uKCl7dmFyIG49dGhpcztpZighKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSYmdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJmcodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoYm4pfHxnKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKEluKSkpe3ZhciB0LGksZT1nKHRoaXMuX2VsZW1lbnQpLmNsb3Nlc3QoTm4pWzBdLG89Xy5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO2lmKGUpe3ZhciByPVwiVUxcIj09PWUubm9kZU5hbWV8fFwiT0xcIj09PWUubm9kZU5hbWU/a246T247aT0oaT1nLm1ha2VBcnJheShnKGUpLmZpbmQocikpKVtpLmxlbmd0aC0xXX12YXIgcz1nLkV2ZW50KFRuLkhJREUse3JlbGF0ZWRUYXJnZXQ6dGhpcy5fZWxlbWVudH0pLGE9Zy5FdmVudChUbi5TSE9XLHtyZWxhdGVkVGFyZ2V0Oml9KTtpZihpJiZnKGkpLnRyaWdnZXIocyksZyh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKGEpLCFhLmlzRGVmYXVsdFByZXZlbnRlZCgpJiYhcy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSl7byYmKHQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvKSksdGhpcy5fYWN0aXZhdGUodGhpcy5fZWxlbWVudCxlKTt2YXIgbD1mdW5jdGlvbigpe3ZhciB0PWcuRXZlbnQoVG4uSElEREVOLHtyZWxhdGVkVGFyZ2V0Om4uX2VsZW1lbnR9KSxlPWcuRXZlbnQoVG4uU0hPV04se3JlbGF0ZWRUYXJnZXQ6aX0pO2coaSkudHJpZ2dlcih0KSxnKG4uX2VsZW1lbnQpLnRyaWdnZXIoZSl9O3Q/dGhpcy5fYWN0aXZhdGUodCx0LnBhcmVudE5vZGUsbCk6bCgpfX19LHQuZGlzcG9zZT1mdW5jdGlvbigpe2cucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LEVuKSx0aGlzLl9lbGVtZW50PW51bGx9LHQuX2FjdGl2YXRlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10aGlzLG89KCFlfHxcIlVMXCIhPT1lLm5vZGVOYW1lJiZcIk9MXCIhPT1lLm5vZGVOYW1lP2coZSkuY2hpbGRyZW4oT24pOmcoZSkuZmluZChrbikpWzBdLHI9biYmbyYmZyhvKS5oYXNDbGFzcyhEbikscz1mdW5jdGlvbigpe3JldHVybiBpLl90cmFuc2l0aW9uQ29tcGxldGUodCxvLG4pfTtpZihvJiZyKXt2YXIgYT1fLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KG8pO2cobykucmVtb3ZlQ2xhc3Mod24pLm9uZShfLlRSQU5TSVRJT05fRU5ELHMpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGEpfWVsc2UgcygpfSx0Ll90cmFuc2l0aW9uQ29tcGxldGU9ZnVuY3Rpb24odCxlLG4pe2lmKGUpe2coZSkucmVtb3ZlQ2xhc3MoYm4pO3ZhciBpPWcoZS5wYXJlbnROb2RlKS5maW5kKGpuKVswXTtpJiZnKGkpLnJlbW92ZUNsYXNzKGJuKSxcInRhYlwiPT09ZS5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpJiZlLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwhMSl9aWYoZyh0KS5hZGRDbGFzcyhibiksXCJ0YWJcIj09PXQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSYmdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsITApLF8ucmVmbG93KHQpLGcodCkuYWRkQ2xhc3Mod24pLHQucGFyZW50Tm9kZSYmZyh0LnBhcmVudE5vZGUpLmhhc0NsYXNzKFNuKSl7dmFyIG89Zyh0KS5jbG9zZXN0KEFuKVswXTtpZihvKXt2YXIgcj1bXS5zbGljZS5jYWxsKG8ucXVlcnlTZWxlY3RvckFsbChMbikpO2cocikuYWRkQ2xhc3MoYm4pfXQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCEwKX1uJiZuKCl9LGkuX2pRdWVyeUludGVyZmFjZT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9Zyh0aGlzKSxlPXQuZGF0YShFbik7aWYoZXx8KGU9bmV3IGkodGhpcyksdC5kYXRhKEVuLGUpKSxcInN0cmluZ1wiPT10eXBlb2Ygbil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGVbbl0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytuKydcIicpO2Vbbl0oKX19KX0scyhpLG51bGwsW3trZXk6XCJWRVJTSU9OXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjIuMVwifX1dKSxpfSgpO2coZG9jdW1lbnQpLm9uKFRuLkNMSUNLX0RBVEFfQVBJLFBuLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxIbi5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoZyh0aGlzKSxcInNob3dcIil9KSxnLmZuLnRhYj1Ibi5falF1ZXJ5SW50ZXJmYWNlLGcuZm4udGFiLkNvbnN0cnVjdG9yPUhuLGcuZm4udGFiLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gZy5mbi50YWI9Q24sSG4uX2pRdWVyeUludGVyZmFjZX07dmFyIFJuPVwidG9hc3RcIixVbj1cImJzLnRvYXN0XCIsV249XCIuXCIrVW4seG49Zy5mbltSbl0sRm49e0NMSUNLX0RJU01JU1M6XCJjbGljay5kaXNtaXNzXCIrV24sSElERTpcImhpZGVcIitXbixISURERU46XCJoaWRkZW5cIitXbixTSE9XOlwic2hvd1wiK1duLFNIT1dOOlwic2hvd25cIitXbn0scW49XCJmYWRlXCIsTW49XCJoaWRlXCIsS249XCJzaG93XCIsUW49XCJzaG93aW5nXCIsQm49e2FuaW1hdGlvbjpcImJvb2xlYW5cIixhdXRvaGlkZTpcImJvb2xlYW5cIixkZWxheTpcIm51bWJlclwifSxWbj17YW5pbWF0aW9uOiEwLGF1dG9oaWRlOiEwLGRlbGF5OjUwMH0sWW49J1tkYXRhLWRpc21pc3M9XCJ0b2FzdFwiXScsWG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBpKHQsZSl7dGhpcy5fZWxlbWVudD10LHRoaXMuX2NvbmZpZz10aGlzLl9nZXRDb25maWcoZSksdGhpcy5fdGltZW91dD1udWxsLHRoaXMuX3NldExpc3RlbmVycygpfXZhciB0PWkucHJvdG90eXBlO3JldHVybiB0LnNob3c9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2codGhpcy5fZWxlbWVudCkudHJpZ2dlcihGbi5TSE9XKSx0aGlzLl9jb25maWcuYW5pbWF0aW9uJiZ0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQocW4pO3ZhciBlPWZ1bmN0aW9uKCl7dC5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFFuKSx0Ll9lbGVtZW50LmNsYXNzTGlzdC5hZGQoS24pLGcodC5fZWxlbWVudCkudHJpZ2dlcihGbi5TSE9XTiksdC5fY29uZmlnLmF1dG9oaWRlJiZ0LmhpZGUoKX07aWYodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKE1uKSx0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoUW4pLHRoaXMuX2NvbmZpZy5hbmltYXRpb24pe3ZhciBuPV8uZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7Zyh0aGlzLl9lbGVtZW50KS5vbmUoXy5UUkFOU0lUSU9OX0VORCxlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChuKX1lbHNlIGUoKX0sdC5oaWRlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoS24pJiYoZyh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKEZuLkhJREUpLHQ/dGhpcy5fY2xvc2UoKTp0aGlzLl90aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl9jbG9zZSgpfSx0aGlzLl9jb25maWcuZGVsYXkpKX0sdC5kaXNwb3NlPWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLHRoaXMuX3RpbWVvdXQ9bnVsbCx0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhLbikmJnRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShLbiksZyh0aGlzLl9lbGVtZW50KS5vZmYoRm4uQ0xJQ0tfRElTTUlTUyksZy5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsVW4pLHRoaXMuX2VsZW1lbnQ9bnVsbCx0aGlzLl9jb25maWc9bnVsbH0sdC5fZ2V0Q29uZmlnPWZ1bmN0aW9uKHQpe3JldHVybiB0PWwoe30sVm4sZyh0aGlzLl9lbGVtZW50KS5kYXRhKCksXCJvYmplY3RcIj09dHlwZW9mIHQmJnQ/dDp7fSksXy50eXBlQ2hlY2tDb25maWcoUm4sdCx0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSx0fSx0Ll9zZXRMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2codGhpcy5fZWxlbWVudCkub24oRm4uQ0xJQ0tfRElTTUlTUyxZbixmdW5jdGlvbigpe3JldHVybiB0LmhpZGUoITApfSl9LHQuX2Nsb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPWZ1bmN0aW9uKCl7dC5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKE1uKSxnKHQuX2VsZW1lbnQpLnRyaWdnZXIoRm4uSElEREVOKX07aWYodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKEtuKSx0aGlzLl9jb25maWcuYW5pbWF0aW9uKXt2YXIgbj1fLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO2codGhpcy5fZWxlbWVudCkub25lKF8uVFJBTlNJVElPTl9FTkQsZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQobil9ZWxzZSBlKCl9LGkuX2pRdWVyeUludGVyZmFjZT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9Zyh0aGlzKSxlPXQuZGF0YShVbik7aWYoZXx8KGU9bmV3IGkodGhpcyxcIm9iamVjdFwiPT10eXBlb2YgbiYmbiksdC5kYXRhKFVuLGUpKSxcInN0cmluZ1wiPT10eXBlb2Ygbil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGVbbl0pdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytuKydcIicpO2Vbbl0odGhpcyl9fSl9LHMoaSxudWxsLFt7a2V5OlwiVkVSU0lPTlwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiNC4yLjFcIn19LHtrZXk6XCJEZWZhdWx0VHlwZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBCbn19XSksaX0oKTtnLmZuW1JuXT1Ybi5falF1ZXJ5SW50ZXJmYWNlLGcuZm5bUm5dLkNvbnN0cnVjdG9yPVhuLGcuZm5bUm5dLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gZy5mbltSbl09eG4sWG4uX2pRdWVyeUludGVyZmFjZX0sZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQm9vdHN0cmFwJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnkuIGpRdWVyeSBtdXN0IGJlIGluY2x1ZGVkIGJlZm9yZSBCb290c3RyYXAncyBKYXZhU2NyaXB0LlwiKTt2YXIgdD1nLmZuLmpxdWVyeS5zcGxpdChcIiBcIilbMF0uc3BsaXQoXCIuXCIpO2lmKHRbMF08MiYmdFsxXTw5fHwxPT09dFswXSYmOT09PXRbMV0mJnRbMl08MXx8NDw9dFswXSl0aHJvdyBuZXcgRXJyb3IoXCJCb290c3RyYXAncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGF0IGxlYXN0IGpRdWVyeSB2MS45LjEgYnV0IGxlc3MgdGhhbiB2NC4wLjBcIil9KCksdC5VdGlsPV8sdC5BbGVydD1wLHQuQnV0dG9uPVAsdC5DYXJvdXNlbD1sdCx0LkNvbGxhcHNlPWJ0LHQuRHJvcGRvd249WnQsdC5Nb2RhbD1tZSx0LlBvcG92ZXI9SmUsdC5TY3JvbGxzcHk9dm4sdC5UYWI9SG4sdC5Ub2FzdD1Ybix0LlRvb2x0aXA9VWUsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KTtcbiIsIi8qIVxuICoganF1ZXJ5LmNvdW50ZXJ1cC5qcyAyLjEuMFxuICpcbiAqIENvcHlyaWdodCAyMDEzLCBCZW5qYW1pbiBJbnRhbCBodHRwOi8vZ2FtYml0LnBoIEBiZmludGFsXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgR1BMIHYyIExpY2Vuc2VcbiAqXG4gKiBBbWVuZGVkIGJ5IEplcmVteSBQYXJpcywgQ2lybyBNYXR0aWEgR29uYW5vIGFuZCBvdGhlcnNcbiAqXG4gKiBEYXRlOiBGZWIgMjQsIDIwMTdcbiAqL1xuIChmdW5jdGlvbigkKXtcInVzZSBzdHJpY3RcIjskLmZuLmNvdW50ZXJVcD1mdW5jdGlvbihvcHRpb25zKXt2YXIgc2V0dGluZ3M9JC5leHRlbmQoe3RpbWU6NDAwLGRlbGF5OjEwLG9mZnNldDoxMDAsYmVnaW5BdDowLGZvcm1hdHRlcjpmYWxzZSxjb250ZXh0Olwid2luZG93XCIsY2FsbGJhY2s6ZnVuY3Rpb24oKXt9fSxvcHRpb25zKSxzO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgJHRoaXM9JCh0aGlzKSxjb3VudGVyPXt0aW1lOiQodGhpcykuZGF0YShcImNvdW50ZXJ1cC10aW1lXCIpfHxzZXR0aW5ncy50aW1lLGRlbGF5OiQodGhpcykuZGF0YShcImNvdW50ZXJ1cC1kZWxheVwiKXx8c2V0dGluZ3MuZGVsYXksb2Zmc2V0OiQodGhpcykuZGF0YShcImNvdW50ZXJ1cC1vZmZzZXRcIil8fHNldHRpbmdzLm9mZnNldCxiZWdpbkF0OiQodGhpcykuZGF0YShcImNvdW50ZXJ1cC1iZWdpbmF0XCIpfHxzZXR0aW5ncy5iZWdpbkF0LGNvbnRleHQ6JCh0aGlzKS5kYXRhKFwiY291bnRlcnVwLWNvbnRleHRcIil8fHNldHRpbmdzLmNvbnRleHR9O3ZhciBjb3VudGVyVXBwZXI9ZnVuY3Rpb24oKXt2YXIgbnVtcz1bXTt2YXIgZGl2aXNpb25zPWNvdW50ZXIudGltZS9jb3VudGVyLmRlbGF5O3ZhciBudW09JCh0aGlzKS5hdHRyKFwiZGF0YS1udW1cIik/JCh0aGlzKS5hdHRyKFwiZGF0YS1udW1cIik6JHRoaXMudGV4dCgpO3ZhciBpc0NvbW1hPS9bMC05XSssWzAtOV0rLy50ZXN0KG51bSk7bnVtPW51bS5yZXBsYWNlKC8sL2csXCJcIik7dmFyIGRlY2ltYWxQbGFjZXM9KG51bS5zcGxpdChcIi5cIilbMV18fFtdKS5sZW5ndGg7aWYoY291bnRlci5iZWdpbkF0Pm51bSljb3VudGVyLmJlZ2luQXQ9bnVtO3ZhciBpc1RpbWU9L1swLTldKzpbMC05XSs6WzAtOV0rLy50ZXN0KG51bSk7aWYoaXNUaW1lKXt2YXIgdGltZXM9bnVtLnNwbGl0KFwiOlwiKSxtPTE7cz0wO3doaWxlKHRpbWVzLmxlbmd0aD4wKXtzKz1tKnBhcnNlSW50KHRpbWVzLnBvcCgpLDEwKTttKj02MH19Zm9yKHZhciBpPWRpdmlzaW9ucztpPj1jb3VudGVyLmJlZ2luQXQvbnVtKmRpdmlzaW9ucztpLS0pe3ZhciBuZXdOdW09cGFyc2VGbG9hdChudW0vZGl2aXNpb25zKmkpLnRvRml4ZWQoZGVjaW1hbFBsYWNlcyk7aWYoaXNUaW1lKXtuZXdOdW09cGFyc2VJbnQocy9kaXZpc2lvbnMqaSk7dmFyIGhvdXJzPXBhcnNlSW50KG5ld051bS8zNjAwKSUyNDt2YXIgbWludXRlcz1wYXJzZUludChuZXdOdW0vNjApJTYwO3ZhciBzZWNvbmRzPXBhcnNlSW50KG5ld051bSU2MCwxMCk7bmV3TnVtPShob3VyczwxMD9cIjBcIitob3Vyczpob3VycykrXCI6XCIrKG1pbnV0ZXM8MTA/XCIwXCIrbWludXRlczptaW51dGVzKStcIjpcIisoc2Vjb25kczwxMD9cIjBcIitzZWNvbmRzOnNlY29uZHMpfWlmKGlzQ29tbWEpe3doaWxlKC8oXFxkKykoXFxkezN9KS8udGVzdChuZXdOdW0udG9TdHJpbmcoKSkpe25ld051bT1uZXdOdW0udG9TdHJpbmcoKS5yZXBsYWNlKC8oXFxkKykoXFxkezN9KS8sXCIkMVwiK1wiLFwiK1wiJDJcIil9fWlmKHNldHRpbmdzLmZvcm1hdHRlcil7bmV3TnVtPXNldHRpbmdzLmZvcm1hdHRlci5jYWxsKHRoaXMsbmV3TnVtKX1udW1zLnVuc2hpZnQobmV3TnVtKX0kdGhpcy5kYXRhKFwiY291bnRlcnVwLW51bXNcIixudW1zKTskdGhpcy50ZXh0KGNvdW50ZXIuYmVnaW5BdCk7dmFyIGY9ZnVuY3Rpb24oKXtpZighJHRoaXMuZGF0YShcImNvdW50ZXJ1cC1udW1zXCIpKXtzZXR0aW5ncy5jYWxsYmFjay5jYWxsKHRoaXMpO3JldHVybn0kdGhpcy5odG1sKCR0aGlzLmRhdGEoXCJjb3VudGVydXAtbnVtc1wiKS5zaGlmdCgpKTtpZigkdGhpcy5kYXRhKFwiY291bnRlcnVwLW51bXNcIikubGVuZ3RoKXtzZXRUaW1lb3V0KCR0aGlzLmRhdGEoXCJjb3VudGVydXAtZnVuY1wiKSxjb3VudGVyLmRlbGF5KX1lbHNleyR0aGlzLmRhdGEoXCJjb3VudGVydXAtbnVtc1wiLG51bGwpOyR0aGlzLmRhdGEoXCJjb3VudGVydXAtZnVuY1wiLG51bGwpO3NldHRpbmdzLmNhbGxiYWNrLmNhbGwodGhpcyl9fTskdGhpcy5kYXRhKFwiY291bnRlcnVwLWZ1bmNcIixmKTtzZXRUaW1lb3V0KCR0aGlzLmRhdGEoXCJjb3VudGVydXAtZnVuY1wiKSxjb3VudGVyLmRlbGF5KX07JHRoaXMud2F5cG9pbnQoZnVuY3Rpb24oZGlyZWN0aW9uKXtjb3VudGVyVXBwZXIoKTt0aGlzLmRlc3Ryb3koKX0se29mZnNldDpjb3VudGVyLm9mZnNldCtcIiVcIixjb250ZXh0OmNvdW50ZXIuY29udGV4dH0pfSl9fSkoalF1ZXJ5KTtcbiIsIiFmdW5jdGlvbihuKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImpxdWVyeVwiXSxmdW5jdGlvbihlKXtyZXR1cm4gbihlKX0pOlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUuZXhwb3J0cz9leHBvcnRzPW4ocmVxdWlyZShcImpxdWVyeVwiKSk6bihqUXVlcnkpfShmdW5jdGlvbihuKXtmdW5jdGlvbiBlKG4pe3ZhciBlPTcuNTYyNSx0PTIuNzU7cmV0dXJuIG48MS90P2UqbipuOm48Mi90P2UqKG4tPTEuNS90KSpuKy43NTpuPDIuNS90P2UqKG4tPTIuMjUvdCkqbisuOTM3NTplKihuLT0yLjYyNS90KSpuKy45ODQzNzV9dm9pZCAwIT09bi5lYXNpbmcmJihuLmVhc2luZy5qc3dpbmc9bi5lYXNpbmcuc3dpbmcpO3ZhciB0PU1hdGgucG93LHU9TWF0aC5zcXJ0LHI9TWF0aC5zaW4saT1NYXRoLmNvcyxhPU1hdGguUEksYz0xLjcwMTU4LG89MS41MjUqYyxzPTIqYS8zLGY9MiphLzQuNTtuLmV4dGVuZChuLmVhc2luZyx7ZGVmOlwiZWFzZU91dFF1YWRcIixzd2luZzpmdW5jdGlvbihlKXtyZXR1cm4gbi5lYXNpbmdbbi5lYXNpbmcuZGVmXShlKX0sZWFzZUluUXVhZDpmdW5jdGlvbihuKXtyZXR1cm4gbipufSxlYXNlT3V0UXVhZDpmdW5jdGlvbihuKXtyZXR1cm4gMS0oMS1uKSooMS1uKX0sZWFzZUluT3V0UXVhZDpmdW5jdGlvbihuKXtyZXR1cm4gbjwuNT8yKm4qbjoxLXQoLTIqbisyLDIpLzJ9LGVhc2VJbkN1YmljOmZ1bmN0aW9uKG4pe3JldHVybiBuKm4qbn0sZWFzZU91dEN1YmljOmZ1bmN0aW9uKG4pe3JldHVybiAxLXQoMS1uLDMpfSxlYXNlSW5PdXRDdWJpYzpmdW5jdGlvbihuKXtyZXR1cm4gbjwuNT80Km4qbipuOjEtdCgtMipuKzIsMykvMn0sZWFzZUluUXVhcnQ6ZnVuY3Rpb24obil7cmV0dXJuIG4qbipuKm59LGVhc2VPdXRRdWFydDpmdW5jdGlvbihuKXtyZXR1cm4gMS10KDEtbiw0KX0sZWFzZUluT3V0UXVhcnQ6ZnVuY3Rpb24obil7cmV0dXJuIG48LjU/OCpuKm4qbipuOjEtdCgtMipuKzIsNCkvMn0sZWFzZUluUXVpbnQ6ZnVuY3Rpb24obil7cmV0dXJuIG4qbipuKm4qbn0sZWFzZU91dFF1aW50OmZ1bmN0aW9uKG4pe3JldHVybiAxLXQoMS1uLDUpfSxlYXNlSW5PdXRRdWludDpmdW5jdGlvbihuKXtyZXR1cm4gbjwuNT8xNipuKm4qbipuKm46MS10KC0yKm4rMiw1KS8yfSxlYXNlSW5TaW5lOmZ1bmN0aW9uKG4pe3JldHVybiAxLWkobiphLzIpfSxlYXNlT3V0U2luZTpmdW5jdGlvbihuKXtyZXR1cm4gcihuKmEvMil9LGVhc2VJbk91dFNpbmU6ZnVuY3Rpb24obil7cmV0dXJuLShpKGEqbiktMSkvMn0sZWFzZUluRXhwbzpmdW5jdGlvbihuKXtyZXR1cm4gMD09PW4/MDp0KDIsMTAqbi0xMCl9LGVhc2VPdXRFeHBvOmZ1bmN0aW9uKG4pe3JldHVybiAxPT09bj8xOjEtdCgyLC0xMCpuKX0sZWFzZUluT3V0RXhwbzpmdW5jdGlvbihuKXtyZXR1cm4gMD09PW4/MDoxPT09bj8xOm48LjU/dCgyLDIwKm4tMTApLzI6KDItdCgyLC0yMCpuKzEwKSkvMn0sZWFzZUluQ2lyYzpmdW5jdGlvbihuKXtyZXR1cm4gMS11KDEtdChuLDIpKX0sZWFzZU91dENpcmM6ZnVuY3Rpb24obil7cmV0dXJuIHUoMS10KG4tMSwyKSl9LGVhc2VJbk91dENpcmM6ZnVuY3Rpb24obil7cmV0dXJuIG48LjU/KDEtdSgxLXQoMipuLDIpKSkvMjoodSgxLXQoLTIqbisyLDIpKSsxKS8yfSxlYXNlSW5FbGFzdGljOmZ1bmN0aW9uKG4pe3JldHVybiAwPT09bj8wOjE9PT1uPzE6LXQoMiwxMCpuLTEwKSpyKCgxMCpuLTEwLjc1KSpzKX0sZWFzZU91dEVsYXN0aWM6ZnVuY3Rpb24obil7cmV0dXJuIDA9PT1uPzA6MT09PW4/MTp0KDIsLTEwKm4pKnIoKDEwKm4tLjc1KSpzKSsxfSxlYXNlSW5PdXRFbGFzdGljOmZ1bmN0aW9uKG4pe3JldHVybiAwPT09bj8wOjE9PT1uPzE6bjwuNT8tKHQoMiwyMCpuLTEwKSpyKCgyMCpuLTExLjEyNSkqZikpLzI6dCgyLC0yMCpuKzEwKSpyKCgyMCpuLTExLjEyNSkqZikvMisxfSxlYXNlSW5CYWNrOmZ1bmN0aW9uKG4pe3JldHVybihjKzEpKm4qbipuLWMqbipufSxlYXNlT3V0QmFjazpmdW5jdGlvbihuKXtyZXR1cm4gMSsoYysxKSp0KG4tMSwzKStjKnQobi0xLDIpfSxlYXNlSW5PdXRCYWNrOmZ1bmN0aW9uKG4pe3JldHVybiBuPC41P3QoMipuLDIpKig3LjE4OTgxOSpuLW8pLzI6KHQoMipuLTIsMikqKChvKzEpKigyKm4tMikrbykrMikvMn0sZWFzZUluQm91bmNlOmZ1bmN0aW9uKG4pe3JldHVybiAxLWUoMS1uKX0sZWFzZU91dEJvdW5jZTplLGVhc2VJbk91dEJvdW5jZTpmdW5jdGlvbihuKXtyZXR1cm4gbjwuNT8oMS1lKDEtMipuKSkvMjooMStlKDIqbi0xKSkvMn19KX0pO1xyXG4iLCIvKiFcbiAqIExpZ2h0Ym94IHYyLjEwLjBcbiAqIGJ5IExva2VzaCBEaGFrYXJcbiAqXG4gKiBNb3JlIGluZm86XG4gKiBodHRwOi8vbG9rZXNoZGhha2FyLmNvbS9wcm9qZWN0cy9saWdodGJveDIvXG4gKlxuICogQ29weXJpZ2h0IDIwMDcsIDIwMTggTG9rZXNoIERoYWthclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbG9rZXNoL2xpZ2h0Ym94Mi9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogQHByZXNlcnZlXG4gKi9cbiFmdW5jdGlvbihhLGIpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wianF1ZXJ5XCJdLGIpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP21vZHVsZS5leHBvcnRzPWIocmVxdWlyZShcImpxdWVyeVwiKSk6YS5saWdodGJveD1iKGEualF1ZXJ5KX0odGhpcyxmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIpe3RoaXMuYWxidW09W10sdGhpcy5jdXJyZW50SW1hZ2VJbmRleD12b2lkIDAsdGhpcy5pbml0KCksdGhpcy5vcHRpb25zPWEuZXh0ZW5kKHt9LHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdHMpLHRoaXMub3B0aW9uKGIpfXJldHVybiBiLmRlZmF1bHRzPXthbGJ1bUxhYmVsOlwiSW1hZ2UgJTEgb2YgJTJcIixhbHdheXNTaG93TmF2T25Ub3VjaERldmljZXM6ITEsZmFkZUR1cmF0aW9uOjYwMCxmaXRJbWFnZXNJblZpZXdwb3J0OiEwLGltYWdlRmFkZUR1cmF0aW9uOjYwMCxwb3NpdGlvbkZyb21Ub3A6NTAscmVzaXplRHVyYXRpb246NzAwLHNob3dJbWFnZU51bWJlckxhYmVsOiEwLHdyYXBBcm91bmQ6ITEsZGlzYWJsZVNjcm9sbGluZzohMSxzYW5pdGl6ZVRpdGxlOiExfSxiLnByb3RvdHlwZS5vcHRpb249ZnVuY3Rpb24oYil7YS5leHRlbmQodGhpcy5vcHRpb25zLGIpfSxiLnByb3RvdHlwZS5pbWFnZUNvdW50TGFiZWw9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5vcHRpb25zLmFsYnVtTGFiZWwucmVwbGFjZSgvJTEvZyxhKS5yZXBsYWNlKC8lMi9nLGIpfSxiLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7dmFyIGI9dGhpczthKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe2IuZW5hYmxlKCksYi5idWlsZCgpfSl9LGIucHJvdG90eXBlLmVuYWJsZT1mdW5jdGlvbigpe3ZhciBiPXRoaXM7YShcImJvZHlcIikub24oXCJjbGlja1wiLFwiYVtyZWxePWxpZ2h0Ym94XSwgYXJlYVtyZWxePWxpZ2h0Ym94XSwgYVtkYXRhLWxpZ2h0Ym94XSwgYXJlYVtkYXRhLWxpZ2h0Ym94XVwiLGZ1bmN0aW9uKGMpe3JldHVybiBiLnN0YXJ0KGEoYy5jdXJyZW50VGFyZ2V0KSksITF9KX0sYi5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oKXtpZighKGEoXCIjbGlnaHRib3hcIikubGVuZ3RoPjApKXt2YXIgYj10aGlzO2EoJzxkaXYgaWQ9XCJsaWdodGJveE92ZXJsYXlcIiBjbGFzcz1cImxpZ2h0Ym94T3ZlcmxheVwiPjwvZGl2PjxkaXYgaWQ9XCJsaWdodGJveFwiIGNsYXNzPVwibGlnaHRib3hcIj48ZGl2IGNsYXNzPVwibGItb3V0ZXJDb250YWluZXJcIj48ZGl2IGNsYXNzPVwibGItY29udGFpbmVyXCI+PGltZyBjbGFzcz1cImxiLWltYWdlXCIgc3JjPVwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBUC8vL3dBQUFDSDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUNSQUVBT3c9PVwiIC8+PGRpdiBjbGFzcz1cImxiLW5hdlwiPjxhIGNsYXNzPVwibGItcHJldlwiIGhyZWY9XCJcIiA+PC9hPjxhIGNsYXNzPVwibGItbmV4dFwiIGhyZWY9XCJcIiA+PC9hPjwvZGl2PjxkaXYgY2xhc3M9XCJsYi1sb2FkZXJcIj48YSBjbGFzcz1cImxiLWNhbmNlbFwiPjwvYT48L2Rpdj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVwibGItZGF0YUNvbnRhaW5lclwiPjxkaXYgY2xhc3M9XCJsYi1kYXRhXCI+PGRpdiBjbGFzcz1cImxiLWRldGFpbHNcIj48c3BhbiBjbGFzcz1cImxiLWNhcHRpb25cIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJsYi1udW1iZXJcIj48L3NwYW4+PC9kaXY+PGRpdiBjbGFzcz1cImxiLWNsb3NlQ29udGFpbmVyXCI+PGEgY2xhc3M9XCJsYi1jbG9zZVwiPjwvYT48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj4nKS5hcHBlbmRUbyhhKFwiYm9keVwiKSksdGhpcy4kbGlnaHRib3g9YShcIiNsaWdodGJveFwiKSx0aGlzLiRvdmVybGF5PWEoXCIjbGlnaHRib3hPdmVybGF5XCIpLHRoaXMuJG91dGVyQ29udGFpbmVyPXRoaXMuJGxpZ2h0Ym94LmZpbmQoXCIubGItb3V0ZXJDb250YWluZXJcIiksdGhpcy4kY29udGFpbmVyPXRoaXMuJGxpZ2h0Ym94LmZpbmQoXCIubGItY29udGFpbmVyXCIpLHRoaXMuJGltYWdlPXRoaXMuJGxpZ2h0Ym94LmZpbmQoXCIubGItaW1hZ2VcIiksdGhpcy4kbmF2PXRoaXMuJGxpZ2h0Ym94LmZpbmQoXCIubGItbmF2XCIpLHRoaXMuY29udGFpbmVyUGFkZGluZz17dG9wOnBhcnNlSW50KHRoaXMuJGNvbnRhaW5lci5jc3MoXCJwYWRkaW5nLXRvcFwiKSwxMCkscmlnaHQ6cGFyc2VJbnQodGhpcy4kY29udGFpbmVyLmNzcyhcInBhZGRpbmctcmlnaHRcIiksMTApLGJvdHRvbTpwYXJzZUludCh0aGlzLiRjb250YWluZXIuY3NzKFwicGFkZGluZy1ib3R0b21cIiksMTApLGxlZnQ6cGFyc2VJbnQodGhpcy4kY29udGFpbmVyLmNzcyhcInBhZGRpbmctbGVmdFwiKSwxMCl9LHRoaXMuaW1hZ2VCb3JkZXJXaWR0aD17dG9wOnBhcnNlSW50KHRoaXMuJGltYWdlLmNzcyhcImJvcmRlci10b3Atd2lkdGhcIiksMTApLHJpZ2h0OnBhcnNlSW50KHRoaXMuJGltYWdlLmNzcyhcImJvcmRlci1yaWdodC13aWR0aFwiKSwxMCksYm90dG9tOnBhcnNlSW50KHRoaXMuJGltYWdlLmNzcyhcImJvcmRlci1ib3R0b20td2lkdGhcIiksMTApLGxlZnQ6cGFyc2VJbnQodGhpcy4kaW1hZ2UuY3NzKFwiYm9yZGVyLWxlZnQtd2lkdGhcIiksMTApfSx0aGlzLiRvdmVybGF5LmhpZGUoKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtyZXR1cm4gYi5lbmQoKSwhMX0pLHRoaXMuJGxpZ2h0Ym94LmhpZGUoKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oYyl7cmV0dXJuXCJsaWdodGJveFwiPT09YShjLnRhcmdldCkuYXR0cihcImlkXCIpJiZiLmVuZCgpLCExfSksdGhpcy4kb3V0ZXJDb250YWluZXIub24oXCJjbGlja1wiLGZ1bmN0aW9uKGMpe3JldHVyblwibGlnaHRib3hcIj09PWEoYy50YXJnZXQpLmF0dHIoXCJpZFwiKSYmYi5lbmQoKSwhMX0pLHRoaXMuJGxpZ2h0Ym94LmZpbmQoXCIubGItcHJldlwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtyZXR1cm4gMD09PWIuY3VycmVudEltYWdlSW5kZXg/Yi5jaGFuZ2VJbWFnZShiLmFsYnVtLmxlbmd0aC0xKTpiLmNoYW5nZUltYWdlKGIuY3VycmVudEltYWdlSW5kZXgtMSksITF9KSx0aGlzLiRsaWdodGJveC5maW5kKFwiLmxiLW5leHRcIikub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7cmV0dXJuIGIuY3VycmVudEltYWdlSW5kZXg9PT1iLmFsYnVtLmxlbmd0aC0xP2IuY2hhbmdlSW1hZ2UoMCk6Yi5jaGFuZ2VJbWFnZShiLmN1cnJlbnRJbWFnZUluZGV4KzEpLCExfSksdGhpcy4kbmF2Lm9uKFwibW91c2Vkb3duXCIsZnVuY3Rpb24oYSl7Mz09PWEud2hpY2gmJihiLiRuYXYuY3NzKFwicG9pbnRlci1ldmVudHNcIixcIm5vbmVcIiksYi4kbGlnaHRib3gub25lKFwiY29udGV4dG1lbnVcIixmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aGlzLiRuYXYuY3NzKFwicG9pbnRlci1ldmVudHNcIixcImF1dG9cIil9LmJpbmQoYiksMCl9KSl9KSx0aGlzLiRsaWdodGJveC5maW5kKFwiLmxiLWxvYWRlciwgLmxiLWNsb3NlXCIpLm9uKFwiY2xpY2tcIixmdW5jdGlvbigpe3JldHVybiBiLmVuZCgpLCExfSl9fSxiLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2QuYWxidW0ucHVzaCh7YWx0OmEuYXR0cihcImRhdGEtYWx0XCIpLGxpbms6YS5hdHRyKFwiaHJlZlwiKSx0aXRsZTphLmF0dHIoXCJkYXRhLXRpdGxlXCIpfHxhLmF0dHIoXCJ0aXRsZVwiKX0pfXZhciBkPXRoaXMsZT1hKHdpbmRvdyk7ZS5vbihcInJlc2l6ZVwiLGEucHJveHkodGhpcy5zaXplT3ZlcmxheSx0aGlzKSksYShcInNlbGVjdCwgb2JqZWN0LCBlbWJlZFwiKS5jc3Moe3Zpc2liaWxpdHk6XCJoaWRkZW5cIn0pLHRoaXMuc2l6ZU92ZXJsYXkoKSx0aGlzLmFsYnVtPVtdO3ZhciBmLGc9MCxoPWIuYXR0cihcImRhdGEtbGlnaHRib3hcIik7aWYoaCl7Zj1hKGIucHJvcChcInRhZ05hbWVcIikrJ1tkYXRhLWxpZ2h0Ym94PVwiJytoKydcIl0nKTtmb3IodmFyIGk9MDtpPGYubGVuZ3RoO2k9KytpKWMoYShmW2ldKSksZltpXT09PWJbMF0mJihnPWkpfWVsc2UgaWYoXCJsaWdodGJveFwiPT09Yi5hdHRyKFwicmVsXCIpKWMoYik7ZWxzZXtmPWEoYi5wcm9wKFwidGFnTmFtZVwiKSsnW3JlbD1cIicrYi5hdHRyKFwicmVsXCIpKydcIl0nKTtmb3IodmFyIGo9MDtqPGYubGVuZ3RoO2o9KytqKWMoYShmW2pdKSksZltqXT09PWJbMF0mJihnPWopfXZhciBrPWUuc2Nyb2xsVG9wKCkrdGhpcy5vcHRpb25zLnBvc2l0aW9uRnJvbVRvcCxsPWUuc2Nyb2xsTGVmdCgpO3RoaXMuJGxpZ2h0Ym94LmNzcyh7dG9wOmsrXCJweFwiLGxlZnQ6bCtcInB4XCJ9KS5mYWRlSW4odGhpcy5vcHRpb25zLmZhZGVEdXJhdGlvbiksdGhpcy5vcHRpb25zLmRpc2FibGVTY3JvbGxpbmcmJmEoXCJodG1sXCIpLmFkZENsYXNzKFwibGItZGlzYWJsZS1zY3JvbGxpbmdcIiksdGhpcy5jaGFuZ2VJbWFnZShnKX0sYi5wcm90b3R5cGUuY2hhbmdlSW1hZ2U9ZnVuY3Rpb24oYil7dmFyIGM9dGhpczt0aGlzLmRpc2FibGVLZXlib2FyZE5hdigpO3ZhciBkPXRoaXMuJGxpZ2h0Ym94LmZpbmQoXCIubGItaW1hZ2VcIik7dGhpcy4kb3ZlcmxheS5mYWRlSW4odGhpcy5vcHRpb25zLmZhZGVEdXJhdGlvbiksYShcIi5sYi1sb2FkZXJcIikuZmFkZUluKFwic2xvd1wiKSx0aGlzLiRsaWdodGJveC5maW5kKFwiLmxiLWltYWdlLCAubGItbmF2LCAubGItcHJldiwgLmxiLW5leHQsIC5sYi1kYXRhQ29udGFpbmVyLCAubGItbnVtYmVycywgLmxiLWNhcHRpb25cIikuaGlkZSgpLHRoaXMuJG91dGVyQ29udGFpbmVyLmFkZENsYXNzKFwiYW5pbWF0aW5nXCIpO3ZhciBlPW5ldyBJbWFnZTtlLm9ubG9hZD1mdW5jdGlvbigpe3ZhciBmLGcsaCxpLGosaztkLmF0dHIoe2FsdDpjLmFsYnVtW2JdLmFsdCxzcmM6Yy5hbGJ1bVtiXS5saW5rfSksYShlKSxkLndpZHRoKGUud2lkdGgpLGQuaGVpZ2h0KGUuaGVpZ2h0KSxjLm9wdGlvbnMuZml0SW1hZ2VzSW5WaWV3cG9ydCYmKGs9YSh3aW5kb3cpLndpZHRoKCksaj1hKHdpbmRvdykuaGVpZ2h0KCksaT1rLWMuY29udGFpbmVyUGFkZGluZy5sZWZ0LWMuY29udGFpbmVyUGFkZGluZy5yaWdodC1jLmltYWdlQm9yZGVyV2lkdGgubGVmdC1jLmltYWdlQm9yZGVyV2lkdGgucmlnaHQtMjAsaD1qLWMuY29udGFpbmVyUGFkZGluZy50b3AtYy5jb250YWluZXJQYWRkaW5nLmJvdHRvbS1jLmltYWdlQm9yZGVyV2lkdGgudG9wLWMuaW1hZ2VCb3JkZXJXaWR0aC5ib3R0b20tMTIwLGMub3B0aW9ucy5tYXhXaWR0aCYmYy5vcHRpb25zLm1heFdpZHRoPGkmJihpPWMub3B0aW9ucy5tYXhXaWR0aCksYy5vcHRpb25zLm1heEhlaWdodCYmYy5vcHRpb25zLm1heEhlaWdodDxpJiYoaD1jLm9wdGlvbnMubWF4SGVpZ2h0KSwoZS53aWR0aD5pfHxlLmhlaWdodD5oKSYmKGUud2lkdGgvaT5lLmhlaWdodC9oPyhnPWksZj1wYXJzZUludChlLmhlaWdodC8oZS53aWR0aC9nKSwxMCksZC53aWR0aChnKSxkLmhlaWdodChmKSk6KGY9aCxnPXBhcnNlSW50KGUud2lkdGgvKGUuaGVpZ2h0L2YpLDEwKSxkLndpZHRoKGcpLGQuaGVpZ2h0KGYpKSkpLGMuc2l6ZUNvbnRhaW5lcihkLndpZHRoKCksZC5oZWlnaHQoKSl9LGUuc3JjPXRoaXMuYWxidW1bYl0ubGluayx0aGlzLmN1cnJlbnRJbWFnZUluZGV4PWJ9LGIucHJvdG90eXBlLnNpemVPdmVybGF5PWZ1bmN0aW9uKCl7dGhpcy4kb3ZlcmxheS53aWR0aChhKGRvY3VtZW50KS53aWR0aCgpKS5oZWlnaHQoYShkb2N1bWVudCkuaGVpZ2h0KCkpfSxiLnByb3RvdHlwZS5zaXplQ29udGFpbmVyPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe2QuJGxpZ2h0Ym94LmZpbmQoXCIubGItZGF0YUNvbnRhaW5lclwiKS53aWR0aChnKSxkLiRsaWdodGJveC5maW5kKFwiLmxiLXByZXZMaW5rXCIpLmhlaWdodChoKSxkLiRsaWdodGJveC5maW5kKFwiLmxiLW5leHRMaW5rXCIpLmhlaWdodChoKSxkLnNob3dJbWFnZSgpfXZhciBkPXRoaXMsZT10aGlzLiRvdXRlckNvbnRhaW5lci5vdXRlcldpZHRoKCksZj10aGlzLiRvdXRlckNvbnRhaW5lci5vdXRlckhlaWdodCgpLGc9YSt0aGlzLmNvbnRhaW5lclBhZGRpbmcubGVmdCt0aGlzLmNvbnRhaW5lclBhZGRpbmcucmlnaHQrdGhpcy5pbWFnZUJvcmRlcldpZHRoLmxlZnQrdGhpcy5pbWFnZUJvcmRlcldpZHRoLnJpZ2h0LGg9Yit0aGlzLmNvbnRhaW5lclBhZGRpbmcudG9wK3RoaXMuY29udGFpbmVyUGFkZGluZy5ib3R0b20rdGhpcy5pbWFnZUJvcmRlcldpZHRoLnRvcCt0aGlzLmltYWdlQm9yZGVyV2lkdGguYm90dG9tO2UhPT1nfHxmIT09aD90aGlzLiRvdXRlckNvbnRhaW5lci5hbmltYXRlKHt3aWR0aDpnLGhlaWdodDpofSx0aGlzLm9wdGlvbnMucmVzaXplRHVyYXRpb24sXCJzd2luZ1wiLGZ1bmN0aW9uKCl7YygpfSk6YygpfSxiLnByb3RvdHlwZS5zaG93SW1hZ2U9ZnVuY3Rpb24oKXt0aGlzLiRsaWdodGJveC5maW5kKFwiLmxiLWxvYWRlclwiKS5zdG9wKCEwKS5oaWRlKCksdGhpcy4kbGlnaHRib3guZmluZChcIi5sYi1pbWFnZVwiKS5mYWRlSW4odGhpcy5vcHRpb25zLmltYWdlRmFkZUR1cmF0aW9uKSx0aGlzLnVwZGF0ZU5hdigpLHRoaXMudXBkYXRlRGV0YWlscygpLHRoaXMucHJlbG9hZE5laWdoYm9yaW5nSW1hZ2VzKCksdGhpcy5lbmFibGVLZXlib2FyZE5hdigpfSxiLnByb3RvdHlwZS51cGRhdGVOYXY9ZnVuY3Rpb24oKXt2YXIgYT0hMTt0cnl7ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJUb3VjaEV2ZW50XCIpLGE9ISF0aGlzLm9wdGlvbnMuYWx3YXlzU2hvd05hdk9uVG91Y2hEZXZpY2VzfWNhdGNoKGEpe310aGlzLiRsaWdodGJveC5maW5kKFwiLmxiLW5hdlwiKS5zaG93KCksdGhpcy5hbGJ1bS5sZW5ndGg+MSYmKHRoaXMub3B0aW9ucy53cmFwQXJvdW5kPyhhJiZ0aGlzLiRsaWdodGJveC5maW5kKFwiLmxiLXByZXYsIC5sYi1uZXh0XCIpLmNzcyhcIm9wYWNpdHlcIixcIjFcIiksdGhpcy4kbGlnaHRib3guZmluZChcIi5sYi1wcmV2LCAubGItbmV4dFwiKS5zaG93KCkpOih0aGlzLmN1cnJlbnRJbWFnZUluZGV4PjAmJih0aGlzLiRsaWdodGJveC5maW5kKFwiLmxiLXByZXZcIikuc2hvdygpLGEmJnRoaXMuJGxpZ2h0Ym94LmZpbmQoXCIubGItcHJldlwiKS5jc3MoXCJvcGFjaXR5XCIsXCIxXCIpKSx0aGlzLmN1cnJlbnRJbWFnZUluZGV4PHRoaXMuYWxidW0ubGVuZ3RoLTEmJih0aGlzLiRsaWdodGJveC5maW5kKFwiLmxiLW5leHRcIikuc2hvdygpLGEmJnRoaXMuJGxpZ2h0Ym94LmZpbmQoXCIubGItbmV4dFwiKS5jc3MoXCJvcGFjaXR5XCIsXCIxXCIpKSkpfSxiLnByb3RvdHlwZS51cGRhdGVEZXRhaWxzPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcztpZih2b2lkIDAhPT10aGlzLmFsYnVtW3RoaXMuY3VycmVudEltYWdlSW5kZXhdLnRpdGxlJiZcIlwiIT09dGhpcy5hbGJ1bVt0aGlzLmN1cnJlbnRJbWFnZUluZGV4XS50aXRsZSl7dmFyIGM9dGhpcy4kbGlnaHRib3guZmluZChcIi5sYi1jYXB0aW9uXCIpO3RoaXMub3B0aW9ucy5zYW5pdGl6ZVRpdGxlP2MudGV4dCh0aGlzLmFsYnVtW3RoaXMuY3VycmVudEltYWdlSW5kZXhdLnRpdGxlKTpjLmh0bWwodGhpcy5hbGJ1bVt0aGlzLmN1cnJlbnRJbWFnZUluZGV4XS50aXRsZSksYy5mYWRlSW4oXCJmYXN0XCIpLmZpbmQoXCJhXCIpLm9uKFwiY2xpY2tcIixmdW5jdGlvbihiKXt2b2lkIDAhPT1hKHRoaXMpLmF0dHIoXCJ0YXJnZXRcIik/d2luZG93Lm9wZW4oYSh0aGlzKS5hdHRyKFwiaHJlZlwiKSxhKHRoaXMpLmF0dHIoXCJ0YXJnZXRcIikpOmxvY2F0aW9uLmhyZWY9YSh0aGlzKS5hdHRyKFwiaHJlZlwiKX0pfWlmKHRoaXMuYWxidW0ubGVuZ3RoPjEmJnRoaXMub3B0aW9ucy5zaG93SW1hZ2VOdW1iZXJMYWJlbCl7dmFyIGQ9dGhpcy5pbWFnZUNvdW50TGFiZWwodGhpcy5jdXJyZW50SW1hZ2VJbmRleCsxLHRoaXMuYWxidW0ubGVuZ3RoKTt0aGlzLiRsaWdodGJveC5maW5kKFwiLmxiLW51bWJlclwiKS50ZXh0KGQpLmZhZGVJbihcImZhc3RcIil9ZWxzZSB0aGlzLiRsaWdodGJveC5maW5kKFwiLmxiLW51bWJlclwiKS5oaWRlKCk7dGhpcy4kb3V0ZXJDb250YWluZXIucmVtb3ZlQ2xhc3MoXCJhbmltYXRpbmdcIiksdGhpcy4kbGlnaHRib3guZmluZChcIi5sYi1kYXRhQ29udGFpbmVyXCIpLmZhZGVJbih0aGlzLm9wdGlvbnMucmVzaXplRHVyYXRpb24sZnVuY3Rpb24oKXtyZXR1cm4gYi5zaXplT3ZlcmxheSgpfSl9LGIucHJvdG90eXBlLnByZWxvYWROZWlnaGJvcmluZ0ltYWdlcz1mdW5jdGlvbigpe2lmKHRoaXMuYWxidW0ubGVuZ3RoPnRoaXMuY3VycmVudEltYWdlSW5kZXgrMSl7KG5ldyBJbWFnZSkuc3JjPXRoaXMuYWxidW1bdGhpcy5jdXJyZW50SW1hZ2VJbmRleCsxXS5saW5rfWlmKHRoaXMuY3VycmVudEltYWdlSW5kZXg+MCl7KG5ldyBJbWFnZSkuc3JjPXRoaXMuYWxidW1bdGhpcy5jdXJyZW50SW1hZ2VJbmRleC0xXS5saW5rfX0sYi5wcm90b3R5cGUuZW5hYmxlS2V5Ym9hcmROYXY9ZnVuY3Rpb24oKXthKGRvY3VtZW50KS5vbihcImtleXVwLmtleWJvYXJkXCIsYS5wcm94eSh0aGlzLmtleWJvYXJkQWN0aW9uLHRoaXMpKX0sYi5wcm90b3R5cGUuZGlzYWJsZUtleWJvYXJkTmF2PWZ1bmN0aW9uKCl7YShkb2N1bWVudCkub2ZmKFwiLmtleWJvYXJkXCIpfSxiLnByb3RvdHlwZS5rZXlib2FyZEFjdGlvbj1mdW5jdGlvbihhKXt2YXIgYj1hLmtleUNvZGUsYz1TdHJpbmcuZnJvbUNoYXJDb2RlKGIpLnRvTG93ZXJDYXNlKCk7Mjc9PT1ifHxjLm1hdGNoKC94fG98Yy8pP3RoaXMuZW5kKCk6XCJwXCI9PT1jfHwzNz09PWI/MCE9PXRoaXMuY3VycmVudEltYWdlSW5kZXg/dGhpcy5jaGFuZ2VJbWFnZSh0aGlzLmN1cnJlbnRJbWFnZUluZGV4LTEpOnRoaXMub3B0aW9ucy53cmFwQXJvdW5kJiZ0aGlzLmFsYnVtLmxlbmd0aD4xJiZ0aGlzLmNoYW5nZUltYWdlKHRoaXMuYWxidW0ubGVuZ3RoLTEpOlwiblwiIT09YyYmMzkhPT1ifHwodGhpcy5jdXJyZW50SW1hZ2VJbmRleCE9PXRoaXMuYWxidW0ubGVuZ3RoLTE/dGhpcy5jaGFuZ2VJbWFnZSh0aGlzLmN1cnJlbnRJbWFnZUluZGV4KzEpOnRoaXMub3B0aW9ucy53cmFwQXJvdW5kJiZ0aGlzLmFsYnVtLmxlbmd0aD4xJiZ0aGlzLmNoYW5nZUltYWdlKDApKX0sYi5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKCl7dGhpcy5kaXNhYmxlS2V5Ym9hcmROYXYoKSxhKHdpbmRvdykub2ZmKFwicmVzaXplXCIsdGhpcy5zaXplT3ZlcmxheSksdGhpcy4kbGlnaHRib3guZmFkZU91dCh0aGlzLm9wdGlvbnMuZmFkZUR1cmF0aW9uKSx0aGlzLiRvdmVybGF5LmZhZGVPdXQodGhpcy5vcHRpb25zLmZhZGVEdXJhdGlvbiksYShcInNlbGVjdCwgb2JqZWN0LCBlbWJlZFwiKS5jc3Moe3Zpc2liaWxpdHk6XCJ2aXNpYmxlXCJ9KSx0aGlzLm9wdGlvbnMuZGlzYWJsZVNjcm9sbGluZyYmYShcImh0bWxcIikucmVtb3ZlQ2xhc3MoXCJsYi1kaXNhYmxlLXNjcm9sbGluZ1wiKX0sbmV3IGJ9KTtcbiIsIi8qIVxyXG4gKiBob3ZlckludGVudCB2MS44LjEgLy8gMjAxNC4wOC4xMSAvLyBqUXVlcnkgdjEuOS4xK1xyXG4gKiBodHRwOi8vYnJpYW5jaGVybmUuZ2l0aHViLmlvL2pxdWVyeS1ob3ZlckludGVudC9cclxuICpcclxuICogWW91IG1heSB1c2UgaG92ZXJJbnRlbnQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZS4gQmFzaWNhbGx5IHRoYXRcclxuICogbWVhbnMgeW91IGFyZSBmcmVlIHRvIHVzZSBob3ZlckludGVudCBhcyBsb25nIGFzIHRoaXMgaGVhZGVyIGlzIGxlZnQgaW50YWN0LlxyXG4gKiBDb3B5cmlnaHQgMjAwNywgMjAxNCBCcmlhbiBDaGVybmVcclxuICovXHJcblxyXG4vKiBob3ZlckludGVudCBpcyBzaW1pbGFyIHRvIGpRdWVyeSdzIGJ1aWx0LWluIFwiaG92ZXJcIiBtZXRob2QgZXhjZXB0IHRoYXRcclxuICogaW5zdGVhZCBvZiBmaXJpbmcgdGhlIGhhbmRsZXJJbiBmdW5jdGlvbiBpbW1lZGlhdGVseSwgaG92ZXJJbnRlbnQgY2hlY2tzXHJcbiAqIHRvIHNlZSBpZiB0aGUgdXNlcidzIG1vdXNlIGhhcyBzbG93ZWQgZG93biAoYmVuZWF0aCB0aGUgc2Vuc2l0aXZpdHlcclxuICogdGhyZXNob2xkKSBiZWZvcmUgZmlyaW5nIHRoZSBldmVudC4gVGhlIGhhbmRsZXJPdXQgZnVuY3Rpb24gaXMgb25seVxyXG4gKiBjYWxsZWQgYWZ0ZXIgYSBtYXRjaGluZyBoYW5kbGVySW4uXHJcbiAqXHJcbiAqIC8vIGJhc2ljIHVzYWdlIC4uLiBqdXN0IGxpa2UgLmhvdmVyKClcclxuICogLmhvdmVySW50ZW50KCBoYW5kbGVySW4sIGhhbmRsZXJPdXQgKVxyXG4gKiAuaG92ZXJJbnRlbnQoIGhhbmRsZXJJbk91dCApXHJcbiAqXHJcbiAqIC8vIGJhc2ljIHVzYWdlIC4uLiB3aXRoIGV2ZW50IGRlbGVnYXRpb24hXHJcbiAqIC5ob3ZlckludGVudCggaGFuZGxlckluLCBoYW5kbGVyT3V0LCBzZWxlY3RvciApXHJcbiAqIC5ob3ZlckludGVudCggaGFuZGxlckluT3V0LCBzZWxlY3RvciApXHJcbiAqXHJcbiAqIC8vIHVzaW5nIGEgYmFzaWMgY29uZmlndXJhdGlvbiBvYmplY3RcclxuICogLmhvdmVySW50ZW50KCBjb25maWcgKVxyXG4gKlxyXG4gKiBAcGFyYW0gIGhhbmRsZXJJbiAgIGZ1bmN0aW9uIE9SIGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAqIEBwYXJhbSAgaGFuZGxlck91dCAgZnVuY3Rpb24gT1Igc2VsZWN0b3IgZm9yIGRlbGVnYXRpb24gT1IgdW5kZWZpbmVkXHJcbiAqIEBwYXJhbSAgc2VsZWN0b3IgICAgc2VsZWN0b3IgT1IgdW5kZWZpbmVkXHJcbiAqIEBhdXRob3IgQnJpYW4gQ2hlcm5lIDxicmlhbihhdCljaGVybmUoZG90KW5ldD5cclxuICovXHJcblxyXG47KGZ1bmN0aW9uKGZhY3RvcnkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XHJcbiAgICB9IGVsc2UgaWYgKGpRdWVyeSAmJiAhalF1ZXJ5LmZuLmhvdmVySW50ZW50KSB7XHJcbiAgICAgICAgZmFjdG9yeShqUXVlcnkpO1xyXG4gICAgfVxyXG59KShmdW5jdGlvbigkKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLy8gZGVmYXVsdCBjb25maWd1cmF0aW9uIHZhbHVlc1xyXG4gICAgdmFyIF9jZmcgPSB7XHJcbiAgICAgICAgaW50ZXJ2YWw6IDEwMCxcclxuICAgICAgICBzZW5zaXRpdml0eTogNixcclxuICAgICAgICB0aW1lb3V0OiAwXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGNvdW50ZXIgdXNlZCB0byBnZW5lcmF0ZSBhbiBJRCBmb3IgZWFjaCBpbnN0YW5jZVxyXG4gICAgdmFyIElOU1RBTkNFX0NPVU5UID0gMDtcclxuXHJcbiAgICAvLyBjdXJyZW50IFggYW5kIFkgcG9zaXRpb24gb2YgbW91c2UsIHVwZGF0ZWQgZHVyaW5nIG1vdXNlbW92ZSB0cmFja2luZyAoc2hhcmVkIGFjcm9zcyBpbnN0YW5jZXMpXHJcbiAgICB2YXIgY1gsIGNZO1xyXG5cclxuICAgIC8vIHNhdmVzIHRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gY29vcmRpbmF0ZXMgYmFzZWQgb24gdGhlIGdpdmVuIG1vdXNlbW92ZSBldmVudFxyXG4gICAgdmFyIHRyYWNrID0gZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICBjWCA9IGV2LnBhZ2VYO1xyXG4gICAgICAgIGNZID0gZXYucGFnZVk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGNvbXBhcmVzIGN1cnJlbnQgYW5kIHByZXZpb3VzIG1vdXNlIHBvc2l0aW9uc1xyXG4gICAgdmFyIGNvbXBhcmUgPSBmdW5jdGlvbihldiwkZWwscyxjZmcpIHtcclxuICAgICAgICAvLyBjb21wYXJlIG1vdXNlIHBvc2l0aW9ucyB0byBzZWUgaWYgcG9pbnRlciBoYXMgc2xvd2VkIGVub3VnaCB0byB0cmlnZ2VyIGBvdmVyYCBmdW5jdGlvblxyXG4gICAgICAgIGlmICggTWF0aC5zcXJ0KCAocy5wWC1jWCkqKHMucFgtY1gpICsgKHMucFktY1kpKihzLnBZLWNZKSApIDwgY2ZnLnNlbnNpdGl2aXR5ICkge1xyXG4gICAgICAgICAgICAkZWwub2ZmKHMuZXZlbnQsdHJhY2spO1xyXG4gICAgICAgICAgICBkZWxldGUgcy50aW1lb3V0SWQ7XHJcbiAgICAgICAgICAgIC8vIHNldCBob3ZlckludGVudCBzdGF0ZSBhcyBhY3RpdmUgZm9yIHRoaXMgZWxlbWVudCAocGVybWl0cyBgb3V0YCBoYW5kbGVyIHRvIHRyaWdnZXIpXHJcbiAgICAgICAgICAgIHMuaXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBvdmVyd3JpdGUgb2xkIG1vdXNlZW50ZXIgZXZlbnQgY29vcmRpbmF0ZXMgd2l0aCBtb3N0IHJlY2VudCBwb2ludGVyIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGV2LnBhZ2VYID0gY1g7IGV2LnBhZ2VZID0gY1k7XHJcbiAgICAgICAgICAgIC8vIGNsZWFyIGNvb3JkaW5hdGUgZGF0YSBmcm9tIHN0YXRlIG9iamVjdFxyXG4gICAgICAgICAgICBkZWxldGUgcy5wWDsgZGVsZXRlIHMucFk7XHJcbiAgICAgICAgICAgIHJldHVybiBjZmcub3Zlci5hcHBseSgkZWxbMF0sW2V2XSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gc2V0IHByZXZpb3VzIGNvb3JkaW5hdGVzIGZvciBuZXh0IGNvbXBhcmlzb25cclxuICAgICAgICAgICAgcy5wWCA9IGNYOyBzLnBZID0gY1k7XHJcbiAgICAgICAgICAgIC8vIHVzZSBzZWxmLWNhbGxpbmcgdGltZW91dCwgZ3VhcmFudGVlcyBpbnRlcnZhbHMgYXJlIHNwYWNlZCBvdXQgcHJvcGVybHkgKGF2b2lkcyBKYXZhU2NyaXB0IHRpbWVyIGJ1Z3MpXHJcbiAgICAgICAgICAgIHMudGltZW91dElkID0gc2V0VGltZW91dCggZnVuY3Rpb24oKXtjb21wYXJlKGV2LCAkZWwsIHMsIGNmZyk7fSAsIGNmZy5pbnRlcnZhbCApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gdHJpZ2dlcnMgZ2l2ZW4gYG91dGAgZnVuY3Rpb24gYXQgY29uZmlndXJlZCBgdGltZW91dGAgYWZ0ZXIgYSBtb3VzZWxlYXZlIGFuZCBjbGVhcnMgc3RhdGVcclxuICAgIHZhciBkZWxheSA9IGZ1bmN0aW9uKGV2LCRlbCxzLG91dCkge1xyXG4gICAgICAgIGRlbGV0ZSAkZWwuZGF0YSgnaG92ZXJJbnRlbnQnKVtzLmlkXTtcclxuICAgICAgICByZXR1cm4gb3V0LmFwcGx5KCRlbFswXSxbZXZdKTtcclxuICAgIH07XHJcblxyXG4gICAgJC5mbi5ob3ZlckludGVudCA9IGZ1bmN0aW9uKGhhbmRsZXJJbixoYW5kbGVyT3V0LHNlbGVjdG9yKSB7XHJcbiAgICAgICAgLy8gaW5zdGFuY2UgSUQsIHVzZWQgYXMgYSBrZXkgdG8gc3RvcmUgYW5kIHJldHJpZXZlIHN0YXRlIGluZm9ybWF0aW9uIG9uIGFuIGVsZW1lbnRcclxuICAgICAgICB2YXIgaW5zdGFuY2VJZCA9IElOU1RBTkNFX0NPVU5UKys7XHJcblxyXG4gICAgICAgIC8vIGV4dGVuZCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGFuZCBwYXJzZSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgdmFyIGNmZyA9ICQuZXh0ZW5kKHt9LCBfY2ZnKTtcclxuICAgICAgICBpZiAoICQuaXNQbGFpbk9iamVjdChoYW5kbGVySW4pICkge1xyXG4gICAgICAgICAgICBjZmcgPSAkLmV4dGVuZChjZmcsIGhhbmRsZXJJbik7XHJcbiAgICAgICAgICAgIGlmICggISQuaXNGdW5jdGlvbihjZmcub3V0KSApIHtcclxuICAgICAgICAgICAgICAgIGNmZy5vdXQgPSBjZmcub3ZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoICQuaXNGdW5jdGlvbihoYW5kbGVyT3V0KSApIHtcclxuICAgICAgICAgICAgY2ZnID0gJC5leHRlbmQoY2ZnLCB7IG92ZXI6IGhhbmRsZXJJbiwgb3V0OiBoYW5kbGVyT3V0LCBzZWxlY3Rvcjogc2VsZWN0b3IgfSApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNmZyA9ICQuZXh0ZW5kKGNmZywgeyBvdmVyOiBoYW5kbGVySW4sIG91dDogaGFuZGxlckluLCBzZWxlY3RvcjogaGFuZGxlck91dCB9ICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBIHByaXZhdGUgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIG1vdXNlICdob3ZlcmluZydcclxuICAgICAgICB2YXIgaGFuZGxlSG92ZXIgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIC8vIGNsb25lZCBldmVudCB0byBwYXNzIHRvIGhhbmRsZXJzIChjb3B5IHJlcXVpcmVkIGZvciBldmVudCBvYmplY3QgdG8gYmUgcGFzc2VkIGluIElFKVxyXG4gICAgICAgICAgICB2YXIgZXYgPSAkLmV4dGVuZCh7fSxlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHRhcmdldCBvZiB0aGUgbW91c2UgZXZlbnQsIHdyYXBwZWQgaW4gYSBqUXVlcnkgb2JqZWN0XHJcbiAgICAgICAgICAgIHZhciAkZWwgPSAkKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVhZCBob3ZlckludGVudCBkYXRhIGZyb20gZWxlbWVudCAob3IgaW5pdGlhbGl6ZSBpZiBub3QgcHJlc2VudClcclxuICAgICAgICAgICAgdmFyIGhvdmVySW50ZW50RGF0YSA9ICRlbC5kYXRhKCdob3ZlckludGVudCcpO1xyXG4gICAgICAgICAgICBpZiAoIWhvdmVySW50ZW50RGF0YSkgeyAkZWwuZGF0YSgnaG92ZXJJbnRlbnQnLCAoaG92ZXJJbnRlbnREYXRhID0ge30pKTsgfVxyXG5cclxuICAgICAgICAgICAgLy8gcmVhZCBwZXItaW5zdGFuY2Ugc3RhdGUgZnJvbSBlbGVtZW50IChvciBpbml0aWFsaXplIGlmIG5vdCBwcmVzZW50KVxyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBob3ZlckludGVudERhdGFbaW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHsgaG92ZXJJbnRlbnREYXRhW2luc3RhbmNlSWRdID0gc3RhdGUgPSB7IGlkOiBpbnN0YW5jZUlkIH07IH1cclxuXHJcbiAgICAgICAgICAgIC8vIHN0YXRlIHByb3BlcnRpZXM6XHJcbiAgICAgICAgICAgIC8vIGlkID0gaW5zdGFuY2UgSUQsIHVzZWQgdG8gY2xlYW4gdXAgZGF0YVxyXG4gICAgICAgICAgICAvLyB0aW1lb3V0SWQgPSB0aW1lb3V0IElELCByZXVzZWQgZm9yIHRyYWNraW5nIG1vdXNlIHBvc2l0aW9uIGFuZCBkZWxheWluZyBcIm91dFwiIGhhbmRsZXJcclxuICAgICAgICAgICAgLy8gaXNBY3RpdmUgPSBwbHVnaW4gc3RhdGUsIHRydWUgYWZ0ZXIgYG92ZXJgIGlzIGNhbGxlZCBqdXN0IHVudGlsIGBvdXRgIGlzIGNhbGxlZFxyXG4gICAgICAgICAgICAvLyBwWCwgcFkgPSBwcmV2aW91c2x5LW1lYXN1cmVkIHBvaW50ZXIgY29vcmRpbmF0ZXMsIHVwZGF0ZWQgYXQgZWFjaCBwb2xsaW5nIGludGVydmFsXHJcbiAgICAgICAgICAgIC8vIGV2ZW50ID0gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbmFtZXNwYWNlZCBldmVudCB1c2VkIGZvciBtb3VzZSB0cmFja2luZ1xyXG5cclxuICAgICAgICAgICAgLy8gY2xlYXIgYW55IGV4aXN0aW5nIHRpbWVvdXRcclxuICAgICAgICAgICAgaWYgKHN0YXRlLnRpbWVvdXRJZCkgeyBzdGF0ZS50aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQoc3RhdGUudGltZW91dElkKTsgfVxyXG5cclxuICAgICAgICAgICAgLy8gbmFtZXNwYWNlZCBldmVudCB1c2VkIHRvIHJlZ2lzdGVyIGFuZCB1bnJlZ2lzdGVyIG1vdXNlbW92ZSB0cmFja2luZ1xyXG4gICAgICAgICAgICB2YXIgbW91c2Vtb3ZlID0gc3RhdGUuZXZlbnQgPSAnbW91c2Vtb3ZlLmhvdmVySW50ZW50LmhvdmVySW50ZW50JytpbnN0YW5jZUlkO1xyXG5cclxuICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBldmVudCwgYmFzZWQgb24gaXRzIHR5cGVcclxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nIGlmIGFscmVhZHkgYWN0aXZlXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNBY3RpdmUpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgXCJwcmV2aW91c1wiIFggYW5kIFkgcG9zaXRpb24gYmFzZWQgb24gaW5pdGlhbCBlbnRyeSBwb2ludFxyXG4gICAgICAgICAgICAgICAgc3RhdGUucFggPSBldi5wYWdlWDsgc3RhdGUucFkgPSBldi5wYWdlWTtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBcImN1cnJlbnRcIiBYIGFuZCBZIHBvc2l0aW9uIGJhc2VkIG9uIG1vdXNlbW92ZVxyXG4gICAgICAgICAgICAgICAgJGVsLm9mZihtb3VzZW1vdmUsdHJhY2spLm9uKG1vdXNlbW92ZSx0cmFjayk7XHJcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBwb2xsaW5nIGludGVydmFsIChzZWxmLWNhbGxpbmcgdGltZW91dCkgdG8gY29tcGFyZSBtb3VzZSBjb29yZGluYXRlcyBvdmVyIHRpbWVcclxuICAgICAgICAgICAgICAgIHN0YXRlLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7Y29tcGFyZShldiwkZWwsc3RhdGUsY2ZnKTt9ICwgY2ZnLmludGVydmFsICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIFwibW91c2VsZWF2ZVwiXHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nIGlmIG5vdCBhbHJlYWR5IGFjdGl2ZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc0FjdGl2ZSkgeyByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgIC8vIHVuYmluZCBleHBlbnNpdmUgbW91c2Vtb3ZlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAkZWwub2ZmKG1vdXNlbW92ZSx0cmFjayk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBob3ZlckludGVudCBzdGF0ZSBpcyB0cnVlLCB0aGVuIGNhbGwgdGhlIG1vdXNlT3V0IGZ1bmN0aW9uIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXlcclxuICAgICAgICAgICAgICAgIHN0YXRlLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7ZGVsYXkoZXYsJGVsLHN0YXRlLGNmZy5vdXQpO30gLCBjZmcudGltZW91dCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gbGlzdGVuIGZvciBtb3VzZWVudGVyIGFuZCBtb3VzZWxlYXZlXHJcbiAgICAgICAgcmV0dXJuIHRoaXMub24oeydtb3VzZWVudGVyLmhvdmVySW50ZW50JzpoYW5kbGVIb3ZlciwnbW91c2VsZWF2ZS5ob3ZlckludGVudCc6aGFuZGxlSG92ZXJ9LCBjZmcuc2VsZWN0b3IpO1xyXG4gICAgfTtcclxufSk7XHJcbiIsIi8qXG4gKiBqUXVlcnkgU3VwZXJmaXNoIE1lbnUgUGx1Z2luIC0gdjEuNy45XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgSm9lbCBCaXJjaFxuICpcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzOlxuICpcdGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlx0aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC5odG1sXG4gKi9cblxuOyFmdW5jdGlvbihhLGIpe1widXNlIHN0cmljdFwiO3ZhciBjPWZ1bmN0aW9uKCl7dmFyIGM9e2JjQ2xhc3M6XCJzZi1icmVhZGNydW1iXCIsbWVudUNsYXNzOlwic2YtanMtZW5hYmxlZFwiLGFuY2hvckNsYXNzOlwic2Ytd2l0aC11bFwiLG1lbnVBcnJvd0NsYXNzOlwic2YtYXJyb3dzXCJ9LGQ9ZnVuY3Rpb24oKXt2YXIgYj0vXig/IVtcXHdcXFddKldpbmRvd3MgUGhvbmUpW1xcd1xcV10qKGlQaG9uZXxpUGFkfGlQb2QpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtyZXR1cm4gYiYmYShcImh0bWxcIikuY3NzKFwiY3Vyc29yXCIsXCJwb2ludGVyXCIpLm9uKFwiY2xpY2tcIixhLm5vb3ApLGJ9KCksZT1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtyZXR1cm5cImJlaGF2aW9yXCJpbiBhJiZcImZpbGxcImluIGEmJi9pZW1vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCl9KCksZj1mdW5jdGlvbigpe3JldHVybiEhYi5Qb2ludGVyRXZlbnR9KCksZz1mdW5jdGlvbihhLGIsZCl7dmFyIGUsZj1jLm1lbnVDbGFzcztiLmNzc0Fycm93cyYmKGYrPVwiIFwiK2MubWVudUFycm93Q2xhc3MpLGU9ZD9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiLGFbZV0oZil9LGg9ZnVuY3Rpb24oYixkKXtyZXR1cm4gYi5maW5kKFwibGkuXCIrZC5wYXRoQ2xhc3MpLnNsaWNlKDAsZC5wYXRoTGV2ZWxzKS5hZGRDbGFzcyhkLmhvdmVyQ2xhc3MrXCIgXCIrYy5iY0NsYXNzKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gYSh0aGlzKS5jaGlsZHJlbihkLnBvcFVwU2VsZWN0b3IpLmhpZGUoKS5zaG93KCkubGVuZ3RofSkucmVtb3ZlQ2xhc3MoZC5wYXRoQ2xhc3MpfSxpPWZ1bmN0aW9uKGEsYil7dmFyIGQ9Yj9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiO2EuY2hpbGRyZW4oXCJhXCIpW2RdKGMuYW5jaG9yQ2xhc3MpfSxqPWZ1bmN0aW9uKGEpe3ZhciBiPWEuY3NzKFwibXMtdG91Y2gtYWN0aW9uXCIpLGM9YS5jc3MoXCJ0b3VjaC1hY3Rpb25cIik7Yz1jfHxiLGM9XCJwYW4teVwiPT09Yz9cImF1dG9cIjpcInBhbi15XCIsYS5jc3Moe1wibXMtdG91Y2gtYWN0aW9uXCI6YyxcInRvdWNoLWFjdGlvblwiOmN9KX0saz1mdW5jdGlvbihhKXtyZXR1cm4gYS5jbG9zZXN0KFwiLlwiK2MubWVudUNsYXNzKX0sbD1mdW5jdGlvbihhKXtyZXR1cm4gayhhKS5kYXRhKFwic2ZPcHRpb25zXCIpfSxtPWZ1bmN0aW9uKCl7dmFyIGI9YSh0aGlzKSxjPWwoYik7Y2xlYXJUaW1lb3V0KGMuc2ZUaW1lciksYi5zaWJsaW5ncygpLnN1cGVyZmlzaChcImhpZGVcIikuZW5kKCkuc3VwZXJmaXNoKFwic2hvd1wiKX0sbj1mdW5jdGlvbihiKXtiLnJldGFpblBhdGg9YS5pbkFycmF5KHRoaXNbMF0sYi4kcGF0aCk+LTEsdGhpcy5zdXBlcmZpc2goXCJoaWRlXCIpLHRoaXMucGFyZW50cyhcIi5cIitiLmhvdmVyQ2xhc3MpLmxlbmd0aHx8KGIub25JZGxlLmNhbGwoayh0aGlzKSksYi4kcGF0aC5sZW5ndGgmJmEucHJveHkobSxiLiRwYXRoKSgpKX0sbz1mdW5jdGlvbigpe3ZhciBiPWEodGhpcyksYz1sKGIpO2Q/YS5wcm94eShuLGIsYykoKTooY2xlYXJUaW1lb3V0KGMuc2ZUaW1lciksYy5zZlRpbWVyPXNldFRpbWVvdXQoYS5wcm94eShuLGIsYyksYy5kZWxheSkpfSxwPWZ1bmN0aW9uKGIpe3ZhciBjPWEodGhpcyksZD1sKGMpLGU9Yy5zaWJsaW5ncyhiLmRhdGEucG9wVXBTZWxlY3Rvcik7cmV0dXJuIGQub25IYW5kbGVUb3VjaC5jYWxsKGUpPT09ITE/dGhpczp2b2lkKGUubGVuZ3RoPjAmJmUuaXMoXCI6aGlkZGVuXCIpJiYoYy5vbmUoXCJjbGljay5zdXBlcmZpc2hcIiwhMSksXCJNU1BvaW50ZXJEb3duXCI9PT1iLnR5cGV8fFwicG9pbnRlcmRvd25cIj09PWIudHlwZT9jLnRyaWdnZXIoXCJmb2N1c1wiKTphLnByb3h5KG0sYy5wYXJlbnQoXCJsaVwiKSkoKSkpfSxxPWZ1bmN0aW9uKGIsYyl7dmFyIGc9XCJsaTpoYXMoXCIrYy5wb3BVcFNlbGVjdG9yK1wiKVwiO2EuZm4uaG92ZXJJbnRlbnQmJiFjLmRpc2FibGVIST9iLmhvdmVySW50ZW50KG0sbyxnKTpiLm9uKFwibW91c2VlbnRlci5zdXBlcmZpc2hcIixnLG0pLm9uKFwibW91c2VsZWF2ZS5zdXBlcmZpc2hcIixnLG8pO3ZhciBoPVwiTVNQb2ludGVyRG93bi5zdXBlcmZpc2hcIjtmJiYoaD1cInBvaW50ZXJkb3duLnN1cGVyZmlzaFwiKSxkfHwoaCs9XCIgdG91Y2hlbmQuc3VwZXJmaXNoXCIpLGUmJihoKz1cIiBtb3VzZWRvd24uc3VwZXJmaXNoXCIpLGIub24oXCJmb2N1c2luLnN1cGVyZmlzaFwiLFwibGlcIixtKS5vbihcImZvY3Vzb3V0LnN1cGVyZmlzaFwiLFwibGlcIixvKS5vbihoLFwiYVwiLGMscCl9O3JldHVybntoaWRlOmZ1bmN0aW9uKGIpe2lmKHRoaXMubGVuZ3RoKXt2YXIgYz10aGlzLGQ9bChjKTtpZighZClyZXR1cm4gdGhpczt2YXIgZT1kLnJldGFpblBhdGg9PT0hMD9kLiRwYXRoOlwiXCIsZj1jLmZpbmQoXCJsaS5cIitkLmhvdmVyQ2xhc3MpLmFkZCh0aGlzKS5ub3QoZSkucmVtb3ZlQ2xhc3MoZC5ob3ZlckNsYXNzKS5jaGlsZHJlbihkLnBvcFVwU2VsZWN0b3IpLGc9ZC5zcGVlZE91dDtpZihiJiYoZi5zaG93KCksZz0wKSxkLnJldGFpblBhdGg9ITEsZC5vbkJlZm9yZUhpZGUuY2FsbChmKT09PSExKXJldHVybiB0aGlzO2Yuc3RvcCghMCwhMCkuYW5pbWF0ZShkLmFuaW1hdGlvbk91dCxnLGZ1bmN0aW9uKCl7dmFyIGI9YSh0aGlzKTtkLm9uSGlkZS5jYWxsKGIpfSl9cmV0dXJuIHRoaXN9LHNob3c6ZnVuY3Rpb24oKXt2YXIgYT1sKHRoaXMpO2lmKCFhKXJldHVybiB0aGlzO3ZhciBiPXRoaXMuYWRkQ2xhc3MoYS5ob3ZlckNsYXNzKSxjPWIuY2hpbGRyZW4oYS5wb3BVcFNlbGVjdG9yKTtyZXR1cm4gYS5vbkJlZm9yZVNob3cuY2FsbChjKT09PSExP3RoaXM6KGMuc3RvcCghMCwhMCkuYW5pbWF0ZShhLmFuaW1hdGlvbixhLnNwZWVkLGZ1bmN0aW9uKCl7YS5vblNob3cuY2FsbChjKX0pLHRoaXMpfSxkZXN0cm95OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiLGQ9YSh0aGlzKSxlPWQuZGF0YShcInNmT3B0aW9uc1wiKTtyZXR1cm4gZT8oYj1kLmZpbmQoZS5wb3BVcFNlbGVjdG9yKS5wYXJlbnQoXCJsaVwiKSxjbGVhclRpbWVvdXQoZS5zZlRpbWVyKSxnKGQsZSksaShiKSxqKGQpLGQub2ZmKFwiLnN1cGVyZmlzaFwiKS5vZmYoXCIuaG92ZXJJbnRlbnRcIiksYi5jaGlsZHJlbihlLnBvcFVwU2VsZWN0b3IpLmF0dHIoXCJzdHlsZVwiLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGIucmVwbGFjZSgvZGlzcGxheVteO10rOz8vZyxcIlwiKX0pLGUuJHBhdGgucmVtb3ZlQ2xhc3MoZS5ob3ZlckNsYXNzK1wiIFwiK2MuYmNDbGFzcykuYWRkQ2xhc3MoZS5wYXRoQ2xhc3MpLGQuZmluZChcIi5cIitlLmhvdmVyQ2xhc3MpLnJlbW92ZUNsYXNzKGUuaG92ZXJDbGFzcyksZS5vbkRlc3Ryb3kuY2FsbChkKSx2b2lkIGQucmVtb3ZlRGF0YShcInNmT3B0aW9uc1wiKSk6ITF9KX0saW5pdDpmdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKTtpZihkLmRhdGEoXCJzZk9wdGlvbnNcIikpcmV0dXJuITE7dmFyIGU9YS5leHRlbmQoe30sYS5mbi5zdXBlcmZpc2guZGVmYXVsdHMsYiksZj1kLmZpbmQoZS5wb3BVcFNlbGVjdG9yKS5wYXJlbnQoXCJsaVwiKTtlLiRwYXRoPWgoZCxlKSxkLmRhdGEoXCJzZk9wdGlvbnNcIixlKSxnKGQsZSwhMCksaShmLCEwKSxqKGQpLHEoZCxlKSxmLm5vdChcIi5cIitjLmJjQ2xhc3MpLnN1cGVyZmlzaChcImhpZGVcIiwhMCksZS5vbkluaXQuY2FsbCh0aGlzKX0pfX19KCk7YS5mbi5zdXBlcmZpc2g9ZnVuY3Rpb24oYixkKXtyZXR1cm4gY1tiXT9jW2JdLmFwcGx5KHRoaXMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKTpcIm9iamVjdFwiIT10eXBlb2YgYiYmYj9hLmVycm9yKFwiTWV0aG9kIFwiK2IrXCIgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5LmZuLnN1cGVyZmlzaFwiKTpjLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxhLmZuLnN1cGVyZmlzaC5kZWZhdWx0cz17cG9wVXBTZWxlY3RvcjpcInVsLC5zZi1tZWdhXCIsaG92ZXJDbGFzczpcInNmSG92ZXJcIixwYXRoQ2xhc3M6XCJvdmVycmlkZVRoaXNUb1VzZVwiLHBhdGhMZXZlbHM6MSxkZWxheTo4MDAsYW5pbWF0aW9uOntvcGFjaXR5Olwic2hvd1wifSxhbmltYXRpb25PdXQ6e29wYWNpdHk6XCJoaWRlXCJ9LHNwZWVkOlwibm9ybWFsXCIsc3BlZWRPdXQ6XCJmYXN0XCIsY3NzQXJyb3dzOiEwLGRpc2FibGVISTohMSxvbkluaXQ6YS5ub29wLG9uQmVmb3JlU2hvdzphLm5vb3Asb25TaG93OmEubm9vcCxvbkJlZm9yZUhpZGU6YS5ub29wLG9uSGlkZTphLm5vb3Asb25JZGxlOmEubm9vcCxvbkRlc3Ryb3k6YS5ub29wLG9uSGFuZGxlVG91Y2g6YS5ub29wfX0oalF1ZXJ5LHdpbmRvdyk7IiwiLyohXHJcbiAqIEBmaWxlT3ZlcnZpZXcgVG91Y2hTd2lwZSAtIGpRdWVyeSBQbHVnaW5cclxuICogQHZlcnNpb24gMS42LjE4XHJcbiAqXHJcbiAqIEBhdXRob3IgTWF0dCBCcnlzb24gaHR0cDovL3d3dy5naXRodWIuY29tL21hdHRicnlzb25cclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGJyeXNvbi9Ub3VjaFN3aXBlLUpxdWVyeS1QbHVnaW5cclxuICogQHNlZSBodHRwOi8vbGFicy5yYW1waW50ZXJhY3RpdmUuY28udWsvdG91Y2hTd2lwZS9cclxuICogQHNlZSBodHRwOi8vcGx1Z2lucy5qcXVlcnkuY29tL3Byb2plY3QvdG91Y2hTd2lwZVxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNSBNYXR0IEJyeXNvblxyXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cclxuICpcclxuICovXHJcbiFmdW5jdGlvbihmYWN0b3J5KXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQmJmRlZmluZS5hbWQualF1ZXJ5P2RlZmluZShbXCJqcXVlcnlcIl0sZmFjdG9yeSk6ZmFjdG9yeShcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9yZXF1aXJlKFwianF1ZXJ5XCIpOmpRdWVyeSl9KGZ1bmN0aW9uKCQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGluaXQob3B0aW9ucyl7cmV0dXJuIW9wdGlvbnN8fHZvaWQgMCE9PW9wdGlvbnMuYWxsb3dQYWdlU2Nyb2xsfHx2b2lkIDA9PT1vcHRpb25zLnN3aXBlJiZ2b2lkIDA9PT1vcHRpb25zLnN3aXBlU3RhdHVzfHwob3B0aW9ucy5hbGxvd1BhZ2VTY3JvbGw9Tk9ORSksdm9pZCAwIT09b3B0aW9ucy5jbGljayYmdm9pZCAwPT09b3B0aW9ucy50YXAmJihvcHRpb25zLnRhcD1vcHRpb25zLmNsaWNrKSxvcHRpb25zfHwob3B0aW9ucz17fSksb3B0aW9ucz0kLmV4dGVuZCh7fSwkLmZuLnN3aXBlLmRlZmF1bHRzLG9wdGlvbnMpLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciAkdGhpcz0kKHRoaXMpLHBsdWdpbj0kdGhpcy5kYXRhKFBMVUdJTl9OUyk7cGx1Z2lufHwocGx1Z2luPW5ldyBUb3VjaFN3aXBlKHRoaXMsb3B0aW9ucyksJHRoaXMuZGF0YShQTFVHSU5fTlMscGx1Z2luKSl9KX1mdW5jdGlvbiBUb3VjaFN3aXBlKGVsZW1lbnQsb3B0aW9ucyl7ZnVuY3Rpb24gdG91Y2hTdGFydChqcUV2ZW50KXtpZighKGdldFRvdWNoSW5Qcm9ncmVzcygpfHwkKGpxRXZlbnQudGFyZ2V0KS5jbG9zZXN0KG9wdGlvbnMuZXhjbHVkZWRFbGVtZW50cywkZWxlbWVudCkubGVuZ3RoPjApKXt2YXIgZXZlbnQ9anFFdmVudC5vcmlnaW5hbEV2ZW50P2pxRXZlbnQub3JpZ2luYWxFdmVudDpqcUV2ZW50O2lmKCFldmVudC5wb2ludGVyVHlwZXx8XCJtb3VzZVwiIT1ldmVudC5wb2ludGVyVHlwZXx8MCE9b3B0aW9ucy5mYWxsYmFja1RvTW91c2VFdmVudHMpe3ZhciByZXQsdG91Y2hlcz1ldmVudC50b3VjaGVzLGV2dD10b3VjaGVzP3RvdWNoZXNbMF06ZXZlbnQ7cmV0dXJuIHBoYXNlPVBIQVNFX1NUQVJULHRvdWNoZXM/ZmluZ2VyQ291bnQ9dG91Y2hlcy5sZW5ndGg6b3B0aW9ucy5wcmV2ZW50RGVmYXVsdEV2ZW50cyE9PSExJiZqcUV2ZW50LnByZXZlbnREZWZhdWx0KCksZGlzdGFuY2U9MCxkaXJlY3Rpb249bnVsbCxjdXJyZW50RGlyZWN0aW9uPW51bGwscGluY2hEaXJlY3Rpb249bnVsbCxkdXJhdGlvbj0wLHN0YXJ0VG91Y2hlc0Rpc3RhbmNlPTAsZW5kVG91Y2hlc0Rpc3RhbmNlPTAscGluY2hab29tPTEscGluY2hEaXN0YW5jZT0wLG1heGltdW1zTWFwPWNyZWF0ZU1heGltdW1zRGF0YSgpLGNhbmNlbE11bHRpRmluZ2VyUmVsZWFzZSgpLGNyZWF0ZUZpbmdlckRhdGEoMCxldnQpLCF0b3VjaGVzfHxmaW5nZXJDb3VudD09PW9wdGlvbnMuZmluZ2Vyc3x8b3B0aW9ucy5maW5nZXJzPT09QUxMX0ZJTkdFUlN8fGhhc1BpbmNoZXMoKT8oc3RhcnRUaW1lPWdldFRpbWVTdGFtcCgpLDI9PWZpbmdlckNvdW50JiYoY3JlYXRlRmluZ2VyRGF0YSgxLHRvdWNoZXNbMV0pLHN0YXJ0VG91Y2hlc0Rpc3RhbmNlPWVuZFRvdWNoZXNEaXN0YW5jZT1jYWxjdWxhdGVUb3VjaGVzRGlzdGFuY2UoZmluZ2VyRGF0YVswXS5zdGFydCxmaW5nZXJEYXRhWzFdLnN0YXJ0KSksKG9wdGlvbnMuc3dpcGVTdGF0dXN8fG9wdGlvbnMucGluY2hTdGF0dXMpJiYocmV0PXRyaWdnZXJIYW5kbGVyKGV2ZW50LHBoYXNlKSkpOnJldD0hMSxyZXQ9PT0hMT8ocGhhc2U9UEhBU0VfQ0FOQ0VMLHRyaWdnZXJIYW5kbGVyKGV2ZW50LHBoYXNlKSxyZXQpOihvcHRpb25zLmhvbGQmJihob2xkVGltZW91dD1zZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24oKXskZWxlbWVudC50cmlnZ2VyKFwiaG9sZFwiLFtldmVudC50YXJnZXRdKSxvcHRpb25zLmhvbGQmJihyZXQ9b3B0aW9ucy5ob2xkLmNhbGwoJGVsZW1lbnQsZXZlbnQsZXZlbnQudGFyZ2V0KSl9LHRoaXMpLG9wdGlvbnMubG9uZ1RhcFRocmVzaG9sZCkpLHNldFRvdWNoSW5Qcm9ncmVzcyghMCksbnVsbCl9fX1mdW5jdGlvbiB0b3VjaE1vdmUoanFFdmVudCl7dmFyIGV2ZW50PWpxRXZlbnQub3JpZ2luYWxFdmVudD9qcUV2ZW50Lm9yaWdpbmFsRXZlbnQ6anFFdmVudDtpZihwaGFzZSE9PVBIQVNFX0VORCYmcGhhc2UhPT1QSEFTRV9DQU5DRUwmJiFpbk11bHRpRmluZ2VyUmVsZWFzZSgpKXt2YXIgcmV0LHRvdWNoZXM9ZXZlbnQudG91Y2hlcyxldnQ9dG91Y2hlcz90b3VjaGVzWzBdOmV2ZW50LGN1cnJlbnRGaW5nZXI9dXBkYXRlRmluZ2VyRGF0YShldnQpO2lmKGVuZFRpbWU9Z2V0VGltZVN0YW1wKCksdG91Y2hlcyYmKGZpbmdlckNvdW50PXRvdWNoZXMubGVuZ3RoKSxvcHRpb25zLmhvbGQmJmNsZWFyVGltZW91dChob2xkVGltZW91dCkscGhhc2U9UEhBU0VfTU9WRSwyPT1maW5nZXJDb3VudCYmKDA9PXN0YXJ0VG91Y2hlc0Rpc3RhbmNlPyhjcmVhdGVGaW5nZXJEYXRhKDEsdG91Y2hlc1sxXSksc3RhcnRUb3VjaGVzRGlzdGFuY2U9ZW5kVG91Y2hlc0Rpc3RhbmNlPWNhbGN1bGF0ZVRvdWNoZXNEaXN0YW5jZShmaW5nZXJEYXRhWzBdLnN0YXJ0LGZpbmdlckRhdGFbMV0uc3RhcnQpKToodXBkYXRlRmluZ2VyRGF0YSh0b3VjaGVzWzFdKSxlbmRUb3VjaGVzRGlzdGFuY2U9Y2FsY3VsYXRlVG91Y2hlc0Rpc3RhbmNlKGZpbmdlckRhdGFbMF0uZW5kLGZpbmdlckRhdGFbMV0uZW5kKSxwaW5jaERpcmVjdGlvbj1jYWxjdWxhdGVQaW5jaERpcmVjdGlvbihmaW5nZXJEYXRhWzBdLmVuZCxmaW5nZXJEYXRhWzFdLmVuZCkpLHBpbmNoWm9vbT1jYWxjdWxhdGVQaW5jaFpvb20oc3RhcnRUb3VjaGVzRGlzdGFuY2UsZW5kVG91Y2hlc0Rpc3RhbmNlKSxwaW5jaERpc3RhbmNlPU1hdGguYWJzKHN0YXJ0VG91Y2hlc0Rpc3RhbmNlLWVuZFRvdWNoZXNEaXN0YW5jZSkpLGZpbmdlckNvdW50PT09b3B0aW9ucy5maW5nZXJzfHxvcHRpb25zLmZpbmdlcnM9PT1BTExfRklOR0VSU3x8IXRvdWNoZXN8fGhhc1BpbmNoZXMoKSl7aWYoZGlyZWN0aW9uPWNhbGN1bGF0ZURpcmVjdGlvbihjdXJyZW50RmluZ2VyLnN0YXJ0LGN1cnJlbnRGaW5nZXIuZW5kKSxjdXJyZW50RGlyZWN0aW9uPWNhbGN1bGF0ZURpcmVjdGlvbihjdXJyZW50RmluZ2VyLmxhc3QsY3VycmVudEZpbmdlci5lbmQpLHZhbGlkYXRlRGVmYXVsdEV2ZW50KGpxRXZlbnQsY3VycmVudERpcmVjdGlvbiksZGlzdGFuY2U9Y2FsY3VsYXRlRGlzdGFuY2UoY3VycmVudEZpbmdlci5zdGFydCxjdXJyZW50RmluZ2VyLmVuZCksZHVyYXRpb249Y2FsY3VsYXRlRHVyYXRpb24oKSxzZXRNYXhEaXN0YW5jZShkaXJlY3Rpb24sZGlzdGFuY2UpLHJldD10cmlnZ2VySGFuZGxlcihldmVudCxwaGFzZSksIW9wdGlvbnMudHJpZ2dlck9uVG91Y2hFbmR8fG9wdGlvbnMudHJpZ2dlck9uVG91Y2hMZWF2ZSl7dmFyIGluQm91bmRzPSEwO2lmKG9wdGlvbnMudHJpZ2dlck9uVG91Y2hMZWF2ZSl7dmFyIGJvdW5kcz1nZXRib3VuZHModGhpcyk7aW5Cb3VuZHM9aXNJbkJvdW5kcyhjdXJyZW50RmluZ2VyLmVuZCxib3VuZHMpfSFvcHRpb25zLnRyaWdnZXJPblRvdWNoRW5kJiZpbkJvdW5kcz9waGFzZT1nZXROZXh0UGhhc2UoUEhBU0VfTU9WRSk6b3B0aW9ucy50cmlnZ2VyT25Ub3VjaExlYXZlJiYhaW5Cb3VuZHMmJihwaGFzZT1nZXROZXh0UGhhc2UoUEhBU0VfRU5EKSkscGhhc2UhPVBIQVNFX0NBTkNFTCYmcGhhc2UhPVBIQVNFX0VORHx8dHJpZ2dlckhhbmRsZXIoZXZlbnQscGhhc2UpfX1lbHNlIHBoYXNlPVBIQVNFX0NBTkNFTCx0cmlnZ2VySGFuZGxlcihldmVudCxwaGFzZSk7cmV0PT09ITEmJihwaGFzZT1QSEFTRV9DQU5DRUwsdHJpZ2dlckhhbmRsZXIoZXZlbnQscGhhc2UpKX19ZnVuY3Rpb24gdG91Y2hFbmQoanFFdmVudCl7dmFyIGV2ZW50PWpxRXZlbnQub3JpZ2luYWxFdmVudD9qcUV2ZW50Lm9yaWdpbmFsRXZlbnQ6anFFdmVudCx0b3VjaGVzPWV2ZW50LnRvdWNoZXM7aWYodG91Y2hlcyl7aWYodG91Y2hlcy5sZW5ndGgmJiFpbk11bHRpRmluZ2VyUmVsZWFzZSgpKXJldHVybiBzdGFydE11bHRpRmluZ2VyUmVsZWFzZShldmVudCksITA7aWYodG91Y2hlcy5sZW5ndGgmJmluTXVsdGlGaW5nZXJSZWxlYXNlKCkpcmV0dXJuITB9cmV0dXJuIGluTXVsdGlGaW5nZXJSZWxlYXNlKCkmJihmaW5nZXJDb3VudD1maW5nZXJDb3VudEF0UmVsZWFzZSksZW5kVGltZT1nZXRUaW1lU3RhbXAoKSxkdXJhdGlvbj1jYWxjdWxhdGVEdXJhdGlvbigpLGRpZFN3aXBlQmFja1RvQ2FuY2VsKCl8fCF2YWxpZGF0ZVN3aXBlRGlzdGFuY2UoKT8ocGhhc2U9UEhBU0VfQ0FOQ0VMLHRyaWdnZXJIYW5kbGVyKGV2ZW50LHBoYXNlKSk6b3B0aW9ucy50cmlnZ2VyT25Ub3VjaEVuZHx8b3B0aW9ucy50cmlnZ2VyT25Ub3VjaEVuZD09PSExJiZwaGFzZT09PVBIQVNFX01PVkU/KG9wdGlvbnMucHJldmVudERlZmF1bHRFdmVudHMhPT0hMSYmanFFdmVudC5jYW5jZWxhYmxlIT09ITEmJmpxRXZlbnQucHJldmVudERlZmF1bHQoKSxwaGFzZT1QSEFTRV9FTkQsdHJpZ2dlckhhbmRsZXIoZXZlbnQscGhhc2UpKTohb3B0aW9ucy50cmlnZ2VyT25Ub3VjaEVuZCYmaGFzVGFwKCk/KHBoYXNlPVBIQVNFX0VORCx0cmlnZ2VySGFuZGxlckZvckdlc3R1cmUoZXZlbnQscGhhc2UsVEFQKSk6cGhhc2U9PT1QSEFTRV9NT1ZFJiYocGhhc2U9UEhBU0VfQ0FOQ0VMLHRyaWdnZXJIYW5kbGVyKGV2ZW50LHBoYXNlKSksc2V0VG91Y2hJblByb2dyZXNzKCExKSxudWxsfWZ1bmN0aW9uIHRvdWNoQ2FuY2VsKCl7ZmluZ2VyQ291bnQ9MCxlbmRUaW1lPTAsc3RhcnRUaW1lPTAsc3RhcnRUb3VjaGVzRGlzdGFuY2U9MCxlbmRUb3VjaGVzRGlzdGFuY2U9MCxwaW5jaFpvb209MSxjYW5jZWxNdWx0aUZpbmdlclJlbGVhc2UoKSxzZXRUb3VjaEluUHJvZ3Jlc3MoITEpfWZ1bmN0aW9uIHRvdWNoTGVhdmUoanFFdmVudCl7dmFyIGV2ZW50PWpxRXZlbnQub3JpZ2luYWxFdmVudD9qcUV2ZW50Lm9yaWdpbmFsRXZlbnQ6anFFdmVudDtvcHRpb25zLnRyaWdnZXJPblRvdWNoTGVhdmUmJihwaGFzZT1nZXROZXh0UGhhc2UoUEhBU0VfRU5EKSx0cmlnZ2VySGFuZGxlcihldmVudCxwaGFzZSkpfWZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpeyRlbGVtZW50LnVuYmluZChTVEFSVF9FVix0b3VjaFN0YXJ0KSwkZWxlbWVudC51bmJpbmQoQ0FOQ0VMX0VWLHRvdWNoQ2FuY2VsKSwkZWxlbWVudC51bmJpbmQoTU9WRV9FVix0b3VjaE1vdmUpLCRlbGVtZW50LnVuYmluZChFTkRfRVYsdG91Y2hFbmQpLExFQVZFX0VWJiYkZWxlbWVudC51bmJpbmQoTEVBVkVfRVYsdG91Y2hMZWF2ZSksc2V0VG91Y2hJblByb2dyZXNzKCExKX1mdW5jdGlvbiBnZXROZXh0UGhhc2UoY3VycmVudFBoYXNlKXt2YXIgbmV4dFBoYXNlPWN1cnJlbnRQaGFzZSx2YWxpZFRpbWU9dmFsaWRhdGVTd2lwZVRpbWUoKSx2YWxpZERpc3RhbmNlPXZhbGlkYXRlU3dpcGVEaXN0YW5jZSgpLGRpZENhbmNlbD1kaWRTd2lwZUJhY2tUb0NhbmNlbCgpO3JldHVybiF2YWxpZFRpbWV8fGRpZENhbmNlbD9uZXh0UGhhc2U9UEhBU0VfQ0FOQ0VMOiF2YWxpZERpc3RhbmNlfHxjdXJyZW50UGhhc2UhPVBIQVNFX01PVkV8fG9wdGlvbnMudHJpZ2dlck9uVG91Y2hFbmQmJiFvcHRpb25zLnRyaWdnZXJPblRvdWNoTGVhdmU/IXZhbGlkRGlzdGFuY2UmJmN1cnJlbnRQaGFzZT09UEhBU0VfRU5EJiZvcHRpb25zLnRyaWdnZXJPblRvdWNoTGVhdmUmJihuZXh0UGhhc2U9UEhBU0VfQ0FOQ0VMKTpuZXh0UGhhc2U9UEhBU0VfRU5ELG5leHRQaGFzZX1mdW5jdGlvbiB0cmlnZ2VySGFuZGxlcihldmVudCxwaGFzZSl7dmFyIHJldCx0b3VjaGVzPWV2ZW50LnRvdWNoZXM7cmV0dXJuKGRpZFN3aXBlKCl8fGhhc1N3aXBlcygpKSYmKHJldD10cmlnZ2VySGFuZGxlckZvckdlc3R1cmUoZXZlbnQscGhhc2UsU1dJUEUpKSwoZGlkUGluY2goKXx8aGFzUGluY2hlcygpKSYmcmV0IT09ITEmJihyZXQ9dHJpZ2dlckhhbmRsZXJGb3JHZXN0dXJlKGV2ZW50LHBoYXNlLFBJTkNIKSksZGlkRG91YmxlVGFwKCkmJnJldCE9PSExP3JldD10cmlnZ2VySGFuZGxlckZvckdlc3R1cmUoZXZlbnQscGhhc2UsRE9VQkxFX1RBUCk6ZGlkTG9uZ1RhcCgpJiZyZXQhPT0hMT9yZXQ9dHJpZ2dlckhhbmRsZXJGb3JHZXN0dXJlKGV2ZW50LHBoYXNlLExPTkdfVEFQKTpkaWRUYXAoKSYmcmV0IT09ITEmJihyZXQ9dHJpZ2dlckhhbmRsZXJGb3JHZXN0dXJlKGV2ZW50LHBoYXNlLFRBUCkpLHBoYXNlPT09UEhBU0VfQ0FOQ0VMJiZ0b3VjaENhbmNlbChldmVudCkscGhhc2U9PT1QSEFTRV9FTkQmJih0b3VjaGVzP3RvdWNoZXMubGVuZ3RofHx0b3VjaENhbmNlbChldmVudCk6dG91Y2hDYW5jZWwoZXZlbnQpKSxyZXR9ZnVuY3Rpb24gdHJpZ2dlckhhbmRsZXJGb3JHZXN0dXJlKGV2ZW50LHBoYXNlLGdlc3R1cmUpe3ZhciByZXQ7aWYoZ2VzdHVyZT09U1dJUEUpe2lmKCRlbGVtZW50LnRyaWdnZXIoXCJzd2lwZVN0YXR1c1wiLFtwaGFzZSxkaXJlY3Rpb258fG51bGwsZGlzdGFuY2V8fDAsZHVyYXRpb258fDAsZmluZ2VyQ291bnQsZmluZ2VyRGF0YSxjdXJyZW50RGlyZWN0aW9uXSksb3B0aW9ucy5zd2lwZVN0YXR1cyYmKHJldD1vcHRpb25zLnN3aXBlU3RhdHVzLmNhbGwoJGVsZW1lbnQsZXZlbnQscGhhc2UsZGlyZWN0aW9ufHxudWxsLGRpc3RhbmNlfHwwLGR1cmF0aW9ufHwwLGZpbmdlckNvdW50LGZpbmdlckRhdGEsY3VycmVudERpcmVjdGlvbikscmV0PT09ITEpKXJldHVybiExO2lmKHBoYXNlPT1QSEFTRV9FTkQmJnZhbGlkYXRlU3dpcGUoKSl7aWYoY2xlYXJUaW1lb3V0KHNpbmdsZVRhcFRpbWVvdXQpLGNsZWFyVGltZW91dChob2xkVGltZW91dCksJGVsZW1lbnQudHJpZ2dlcihcInN3aXBlXCIsW2RpcmVjdGlvbixkaXN0YW5jZSxkdXJhdGlvbixmaW5nZXJDb3VudCxmaW5nZXJEYXRhLGN1cnJlbnREaXJlY3Rpb25dKSxvcHRpb25zLnN3aXBlJiYocmV0PW9wdGlvbnMuc3dpcGUuY2FsbCgkZWxlbWVudCxldmVudCxkaXJlY3Rpb24sZGlzdGFuY2UsZHVyYXRpb24sZmluZ2VyQ291bnQsZmluZ2VyRGF0YSxjdXJyZW50RGlyZWN0aW9uKSxyZXQ9PT0hMSkpcmV0dXJuITE7c3dpdGNoKGRpcmVjdGlvbil7Y2FzZSBMRUZUOiRlbGVtZW50LnRyaWdnZXIoXCJzd2lwZUxlZnRcIixbZGlyZWN0aW9uLGRpc3RhbmNlLGR1cmF0aW9uLGZpbmdlckNvdW50LGZpbmdlckRhdGEsY3VycmVudERpcmVjdGlvbl0pLG9wdGlvbnMuc3dpcGVMZWZ0JiYocmV0PW9wdGlvbnMuc3dpcGVMZWZ0LmNhbGwoJGVsZW1lbnQsZXZlbnQsZGlyZWN0aW9uLGRpc3RhbmNlLGR1cmF0aW9uLGZpbmdlckNvdW50LGZpbmdlckRhdGEsY3VycmVudERpcmVjdGlvbikpO2JyZWFrO2Nhc2UgUklHSFQ6JGVsZW1lbnQudHJpZ2dlcihcInN3aXBlUmlnaHRcIixbZGlyZWN0aW9uLGRpc3RhbmNlLGR1cmF0aW9uLGZpbmdlckNvdW50LGZpbmdlckRhdGEsY3VycmVudERpcmVjdGlvbl0pLG9wdGlvbnMuc3dpcGVSaWdodCYmKHJldD1vcHRpb25zLnN3aXBlUmlnaHQuY2FsbCgkZWxlbWVudCxldmVudCxkaXJlY3Rpb24sZGlzdGFuY2UsZHVyYXRpb24sZmluZ2VyQ291bnQsZmluZ2VyRGF0YSxjdXJyZW50RGlyZWN0aW9uKSk7YnJlYWs7Y2FzZSBVUDokZWxlbWVudC50cmlnZ2VyKFwic3dpcGVVcFwiLFtkaXJlY3Rpb24sZGlzdGFuY2UsZHVyYXRpb24sZmluZ2VyQ291bnQsZmluZ2VyRGF0YSxjdXJyZW50RGlyZWN0aW9uXSksb3B0aW9ucy5zd2lwZVVwJiYocmV0PW9wdGlvbnMuc3dpcGVVcC5jYWxsKCRlbGVtZW50LGV2ZW50LGRpcmVjdGlvbixkaXN0YW5jZSxkdXJhdGlvbixmaW5nZXJDb3VudCxmaW5nZXJEYXRhLGN1cnJlbnREaXJlY3Rpb24pKTticmVhaztjYXNlIERPV046JGVsZW1lbnQudHJpZ2dlcihcInN3aXBlRG93blwiLFtkaXJlY3Rpb24sZGlzdGFuY2UsZHVyYXRpb24sZmluZ2VyQ291bnQsZmluZ2VyRGF0YSxjdXJyZW50RGlyZWN0aW9uXSksb3B0aW9ucy5zd2lwZURvd24mJihyZXQ9b3B0aW9ucy5zd2lwZURvd24uY2FsbCgkZWxlbWVudCxldmVudCxkaXJlY3Rpb24sZGlzdGFuY2UsZHVyYXRpb24sZmluZ2VyQ291bnQsZmluZ2VyRGF0YSxjdXJyZW50RGlyZWN0aW9uKSl9fX1pZihnZXN0dXJlPT1QSU5DSCl7aWYoJGVsZW1lbnQudHJpZ2dlcihcInBpbmNoU3RhdHVzXCIsW3BoYXNlLHBpbmNoRGlyZWN0aW9ufHxudWxsLHBpbmNoRGlzdGFuY2V8fDAsZHVyYXRpb258fDAsZmluZ2VyQ291bnQscGluY2hab29tLGZpbmdlckRhdGFdKSxvcHRpb25zLnBpbmNoU3RhdHVzJiYocmV0PW9wdGlvbnMucGluY2hTdGF0dXMuY2FsbCgkZWxlbWVudCxldmVudCxwaGFzZSxwaW5jaERpcmVjdGlvbnx8bnVsbCxwaW5jaERpc3RhbmNlfHwwLGR1cmF0aW9ufHwwLGZpbmdlckNvdW50LHBpbmNoWm9vbSxmaW5nZXJEYXRhKSxyZXQ9PT0hMSkpcmV0dXJuITE7aWYocGhhc2U9PVBIQVNFX0VORCYmdmFsaWRhdGVQaW5jaCgpKXN3aXRjaChwaW5jaERpcmVjdGlvbil7Y2FzZSBJTjokZWxlbWVudC50cmlnZ2VyKFwicGluY2hJblwiLFtwaW5jaERpcmVjdGlvbnx8bnVsbCxwaW5jaERpc3RhbmNlfHwwLGR1cmF0aW9ufHwwLGZpbmdlckNvdW50LHBpbmNoWm9vbSxmaW5nZXJEYXRhXSksb3B0aW9ucy5waW5jaEluJiYocmV0PW9wdGlvbnMucGluY2hJbi5jYWxsKCRlbGVtZW50LGV2ZW50LHBpbmNoRGlyZWN0aW9ufHxudWxsLHBpbmNoRGlzdGFuY2V8fDAsZHVyYXRpb258fDAsZmluZ2VyQ291bnQscGluY2hab29tLGZpbmdlckRhdGEpKTticmVhaztjYXNlIE9VVDokZWxlbWVudC50cmlnZ2VyKFwicGluY2hPdXRcIixbcGluY2hEaXJlY3Rpb258fG51bGwscGluY2hEaXN0YW5jZXx8MCxkdXJhdGlvbnx8MCxmaW5nZXJDb3VudCxwaW5jaFpvb20sZmluZ2VyRGF0YV0pLG9wdGlvbnMucGluY2hPdXQmJihyZXQ9b3B0aW9ucy5waW5jaE91dC5jYWxsKCRlbGVtZW50LGV2ZW50LHBpbmNoRGlyZWN0aW9ufHxudWxsLHBpbmNoRGlzdGFuY2V8fDAsZHVyYXRpb258fDAsZmluZ2VyQ291bnQscGluY2hab29tLGZpbmdlckRhdGEpKX19cmV0dXJuIGdlc3R1cmU9PVRBUD9waGFzZSE9PVBIQVNFX0NBTkNFTCYmcGhhc2UhPT1QSEFTRV9FTkR8fChjbGVhclRpbWVvdXQoc2luZ2xlVGFwVGltZW91dCksY2xlYXJUaW1lb3V0KGhvbGRUaW1lb3V0KSxoYXNEb3VibGVUYXAoKSYmIWluRG91YmxlVGFwKCk/KGRvdWJsZVRhcFN0YXJ0VGltZT1nZXRUaW1lU3RhbXAoKSxzaW5nbGVUYXBUaW1lb3V0PXNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbigpe2RvdWJsZVRhcFN0YXJ0VGltZT1udWxsLCRlbGVtZW50LnRyaWdnZXIoXCJ0YXBcIixbZXZlbnQudGFyZ2V0XSksb3B0aW9ucy50YXAmJihyZXQ9b3B0aW9ucy50YXAuY2FsbCgkZWxlbWVudCxldmVudCxldmVudC50YXJnZXQpKX0sdGhpcyksb3B0aW9ucy5kb3VibGVUYXBUaHJlc2hvbGQpKTooZG91YmxlVGFwU3RhcnRUaW1lPW51bGwsJGVsZW1lbnQudHJpZ2dlcihcInRhcFwiLFtldmVudC50YXJnZXRdKSxvcHRpb25zLnRhcCYmKHJldD1vcHRpb25zLnRhcC5jYWxsKCRlbGVtZW50LGV2ZW50LGV2ZW50LnRhcmdldCkpKSk6Z2VzdHVyZT09RE9VQkxFX1RBUD9waGFzZSE9PVBIQVNFX0NBTkNFTCYmcGhhc2UhPT1QSEFTRV9FTkR8fChjbGVhclRpbWVvdXQoc2luZ2xlVGFwVGltZW91dCksY2xlYXJUaW1lb3V0KGhvbGRUaW1lb3V0KSxkb3VibGVUYXBTdGFydFRpbWU9bnVsbCwkZWxlbWVudC50cmlnZ2VyKFwiZG91YmxldGFwXCIsW2V2ZW50LnRhcmdldF0pLG9wdGlvbnMuZG91YmxlVGFwJiYocmV0PW9wdGlvbnMuZG91YmxlVGFwLmNhbGwoJGVsZW1lbnQsZXZlbnQsZXZlbnQudGFyZ2V0KSkpOmdlc3R1cmU9PUxPTkdfVEFQJiYocGhhc2UhPT1QSEFTRV9DQU5DRUwmJnBoYXNlIT09UEhBU0VfRU5EfHwoY2xlYXJUaW1lb3V0KHNpbmdsZVRhcFRpbWVvdXQpLGRvdWJsZVRhcFN0YXJ0VGltZT1udWxsLCRlbGVtZW50LnRyaWdnZXIoXCJsb25ndGFwXCIsW2V2ZW50LnRhcmdldF0pLG9wdGlvbnMubG9uZ1RhcCYmKHJldD1vcHRpb25zLmxvbmdUYXAuY2FsbCgkZWxlbWVudCxldmVudCxldmVudC50YXJnZXQpKSkpLHJldH1mdW5jdGlvbiB2YWxpZGF0ZVN3aXBlRGlzdGFuY2UoKXt2YXIgdmFsaWQ9ITA7cmV0dXJuIG51bGwhPT1vcHRpb25zLnRocmVzaG9sZCYmKHZhbGlkPWRpc3RhbmNlPj1vcHRpb25zLnRocmVzaG9sZCksdmFsaWR9ZnVuY3Rpb24gZGlkU3dpcGVCYWNrVG9DYW5jZWwoKXt2YXIgY2FuY2VsbGVkPSExO3JldHVybiBudWxsIT09b3B0aW9ucy5jYW5jZWxUaHJlc2hvbGQmJm51bGwhPT1kaXJlY3Rpb24mJihjYW5jZWxsZWQ9Z2V0TWF4RGlzdGFuY2UoZGlyZWN0aW9uKS1kaXN0YW5jZT49b3B0aW9ucy5jYW5jZWxUaHJlc2hvbGQpLGNhbmNlbGxlZH1mdW5jdGlvbiB2YWxpZGF0ZVBpbmNoRGlzdGFuY2UoKXtyZXR1cm4gbnVsbD09PW9wdGlvbnMucGluY2hUaHJlc2hvbGR8fHBpbmNoRGlzdGFuY2U+PW9wdGlvbnMucGluY2hUaHJlc2hvbGR9ZnVuY3Rpb24gdmFsaWRhdGVTd2lwZVRpbWUoKXt2YXIgcmVzdWx0O3JldHVybiByZXN1bHQ9IW9wdGlvbnMubWF4VGltZVRocmVzaG9sZHx8IShkdXJhdGlvbj49b3B0aW9ucy5tYXhUaW1lVGhyZXNob2xkKX1mdW5jdGlvbiB2YWxpZGF0ZURlZmF1bHRFdmVudChqcUV2ZW50LGRpcmVjdGlvbil7aWYob3B0aW9ucy5wcmV2ZW50RGVmYXVsdEV2ZW50cyE9PSExKWlmKG9wdGlvbnMuYWxsb3dQYWdlU2Nyb2xsPT09Tk9ORSlqcUV2ZW50LnByZXZlbnREZWZhdWx0KCk7ZWxzZXt2YXIgYXV0bz1vcHRpb25zLmFsbG93UGFnZVNjcm9sbD09PUFVVE87c3dpdGNoKGRpcmVjdGlvbil7Y2FzZSBMRUZUOihvcHRpb25zLnN3aXBlTGVmdCYmYXV0b3x8IWF1dG8mJm9wdGlvbnMuYWxsb3dQYWdlU2Nyb2xsIT1IT1JJWk9OVEFMKSYmanFFdmVudC5wcmV2ZW50RGVmYXVsdCgpO2JyZWFrO2Nhc2UgUklHSFQ6KG9wdGlvbnMuc3dpcGVSaWdodCYmYXV0b3x8IWF1dG8mJm9wdGlvbnMuYWxsb3dQYWdlU2Nyb2xsIT1IT1JJWk9OVEFMKSYmanFFdmVudC5wcmV2ZW50RGVmYXVsdCgpO2JyZWFrO2Nhc2UgVVA6KG9wdGlvbnMuc3dpcGVVcCYmYXV0b3x8IWF1dG8mJm9wdGlvbnMuYWxsb3dQYWdlU2Nyb2xsIT1WRVJUSUNBTCkmJmpxRXZlbnQucHJldmVudERlZmF1bHQoKTticmVhaztjYXNlIERPV046KG9wdGlvbnMuc3dpcGVEb3duJiZhdXRvfHwhYXV0byYmb3B0aW9ucy5hbGxvd1BhZ2VTY3JvbGwhPVZFUlRJQ0FMKSYmanFFdmVudC5wcmV2ZW50RGVmYXVsdCgpO2JyZWFrO2Nhc2UgTk9ORTp9fX1mdW5jdGlvbiB2YWxpZGF0ZVBpbmNoKCl7dmFyIGhhc0NvcnJlY3RGaW5nZXJDb3VudD12YWxpZGF0ZUZpbmdlcnMoKSxoYXNFbmRQb2ludD12YWxpZGF0ZUVuZFBvaW50KCksaGFzQ29ycmVjdERpc3RhbmNlPXZhbGlkYXRlUGluY2hEaXN0YW5jZSgpO3JldHVybiBoYXNDb3JyZWN0RmluZ2VyQ291bnQmJmhhc0VuZFBvaW50JiZoYXNDb3JyZWN0RGlzdGFuY2V9ZnVuY3Rpb24gaGFzUGluY2hlcygpe3JldHVybiEhKG9wdGlvbnMucGluY2hTdGF0dXN8fG9wdGlvbnMucGluY2hJbnx8b3B0aW9ucy5waW5jaE91dCl9ZnVuY3Rpb24gZGlkUGluY2goKXtyZXR1cm4hKCF2YWxpZGF0ZVBpbmNoKCl8fCFoYXNQaW5jaGVzKCkpfWZ1bmN0aW9uIHZhbGlkYXRlU3dpcGUoKXt2YXIgaGFzVmFsaWRUaW1lPXZhbGlkYXRlU3dpcGVUaW1lKCksaGFzVmFsaWREaXN0YW5jZT12YWxpZGF0ZVN3aXBlRGlzdGFuY2UoKSxoYXNDb3JyZWN0RmluZ2VyQ291bnQ9dmFsaWRhdGVGaW5nZXJzKCksaGFzRW5kUG9pbnQ9dmFsaWRhdGVFbmRQb2ludCgpLGRpZENhbmNlbD1kaWRTd2lwZUJhY2tUb0NhbmNlbCgpLHZhbGlkPSFkaWRDYW5jZWwmJmhhc0VuZFBvaW50JiZoYXNDb3JyZWN0RmluZ2VyQ291bnQmJmhhc1ZhbGlkRGlzdGFuY2UmJmhhc1ZhbGlkVGltZTtyZXR1cm4gdmFsaWR9ZnVuY3Rpb24gaGFzU3dpcGVzKCl7cmV0dXJuISEob3B0aW9ucy5zd2lwZXx8b3B0aW9ucy5zd2lwZVN0YXR1c3x8b3B0aW9ucy5zd2lwZUxlZnR8fG9wdGlvbnMuc3dpcGVSaWdodHx8b3B0aW9ucy5zd2lwZVVwfHxvcHRpb25zLnN3aXBlRG93bil9ZnVuY3Rpb24gZGlkU3dpcGUoKXtyZXR1cm4hKCF2YWxpZGF0ZVN3aXBlKCl8fCFoYXNTd2lwZXMoKSl9ZnVuY3Rpb24gdmFsaWRhdGVGaW5nZXJzKCl7cmV0dXJuIGZpbmdlckNvdW50PT09b3B0aW9ucy5maW5nZXJzfHxvcHRpb25zLmZpbmdlcnM9PT1BTExfRklOR0VSU3x8IVNVUFBPUlRTX1RPVUNIfWZ1bmN0aW9uIHZhbGlkYXRlRW5kUG9pbnQoKXtyZXR1cm4gMCE9PWZpbmdlckRhdGFbMF0uZW5kLnh9ZnVuY3Rpb24gaGFzVGFwKCl7cmV0dXJuISFvcHRpb25zLnRhcH1mdW5jdGlvbiBoYXNEb3VibGVUYXAoKXtyZXR1cm4hIW9wdGlvbnMuZG91YmxlVGFwfWZ1bmN0aW9uIGhhc0xvbmdUYXAoKXtyZXR1cm4hIW9wdGlvbnMubG9uZ1RhcH1mdW5jdGlvbiB2YWxpZGF0ZURvdWJsZVRhcCgpe2lmKG51bGw9PWRvdWJsZVRhcFN0YXJ0VGltZSlyZXR1cm4hMTt2YXIgbm93PWdldFRpbWVTdGFtcCgpO3JldHVybiBoYXNEb3VibGVUYXAoKSYmbm93LWRvdWJsZVRhcFN0YXJ0VGltZTw9b3B0aW9ucy5kb3VibGVUYXBUaHJlc2hvbGR9ZnVuY3Rpb24gaW5Eb3VibGVUYXAoKXtyZXR1cm4gdmFsaWRhdGVEb3VibGVUYXAoKX1mdW5jdGlvbiB2YWxpZGF0ZVRhcCgpe3JldHVybigxPT09ZmluZ2VyQ291bnR8fCFTVVBQT1JUU19UT1VDSCkmJihpc05hTihkaXN0YW5jZSl8fGRpc3RhbmNlPG9wdGlvbnMudGhyZXNob2xkKX1mdW5jdGlvbiB2YWxpZGF0ZUxvbmdUYXAoKXtyZXR1cm4gZHVyYXRpb24+b3B0aW9ucy5sb25nVGFwVGhyZXNob2xkJiZkaXN0YW5jZTxET1VCTEVfVEFQX1RIUkVTSE9MRH1mdW5jdGlvbiBkaWRUYXAoKXtyZXR1cm4hKCF2YWxpZGF0ZVRhcCgpfHwhaGFzVGFwKCkpfWZ1bmN0aW9uIGRpZERvdWJsZVRhcCgpe3JldHVybiEoIXZhbGlkYXRlRG91YmxlVGFwKCl8fCFoYXNEb3VibGVUYXAoKSl9ZnVuY3Rpb24gZGlkTG9uZ1RhcCgpe3JldHVybiEoIXZhbGlkYXRlTG9uZ1RhcCgpfHwhaGFzTG9uZ1RhcCgpKX1mdW5jdGlvbiBzdGFydE11bHRpRmluZ2VyUmVsZWFzZShldmVudCl7cHJldmlvdXNUb3VjaEVuZFRpbWU9Z2V0VGltZVN0YW1wKCksZmluZ2VyQ291bnRBdFJlbGVhc2U9ZXZlbnQudG91Y2hlcy5sZW5ndGgrMX1mdW5jdGlvbiBjYW5jZWxNdWx0aUZpbmdlclJlbGVhc2UoKXtwcmV2aW91c1RvdWNoRW5kVGltZT0wLGZpbmdlckNvdW50QXRSZWxlYXNlPTB9ZnVuY3Rpb24gaW5NdWx0aUZpbmdlclJlbGVhc2UoKXt2YXIgd2l0aGluVGhyZXNob2xkPSExO2lmKHByZXZpb3VzVG91Y2hFbmRUaW1lKXt2YXIgZGlmZj1nZXRUaW1lU3RhbXAoKS1wcmV2aW91c1RvdWNoRW5kVGltZTtkaWZmPD1vcHRpb25zLmZpbmdlclJlbGVhc2VUaHJlc2hvbGQmJih3aXRoaW5UaHJlc2hvbGQ9ITApfXJldHVybiB3aXRoaW5UaHJlc2hvbGR9ZnVuY3Rpb24gZ2V0VG91Y2hJblByb2dyZXNzKCl7cmV0dXJuISgkZWxlbWVudC5kYXRhKFBMVUdJTl9OUytcIl9pbnRvdWNoXCIpIT09ITApfWZ1bmN0aW9uIHNldFRvdWNoSW5Qcm9ncmVzcyh2YWwpeyRlbGVtZW50JiYodmFsPT09ITA/KCRlbGVtZW50LmJpbmQoTU9WRV9FVix0b3VjaE1vdmUpLCRlbGVtZW50LmJpbmQoRU5EX0VWLHRvdWNoRW5kKSxMRUFWRV9FViYmJGVsZW1lbnQuYmluZChMRUFWRV9FVix0b3VjaExlYXZlKSk6KCRlbGVtZW50LnVuYmluZChNT1ZFX0VWLHRvdWNoTW92ZSwhMSksJGVsZW1lbnQudW5iaW5kKEVORF9FVix0b3VjaEVuZCwhMSksTEVBVkVfRVYmJiRlbGVtZW50LnVuYmluZChMRUFWRV9FVix0b3VjaExlYXZlLCExKSksJGVsZW1lbnQuZGF0YShQTFVHSU5fTlMrXCJfaW50b3VjaFwiLHZhbD09PSEwKSl9ZnVuY3Rpb24gY3JlYXRlRmluZ2VyRGF0YShpZCxldnQpe3ZhciBmPXtzdGFydDp7eDowLHk6MH0sbGFzdDp7eDowLHk6MH0sZW5kOnt4OjAseTowfX07cmV0dXJuIGYuc3RhcnQueD1mLmxhc3QueD1mLmVuZC54PWV2dC5wYWdlWHx8ZXZ0LmNsaWVudFgsZi5zdGFydC55PWYubGFzdC55PWYuZW5kLnk9ZXZ0LnBhZ2VZfHxldnQuY2xpZW50WSxmaW5nZXJEYXRhW2lkXT1mLGZ9ZnVuY3Rpb24gdXBkYXRlRmluZ2VyRGF0YShldnQpe3ZhciBpZD12b2lkIDAhPT1ldnQuaWRlbnRpZmllcj9ldnQuaWRlbnRpZmllcjowLGY9Z2V0RmluZ2VyRGF0YShpZCk7cmV0dXJuIG51bGw9PT1mJiYoZj1jcmVhdGVGaW5nZXJEYXRhKGlkLGV2dCkpLGYubGFzdC54PWYuZW5kLngsZi5sYXN0Lnk9Zi5lbmQueSxmLmVuZC54PWV2dC5wYWdlWHx8ZXZ0LmNsaWVudFgsZi5lbmQueT1ldnQucGFnZVl8fGV2dC5jbGllbnRZLGZ9ZnVuY3Rpb24gZ2V0RmluZ2VyRGF0YShpZCl7cmV0dXJuIGZpbmdlckRhdGFbaWRdfHxudWxsfWZ1bmN0aW9uIHNldE1heERpc3RhbmNlKGRpcmVjdGlvbixkaXN0YW5jZSl7ZGlyZWN0aW9uIT1OT05FJiYoZGlzdGFuY2U9TWF0aC5tYXgoZGlzdGFuY2UsZ2V0TWF4RGlzdGFuY2UoZGlyZWN0aW9uKSksbWF4aW11bXNNYXBbZGlyZWN0aW9uXS5kaXN0YW5jZT1kaXN0YW5jZSl9ZnVuY3Rpb24gZ2V0TWF4RGlzdGFuY2UoZGlyZWN0aW9uKXtpZihtYXhpbXVtc01hcFtkaXJlY3Rpb25dKXJldHVybiBtYXhpbXVtc01hcFtkaXJlY3Rpb25dLmRpc3RhbmNlfWZ1bmN0aW9uIGNyZWF0ZU1heGltdW1zRGF0YSgpe3ZhciBtYXhEYXRhPXt9O3JldHVybiBtYXhEYXRhW0xFRlRdPWNyZWF0ZU1heGltdW1WTyhMRUZUKSxtYXhEYXRhW1JJR0hUXT1jcmVhdGVNYXhpbXVtVk8oUklHSFQpLG1heERhdGFbVVBdPWNyZWF0ZU1heGltdW1WTyhVUCksbWF4RGF0YVtET1dOXT1jcmVhdGVNYXhpbXVtVk8oRE9XTiksbWF4RGF0YX1mdW5jdGlvbiBjcmVhdGVNYXhpbXVtVk8oZGlyKXtyZXR1cm57ZGlyZWN0aW9uOmRpcixkaXN0YW5jZTowfX1mdW5jdGlvbiBjYWxjdWxhdGVEdXJhdGlvbigpe3JldHVybiBlbmRUaW1lLXN0YXJ0VGltZX1mdW5jdGlvbiBjYWxjdWxhdGVUb3VjaGVzRGlzdGFuY2Uoc3RhcnRQb2ludCxlbmRQb2ludCl7dmFyIGRpZmZYPU1hdGguYWJzKHN0YXJ0UG9pbnQueC1lbmRQb2ludC54KSxkaWZmWT1NYXRoLmFicyhzdGFydFBvaW50LnktZW5kUG9pbnQueSk7cmV0dXJuIE1hdGgucm91bmQoTWF0aC5zcXJ0KGRpZmZYKmRpZmZYK2RpZmZZKmRpZmZZKSl9ZnVuY3Rpb24gY2FsY3VsYXRlUGluY2hab29tKHN0YXJ0RGlzdGFuY2UsZW5kRGlzdGFuY2Upe3ZhciBwZXJjZW50PWVuZERpc3RhbmNlL3N0YXJ0RGlzdGFuY2UqMTtyZXR1cm4gcGVyY2VudC50b0ZpeGVkKDIpfWZ1bmN0aW9uIGNhbGN1bGF0ZVBpbmNoRGlyZWN0aW9uKCl7cmV0dXJuIHBpbmNoWm9vbTwxP09VVDpJTn1mdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZShzdGFydFBvaW50LGVuZFBvaW50KXtyZXR1cm4gTWF0aC5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3coZW5kUG9pbnQueC1zdGFydFBvaW50LngsMikrTWF0aC5wb3coZW5kUG9pbnQueS1zdGFydFBvaW50LnksMikpKX1mdW5jdGlvbiBjYWxjdWxhdGVBbmdsZShzdGFydFBvaW50LGVuZFBvaW50KXt2YXIgeD1zdGFydFBvaW50LngtZW5kUG9pbnQueCx5PWVuZFBvaW50Lnktc3RhcnRQb2ludC55LHI9TWF0aC5hdGFuMih5LHgpLGFuZ2xlPU1hdGgucm91bmQoMTgwKnIvTWF0aC5QSSk7cmV0dXJuIGFuZ2xlPDAmJihhbmdsZT0zNjAtTWF0aC5hYnMoYW5nbGUpKSxhbmdsZX1mdW5jdGlvbiBjYWxjdWxhdGVEaXJlY3Rpb24oc3RhcnRQb2ludCxlbmRQb2ludCl7aWYoY29tcGFyZVBvaW50cyhzdGFydFBvaW50LGVuZFBvaW50KSlyZXR1cm4gTk9ORTt2YXIgYW5nbGU9Y2FsY3VsYXRlQW5nbGUoc3RhcnRQb2ludCxlbmRQb2ludCk7cmV0dXJuIGFuZ2xlPD00NSYmYW5nbGU+PTA/TEVGVDphbmdsZTw9MzYwJiZhbmdsZT49MzE1P0xFRlQ6YW5nbGU+PTEzNSYmYW5nbGU8PTIyNT9SSUdIVDphbmdsZT40NSYmYW5nbGU8MTM1P0RPV046VVB9ZnVuY3Rpb24gZ2V0VGltZVN0YW1wKCl7dmFyIG5vdz1uZXcgRGF0ZTtyZXR1cm4gbm93LmdldFRpbWUoKX1mdW5jdGlvbiBnZXRib3VuZHMoZWwpe2VsPSQoZWwpO3ZhciBvZmZzZXQ9ZWwub2Zmc2V0KCksYm91bmRzPXtsZWZ0Om9mZnNldC5sZWZ0LHJpZ2h0Om9mZnNldC5sZWZ0K2VsLm91dGVyV2lkdGgoKSx0b3A6b2Zmc2V0LnRvcCxib3R0b206b2Zmc2V0LnRvcCtlbC5vdXRlckhlaWdodCgpfTtyZXR1cm4gYm91bmRzfWZ1bmN0aW9uIGlzSW5Cb3VuZHMocG9pbnQsYm91bmRzKXtyZXR1cm4gcG9pbnQueD5ib3VuZHMubGVmdCYmcG9pbnQueDxib3VuZHMucmlnaHQmJnBvaW50Lnk+Ym91bmRzLnRvcCYmcG9pbnQueTxib3VuZHMuYm90dG9tfWZ1bmN0aW9uIGNvbXBhcmVQb2ludHMocG9pbnRBLHBvaW50Qil7cmV0dXJuIHBvaW50QS54PT1wb2ludEIueCYmcG9pbnRBLnk9PXBvaW50Qi55fXZhciBvcHRpb25zPSQuZXh0ZW5kKHt9LG9wdGlvbnMpLHVzZVRvdWNoRXZlbnRzPVNVUFBPUlRTX1RPVUNIfHxTVVBQT1JUU19QT0lOVEVSfHwhb3B0aW9ucy5mYWxsYmFja1RvTW91c2VFdmVudHMsU1RBUlRfRVY9dXNlVG91Y2hFdmVudHM/U1VQUE9SVFNfUE9JTlRFUj9TVVBQT1JUU19QT0lOVEVSX0lFMTA/XCJNU1BvaW50ZXJEb3duXCI6XCJwb2ludGVyZG93blwiOlwidG91Y2hzdGFydFwiOlwibW91c2Vkb3duXCIsTU9WRV9FVj11c2VUb3VjaEV2ZW50cz9TVVBQT1JUU19QT0lOVEVSP1NVUFBPUlRTX1BPSU5URVJfSUUxMD9cIk1TUG9pbnRlck1vdmVcIjpcInBvaW50ZXJtb3ZlXCI6XCJ0b3VjaG1vdmVcIjpcIm1vdXNlbW92ZVwiLEVORF9FVj11c2VUb3VjaEV2ZW50cz9TVVBQT1JUU19QT0lOVEVSP1NVUFBPUlRTX1BPSU5URVJfSUUxMD9cIk1TUG9pbnRlclVwXCI6XCJwb2ludGVydXBcIjpcInRvdWNoZW5kXCI6XCJtb3VzZXVwXCIsTEVBVkVfRVY9dXNlVG91Y2hFdmVudHM/U1VQUE9SVFNfUE9JTlRFUj9cIm1vdXNlbGVhdmVcIjpudWxsOlwibW91c2VsZWF2ZVwiLENBTkNFTF9FVj1TVVBQT1JUU19QT0lOVEVSP1NVUFBPUlRTX1BPSU5URVJfSUUxMD9cIk1TUG9pbnRlckNhbmNlbFwiOlwicG9pbnRlcmNhbmNlbFwiOlwidG91Y2hjYW5jZWxcIixkaXN0YW5jZT0wLGRpcmVjdGlvbj1udWxsLGN1cnJlbnREaXJlY3Rpb249bnVsbCxkdXJhdGlvbj0wLHN0YXJ0VG91Y2hlc0Rpc3RhbmNlPTAsZW5kVG91Y2hlc0Rpc3RhbmNlPTAscGluY2hab29tPTEscGluY2hEaXN0YW5jZT0wLHBpbmNoRGlyZWN0aW9uPTAsbWF4aW11bXNNYXA9bnVsbCwkZWxlbWVudD0kKGVsZW1lbnQpLHBoYXNlPVwic3RhcnRcIixmaW5nZXJDb3VudD0wLGZpbmdlckRhdGE9e30sc3RhcnRUaW1lPTAsZW5kVGltZT0wLHByZXZpb3VzVG91Y2hFbmRUaW1lPTAsZmluZ2VyQ291bnRBdFJlbGVhc2U9MCxkb3VibGVUYXBTdGFydFRpbWU9MCxzaW5nbGVUYXBUaW1lb3V0PW51bGwsaG9sZFRpbWVvdXQ9bnVsbDt0cnl7JGVsZW1lbnQuYmluZChTVEFSVF9FVix0b3VjaFN0YXJ0KSwkZWxlbWVudC5iaW5kKENBTkNFTF9FVix0b3VjaENhbmNlbCl9Y2F0Y2goZSl7JC5lcnJvcihcImV2ZW50cyBub3Qgc3VwcG9ydGVkIFwiK1NUQVJUX0VWK1wiLFwiK0NBTkNFTF9FVitcIiBvbiBqUXVlcnkuc3dpcGVcIil9dGhpcy5lbmFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNhYmxlKCksJGVsZW1lbnQuYmluZChTVEFSVF9FVix0b3VjaFN0YXJ0KSwkZWxlbWVudC5iaW5kKENBTkNFTF9FVix0b3VjaENhbmNlbCksJGVsZW1lbnR9LHRoaXMuZGlzYWJsZT1mdW5jdGlvbigpe3JldHVybiByZW1vdmVMaXN0ZW5lcnMoKSwkZWxlbWVudH0sdGhpcy5kZXN0cm95PWZ1bmN0aW9uKCl7cmVtb3ZlTGlzdGVuZXJzKCksJGVsZW1lbnQuZGF0YShQTFVHSU5fTlMsbnVsbCksJGVsZW1lbnQ9bnVsbH0sdGhpcy5vcHRpb249ZnVuY3Rpb24ocHJvcGVydHksdmFsdWUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBwcm9wZXJ0eSlvcHRpb25zPSQuZXh0ZW5kKG9wdGlvbnMscHJvcGVydHkpO2Vsc2UgaWYodm9pZCAwIT09b3B0aW9uc1twcm9wZXJ0eV0pe2lmKHZvaWQgMD09PXZhbHVlKXJldHVybiBvcHRpb25zW3Byb3BlcnR5XTtvcHRpb25zW3Byb3BlcnR5XT12YWx1ZX1lbHNle2lmKCFwcm9wZXJ0eSlyZXR1cm4gb3B0aW9uczskLmVycm9yKFwiT3B0aW9uIFwiK3Byb3BlcnR5K1wiIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS5zd2lwZS5vcHRpb25zXCIpfXJldHVybiBudWxsfX12YXIgVkVSU0lPTj1cIjEuNi4xOFwiLExFRlQ9XCJsZWZ0XCIsUklHSFQ9XCJyaWdodFwiLFVQPVwidXBcIixET1dOPVwiZG93blwiLElOPVwiaW5cIixPVVQ9XCJvdXRcIixOT05FPVwibm9uZVwiLEFVVE89XCJhdXRvXCIsU1dJUEU9XCJzd2lwZVwiLFBJTkNIPVwicGluY2hcIixUQVA9XCJ0YXBcIixET1VCTEVfVEFQPVwiZG91YmxldGFwXCIsTE9OR19UQVA9XCJsb25ndGFwXCIsSE9SSVpPTlRBTD1cImhvcml6b250YWxcIixWRVJUSUNBTD1cInZlcnRpY2FsXCIsQUxMX0ZJTkdFUlM9XCJhbGxcIixET1VCTEVfVEFQX1RIUkVTSE9MRD0xMCxQSEFTRV9TVEFSVD1cInN0YXJ0XCIsUEhBU0VfTU9WRT1cIm1vdmVcIixQSEFTRV9FTkQ9XCJlbmRcIixQSEFTRV9DQU5DRUw9XCJjYW5jZWxcIixTVVBQT1JUU19UT1VDSD1cIm9udG91Y2hzdGFydFwiaW4gd2luZG93LFNVUFBPUlRTX1BPSU5URVJfSUUxMD13aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQmJiF3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkJiYhU1VQUE9SVFNfVE9VQ0gsU1VQUE9SVFNfUE9JTlRFUj0od2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZHx8d2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSYmIVNVUFBPUlRTX1RPVUNILFBMVUdJTl9OUz1cIlRvdWNoU3dpcGVcIixkZWZhdWx0cz17ZmluZ2VyczoxLHRocmVzaG9sZDo3NSxjYW5jZWxUaHJlc2hvbGQ6bnVsbCxwaW5jaFRocmVzaG9sZDoyMCxtYXhUaW1lVGhyZXNob2xkOm51bGwsZmluZ2VyUmVsZWFzZVRocmVzaG9sZDoyNTAsbG9uZ1RhcFRocmVzaG9sZDo1MDAsZG91YmxlVGFwVGhyZXNob2xkOjIwMCxzd2lwZTpudWxsLHN3aXBlTGVmdDpudWxsLHN3aXBlUmlnaHQ6bnVsbCxzd2lwZVVwOm51bGwsc3dpcGVEb3duOm51bGwsc3dpcGVTdGF0dXM6bnVsbCxwaW5jaEluOm51bGwscGluY2hPdXQ6bnVsbCxwaW5jaFN0YXR1czpudWxsLGNsaWNrOm51bGwsdGFwOm51bGwsZG91YmxlVGFwOm51bGwsbG9uZ1RhcDpudWxsLGhvbGQ6bnVsbCx0cmlnZ2VyT25Ub3VjaEVuZDohMCx0cmlnZ2VyT25Ub3VjaExlYXZlOiExLGFsbG93UGFnZVNjcm9sbDpcImF1dG9cIixmYWxsYmFja1RvTW91c2VFdmVudHM6ITAsZXhjbHVkZWRFbGVtZW50czpcIi5ub1N3aXBlXCIscHJldmVudERlZmF1bHRFdmVudHM6ITB9OyQuZm4uc3dpcGU9ZnVuY3Rpb24obWV0aG9kKXt2YXIgJHRoaXM9JCh0aGlzKSxwbHVnaW49JHRoaXMuZGF0YShQTFVHSU5fTlMpO2lmKHBsdWdpbiYmXCJzdHJpbmdcIj09dHlwZW9mIG1ldGhvZCl7aWYocGx1Z2luW21ldGhvZF0pcmV0dXJuIHBsdWdpblttZXRob2RdLmFwcGx5KHBsdWdpbixBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpOyQuZXJyb3IoXCJNZXRob2QgXCIrbWV0aG9kK1wiIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS5zd2lwZVwiKX1lbHNlIGlmKHBsdWdpbiYmXCJvYmplY3RcIj09dHlwZW9mIG1ldGhvZClwbHVnaW4ub3B0aW9uLmFwcGx5KHBsdWdpbixhcmd1bWVudHMpO2Vsc2UgaWYoIShwbHVnaW58fFwib2JqZWN0XCIhPXR5cGVvZiBtZXRob2QmJm1ldGhvZCkpcmV0dXJuIGluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiAkdGhpc30sJC5mbi5zd2lwZS52ZXJzaW9uPVZFUlNJT04sJC5mbi5zd2lwZS5kZWZhdWx0cz1kZWZhdWx0cywkLmZuLnN3aXBlLnBoYXNlcz17UEhBU0VfU1RBUlQ6UEhBU0VfU1RBUlQsUEhBU0VfTU9WRTpQSEFTRV9NT1ZFLFBIQVNFX0VORDpQSEFTRV9FTkQsUEhBU0VfQ0FOQ0VMOlBIQVNFX0NBTkNFTH0sJC5mbi5zd2lwZS5kaXJlY3Rpb25zPXtMRUZUOkxFRlQsUklHSFQ6UklHSFQsVVA6VVAsRE9XTjpET1dOLElOOklOLE9VVDpPVVR9LCQuZm4uc3dpcGUucGFnZVNjcm9sbD17Tk9ORTpOT05FLEhPUklaT05UQUw6SE9SSVpPTlRBTCxWRVJUSUNBTDpWRVJUSUNBTCxBVVRPOkFVVE99LCQuZm4uc3dpcGUuZmluZ2Vycz17T05FOjEsVFdPOjIsVEhSRUU6MyxGT1VSOjQsRklWRTo1LEFMTDpBTExfRklOR0VSU319KTsiLCIvKiFcbldheXBvaW50cyAtIDQuMC4xXG5Db3B5cmlnaHQgwqkgMjAxMS0yMDE2IENhbGViIFRyb3VnaHRvblxuTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuaHR0cHM6Ly9naXRodWIuY29tL2ltYWtld2VidGhpbmdzL3dheXBvaW50cy9ibG9iL21hc3Rlci9saWNlbnNlcy50eHRcbiovXG4hZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KG8pe2lmKCFvKXRocm93IG5ldyBFcnJvcihcIk5vIG9wdGlvbnMgcGFzc2VkIHRvIFdheXBvaW50IGNvbnN0cnVjdG9yXCIpO2lmKCFvLmVsZW1lbnQpdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBvcHRpb24gcGFzc2VkIHRvIFdheXBvaW50IGNvbnN0cnVjdG9yXCIpO2lmKCFvLmhhbmRsZXIpdGhyb3cgbmV3IEVycm9yKFwiTm8gaGFuZGxlciBvcHRpb24gcGFzc2VkIHRvIFdheXBvaW50IGNvbnN0cnVjdG9yXCIpO3RoaXMua2V5PVwid2F5cG9pbnQtXCIrZSx0aGlzLm9wdGlvbnM9dC5BZGFwdGVyLmV4dGVuZCh7fSx0LmRlZmF1bHRzLG8pLHRoaXMuZWxlbWVudD10aGlzLm9wdGlvbnMuZWxlbWVudCx0aGlzLmFkYXB0ZXI9bmV3IHQuQWRhcHRlcih0aGlzLmVsZW1lbnQpLHRoaXMuY2FsbGJhY2s9by5oYW5kbGVyLHRoaXMuYXhpcz10aGlzLm9wdGlvbnMuaG9yaXpvbnRhbD9cImhvcml6b250YWxcIjpcInZlcnRpY2FsXCIsdGhpcy5lbmFibGVkPXRoaXMub3B0aW9ucy5lbmFibGVkLHRoaXMudHJpZ2dlclBvaW50PW51bGwsdGhpcy5ncm91cD10Lkdyb3VwLmZpbmRPckNyZWF0ZSh7bmFtZTp0aGlzLm9wdGlvbnMuZ3JvdXAsYXhpczp0aGlzLmF4aXN9KSx0aGlzLmNvbnRleHQ9dC5Db250ZXh0LmZpbmRPckNyZWF0ZUJ5RWxlbWVudCh0aGlzLm9wdGlvbnMuY29udGV4dCksdC5vZmZzZXRBbGlhc2VzW3RoaXMub3B0aW9ucy5vZmZzZXRdJiYodGhpcy5vcHRpb25zLm9mZnNldD10Lm9mZnNldEFsaWFzZXNbdGhpcy5vcHRpb25zLm9mZnNldF0pLHRoaXMuZ3JvdXAuYWRkKHRoaXMpLHRoaXMuY29udGV4dC5hZGQodGhpcyksaVt0aGlzLmtleV09dGhpcyxlKz0xfXZhciBlPTAsaT17fTt0LnByb3RvdHlwZS5xdWV1ZVRyaWdnZXI9ZnVuY3Rpb24odCl7dGhpcy5ncm91cC5xdWV1ZVRyaWdnZXIodGhpcyx0KX0sdC5wcm90b3R5cGUudHJpZ2dlcj1mdW5jdGlvbih0KXt0aGlzLmVuYWJsZWQmJnRoaXMuY2FsbGJhY2smJnRoaXMuY2FsbGJhY2suYXBwbHkodGhpcyx0KX0sdC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuY29udGV4dC5yZW1vdmUodGhpcyksdGhpcy5ncm91cC5yZW1vdmUodGhpcyksZGVsZXRlIGlbdGhpcy5rZXldfSx0LnByb3RvdHlwZS5kaXNhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5hYmxlZD0hMSx0aGlzfSx0LnByb3RvdHlwZS5lbmFibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250ZXh0LnJlZnJlc2goKSx0aGlzLmVuYWJsZWQ9ITAsdGhpc30sdC5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdyb3VwLm5leHQodGhpcyl9LHQucHJvdG90eXBlLnByZXZpb3VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JvdXAucHJldmlvdXModGhpcyl9LHQuaW52b2tlQWxsPWZ1bmN0aW9uKHQpe3ZhciBlPVtdO2Zvcih2YXIgbyBpbiBpKWUucHVzaChpW29dKTtmb3IodmFyIG49MCxyPWUubGVuZ3RoO3I+bjtuKyspZVtuXVt0XSgpfSx0LmRlc3Ryb3lBbGw9ZnVuY3Rpb24oKXt0Lmludm9rZUFsbChcImRlc3Ryb3lcIil9LHQuZGlzYWJsZUFsbD1mdW5jdGlvbigpe3QuaW52b2tlQWxsKFwiZGlzYWJsZVwiKX0sdC5lbmFibGVBbGw9ZnVuY3Rpb24oKXt0LkNvbnRleHQucmVmcmVzaEFsbCgpO2Zvcih2YXIgZSBpbiBpKWlbZV0uZW5hYmxlZD0hMDtyZXR1cm4gdGhpc30sdC5yZWZyZXNoQWxsPWZ1bmN0aW9uKCl7dC5Db250ZXh0LnJlZnJlc2hBbGwoKX0sdC52aWV3cG9ydEhlaWdodD1mdW5jdGlvbigpe3JldHVybiB3aW5kb3cuaW5uZXJIZWlnaHR8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHR9LHQudmlld3BvcnRXaWR0aD1mdW5jdGlvbigpe3JldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGh9LHQuYWRhcHRlcnM9W10sdC5kZWZhdWx0cz17Y29udGV4dDp3aW5kb3csY29udGludW91czohMCxlbmFibGVkOiEwLGdyb3VwOlwiZGVmYXVsdFwiLGhvcml6b250YWw6ITEsb2Zmc2V0OjB9LHQub2Zmc2V0QWxpYXNlcz17XCJib3R0b20taW4tdmlld1wiOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udGV4dC5pbm5lckhlaWdodCgpLXRoaXMuYWRhcHRlci5vdXRlckhlaWdodCgpfSxcInJpZ2h0LWluLXZpZXdcIjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRleHQuaW5uZXJXaWR0aCgpLXRoaXMuYWRhcHRlci5vdXRlcldpZHRoKCl9fSx3aW5kb3cuV2F5cG9pbnQ9dH0oKSxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQodCl7d2luZG93LnNldFRpbWVvdXQodCwxZTMvNjApfWZ1bmN0aW9uIGUodCl7dGhpcy5lbGVtZW50PXQsdGhpcy5BZGFwdGVyPW4uQWRhcHRlcix0aGlzLmFkYXB0ZXI9bmV3IHRoaXMuQWRhcHRlcih0KSx0aGlzLmtleT1cIndheXBvaW50LWNvbnRleHQtXCIraSx0aGlzLmRpZFNjcm9sbD0hMSx0aGlzLmRpZFJlc2l6ZT0hMSx0aGlzLm9sZFNjcm9sbD17eDp0aGlzLmFkYXB0ZXIuc2Nyb2xsTGVmdCgpLHk6dGhpcy5hZGFwdGVyLnNjcm9sbFRvcCgpfSx0aGlzLndheXBvaW50cz17dmVydGljYWw6e30saG9yaXpvbnRhbDp7fX0sdC53YXlwb2ludENvbnRleHRLZXk9dGhpcy5rZXksb1t0LndheXBvaW50Q29udGV4dEtleV09dGhpcyxpKz0xLG4ud2luZG93Q29udGV4dHx8KG4ud2luZG93Q29udGV4dD0hMCxuLndpbmRvd0NvbnRleHQ9bmV3IGUod2luZG93KSksdGhpcy5jcmVhdGVUaHJvdHRsZWRTY3JvbGxIYW5kbGVyKCksdGhpcy5jcmVhdGVUaHJvdHRsZWRSZXNpemVIYW5kbGVyKCl9dmFyIGk9MCxvPXt9LG49d2luZG93LldheXBvaW50LHI9d2luZG93Lm9ubG9hZDtlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5vcHRpb25zLmhvcml6b250YWw/XCJob3Jpem9udGFsXCI6XCJ2ZXJ0aWNhbFwiO3RoaXMud2F5cG9pbnRzW2VdW3Qua2V5XT10LHRoaXMucmVmcmVzaCgpfSxlLnByb3RvdHlwZS5jaGVja0VtcHR5PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5BZGFwdGVyLmlzRW1wdHlPYmplY3QodGhpcy53YXlwb2ludHMuaG9yaXpvbnRhbCksZT10aGlzLkFkYXB0ZXIuaXNFbXB0eU9iamVjdCh0aGlzLndheXBvaW50cy52ZXJ0aWNhbCksaT10aGlzLmVsZW1lbnQ9PXRoaXMuZWxlbWVudC53aW5kb3c7dCYmZSYmIWkmJih0aGlzLmFkYXB0ZXIub2ZmKFwiLndheXBvaW50c1wiKSxkZWxldGUgb1t0aGlzLmtleV0pfSxlLnByb3RvdHlwZS5jcmVhdGVUaHJvdHRsZWRSZXNpemVIYW5kbGVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe2UuaGFuZGxlUmVzaXplKCksZS5kaWRSZXNpemU9ITF9dmFyIGU9dGhpczt0aGlzLmFkYXB0ZXIub24oXCJyZXNpemUud2F5cG9pbnRzXCIsZnVuY3Rpb24oKXtlLmRpZFJlc2l6ZXx8KGUuZGlkUmVzaXplPSEwLG4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHQpKX0pfSxlLnByb3RvdHlwZS5jcmVhdGVUaHJvdHRsZWRTY3JvbGxIYW5kbGVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe2UuaGFuZGxlU2Nyb2xsKCksZS5kaWRTY3JvbGw9ITF9dmFyIGU9dGhpczt0aGlzLmFkYXB0ZXIub24oXCJzY3JvbGwud2F5cG9pbnRzXCIsZnVuY3Rpb24oKXsoIWUuZGlkU2Nyb2xsfHxuLmlzVG91Y2gpJiYoZS5kaWRTY3JvbGw9ITAsbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodCkpfSl9LGUucHJvdG90eXBlLmhhbmRsZVJlc2l6ZT1mdW5jdGlvbigpe24uQ29udGV4dC5yZWZyZXNoQWxsKCl9LGUucHJvdG90eXBlLmhhbmRsZVNjcm9sbD1mdW5jdGlvbigpe3ZhciB0PXt9LGU9e2hvcml6b250YWw6e25ld1Njcm9sbDp0aGlzLmFkYXB0ZXIuc2Nyb2xsTGVmdCgpLG9sZFNjcm9sbDp0aGlzLm9sZFNjcm9sbC54LGZvcndhcmQ6XCJyaWdodFwiLGJhY2t3YXJkOlwibGVmdFwifSx2ZXJ0aWNhbDp7bmV3U2Nyb2xsOnRoaXMuYWRhcHRlci5zY3JvbGxUb3AoKSxvbGRTY3JvbGw6dGhpcy5vbGRTY3JvbGwueSxmb3J3YXJkOlwiZG93blwiLGJhY2t3YXJkOlwidXBcIn19O2Zvcih2YXIgaSBpbiBlKXt2YXIgbz1lW2ldLG49by5uZXdTY3JvbGw+by5vbGRTY3JvbGwscj1uP28uZm9yd2FyZDpvLmJhY2t3YXJkO2Zvcih2YXIgcyBpbiB0aGlzLndheXBvaW50c1tpXSl7dmFyIGE9dGhpcy53YXlwb2ludHNbaV1bc107aWYobnVsbCE9PWEudHJpZ2dlclBvaW50KXt2YXIgbD1vLm9sZFNjcm9sbDxhLnRyaWdnZXJQb2ludCxoPW8ubmV3U2Nyb2xsPj1hLnRyaWdnZXJQb2ludCxwPWwmJmgsdT0hbCYmIWg7KHB8fHUpJiYoYS5xdWV1ZVRyaWdnZXIociksdFthLmdyb3VwLmlkXT1hLmdyb3VwKX19fWZvcih2YXIgYyBpbiB0KXRbY10uZmx1c2hUcmlnZ2VycygpO3RoaXMub2xkU2Nyb2xsPXt4OmUuaG9yaXpvbnRhbC5uZXdTY3JvbGwseTplLnZlcnRpY2FsLm5ld1Njcm9sbH19LGUucHJvdG90eXBlLmlubmVySGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWxlbWVudD09dGhpcy5lbGVtZW50LndpbmRvdz9uLnZpZXdwb3J0SGVpZ2h0KCk6dGhpcy5hZGFwdGVyLmlubmVySGVpZ2h0KCl9LGUucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXtkZWxldGUgdGhpcy53YXlwb2ludHNbdC5heGlzXVt0LmtleV0sdGhpcy5jaGVja0VtcHR5KCl9LGUucHJvdG90eXBlLmlubmVyV2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbGVtZW50PT10aGlzLmVsZW1lbnQud2luZG93P24udmlld3BvcnRXaWR0aCgpOnRoaXMuYWRhcHRlci5pbm5lcldpZHRoKCl9LGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgdD1bXTtmb3IodmFyIGUgaW4gdGhpcy53YXlwb2ludHMpZm9yKHZhciBpIGluIHRoaXMud2F5cG9pbnRzW2VdKXQucHVzaCh0aGlzLndheXBvaW50c1tlXVtpXSk7Zm9yKHZhciBvPTAsbj10Lmxlbmd0aDtuPm87bysrKXRbb10uZGVzdHJveSgpfSxlLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzLmVsZW1lbnQ9PXRoaXMuZWxlbWVudC53aW5kb3csaT1lP3ZvaWQgMDp0aGlzLmFkYXB0ZXIub2Zmc2V0KCksbz17fTt0aGlzLmhhbmRsZVNjcm9sbCgpLHQ9e2hvcml6b250YWw6e2NvbnRleHRPZmZzZXQ6ZT8wOmkubGVmdCxjb250ZXh0U2Nyb2xsOmU/MDp0aGlzLm9sZFNjcm9sbC54LGNvbnRleHREaW1lbnNpb246dGhpcy5pbm5lcldpZHRoKCksb2xkU2Nyb2xsOnRoaXMub2xkU2Nyb2xsLngsZm9yd2FyZDpcInJpZ2h0XCIsYmFja3dhcmQ6XCJsZWZ0XCIsb2Zmc2V0UHJvcDpcImxlZnRcIn0sdmVydGljYWw6e2NvbnRleHRPZmZzZXQ6ZT8wOmkudG9wLGNvbnRleHRTY3JvbGw6ZT8wOnRoaXMub2xkU2Nyb2xsLnksY29udGV4dERpbWVuc2lvbjp0aGlzLmlubmVySGVpZ2h0KCksb2xkU2Nyb2xsOnRoaXMub2xkU2Nyb2xsLnksZm9yd2FyZDpcImRvd25cIixiYWNrd2FyZDpcInVwXCIsb2Zmc2V0UHJvcDpcInRvcFwifX07Zm9yKHZhciByIGluIHQpe3ZhciBzPXRbcl07Zm9yKHZhciBhIGluIHRoaXMud2F5cG9pbnRzW3JdKXt2YXIgbCxoLHAsdSxjLGQ9dGhpcy53YXlwb2ludHNbcl1bYV0sZj1kLm9wdGlvbnMub2Zmc2V0LHc9ZC50cmlnZ2VyUG9pbnQseT0wLGc9bnVsbD09dztkLmVsZW1lbnQhPT1kLmVsZW1lbnQud2luZG93JiYoeT1kLmFkYXB0ZXIub2Zmc2V0KClbcy5vZmZzZXRQcm9wXSksXCJmdW5jdGlvblwiPT10eXBlb2YgZj9mPWYuYXBwbHkoZCk6XCJzdHJpbmdcIj09dHlwZW9mIGYmJihmPXBhcnNlRmxvYXQoZiksZC5vcHRpb25zLm9mZnNldC5pbmRleE9mKFwiJVwiKT4tMSYmKGY9TWF0aC5jZWlsKHMuY29udGV4dERpbWVuc2lvbipmLzEwMCkpKSxsPXMuY29udGV4dFNjcm9sbC1zLmNvbnRleHRPZmZzZXQsZC50cmlnZ2VyUG9pbnQ9TWF0aC5mbG9vcih5K2wtZiksaD13PHMub2xkU2Nyb2xsLHA9ZC50cmlnZ2VyUG9pbnQ+PXMub2xkU2Nyb2xsLHU9aCYmcCxjPSFoJiYhcCwhZyYmdT8oZC5xdWV1ZVRyaWdnZXIocy5iYWNrd2FyZCksb1tkLmdyb3VwLmlkXT1kLmdyb3VwKTohZyYmYz8oZC5xdWV1ZVRyaWdnZXIocy5mb3J3YXJkKSxvW2QuZ3JvdXAuaWRdPWQuZ3JvdXApOmcmJnMub2xkU2Nyb2xsPj1kLnRyaWdnZXJQb2ludCYmKGQucXVldWVUcmlnZ2VyKHMuZm9yd2FyZCksb1tkLmdyb3VwLmlkXT1kLmdyb3VwKX19cmV0dXJuIG4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIG8pb1t0XS5mbHVzaFRyaWdnZXJzKCl9KSx0aGlzfSxlLmZpbmRPckNyZWF0ZUJ5RWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gZS5maW5kQnlFbGVtZW50KHQpfHxuZXcgZSh0KX0sZS5yZWZyZXNoQWxsPWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIG8pb1t0XS5yZWZyZXNoKCl9LGUuZmluZEJ5RWxlbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gb1t0LndheXBvaW50Q29udGV4dEtleV19LHdpbmRvdy5vbmxvYWQ9ZnVuY3Rpb24oKXtyJiZyKCksZS5yZWZyZXNoQWxsKCl9LG4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lPWZ1bmN0aW9uKGUpe3ZhciBpPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHQ7aS5jYWxsKHdpbmRvdyxlKX0sbi5Db250ZXh0PWV9KCksZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KHQsZSl7cmV0dXJuIHQudHJpZ2dlclBvaW50LWUudHJpZ2dlclBvaW50fWZ1bmN0aW9uIGUodCxlKXtyZXR1cm4gZS50cmlnZ2VyUG9pbnQtdC50cmlnZ2VyUG9pbnR9ZnVuY3Rpb24gaSh0KXt0aGlzLm5hbWU9dC5uYW1lLHRoaXMuYXhpcz10LmF4aXMsdGhpcy5pZD10aGlzLm5hbWUrXCItXCIrdGhpcy5heGlzLHRoaXMud2F5cG9pbnRzPVtdLHRoaXMuY2xlYXJUcmlnZ2VyUXVldWVzKCksb1t0aGlzLmF4aXNdW3RoaXMubmFtZV09dGhpc312YXIgbz17dmVydGljYWw6e30saG9yaXpvbnRhbDp7fX0sbj13aW5kb3cuV2F5cG9pbnQ7aS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3RoaXMud2F5cG9pbnRzLnB1c2godCl9LGkucHJvdG90eXBlLmNsZWFyVHJpZ2dlclF1ZXVlcz1mdW5jdGlvbigpe3RoaXMudHJpZ2dlclF1ZXVlcz17dXA6W10sZG93bjpbXSxsZWZ0OltdLHJpZ2h0OltdfX0saS5wcm90b3R5cGUuZmx1c2hUcmlnZ2Vycz1mdW5jdGlvbigpe2Zvcih2YXIgaSBpbiB0aGlzLnRyaWdnZXJRdWV1ZXMpe3ZhciBvPXRoaXMudHJpZ2dlclF1ZXVlc1tpXSxuPVwidXBcIj09PWl8fFwibGVmdFwiPT09aTtvLnNvcnQobj9lOnQpO2Zvcih2YXIgcj0wLHM9by5sZW5ndGg7cz5yO3IrPTEpe3ZhciBhPW9bcl07KGEub3B0aW9ucy5jb250aW51b3VzfHxyPT09by5sZW5ndGgtMSkmJmEudHJpZ2dlcihbaV0pfX10aGlzLmNsZWFyVHJpZ2dlclF1ZXVlcygpfSxpLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKGUpe3RoaXMud2F5cG9pbnRzLnNvcnQodCk7dmFyIGk9bi5BZGFwdGVyLmluQXJyYXkoZSx0aGlzLndheXBvaW50cyksbz1pPT09dGhpcy53YXlwb2ludHMubGVuZ3RoLTE7cmV0dXJuIG8/bnVsbDp0aGlzLndheXBvaW50c1tpKzFdfSxpLnByb3RvdHlwZS5wcmV2aW91cz1mdW5jdGlvbihlKXt0aGlzLndheXBvaW50cy5zb3J0KHQpO3ZhciBpPW4uQWRhcHRlci5pbkFycmF5KGUsdGhpcy53YXlwb2ludHMpO3JldHVybiBpP3RoaXMud2F5cG9pbnRzW2ktMV06bnVsbH0saS5wcm90b3R5cGUucXVldWVUcmlnZ2VyPWZ1bmN0aW9uKHQsZSl7dGhpcy50cmlnZ2VyUXVldWVzW2VdLnB1c2godCl9LGkucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXt2YXIgZT1uLkFkYXB0ZXIuaW5BcnJheSh0LHRoaXMud2F5cG9pbnRzKTtlPi0xJiZ0aGlzLndheXBvaW50cy5zcGxpY2UoZSwxKX0saS5wcm90b3R5cGUuZmlyc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53YXlwb2ludHNbMF19LGkucHJvdG90eXBlLmxhc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53YXlwb2ludHNbdGhpcy53YXlwb2ludHMubGVuZ3RoLTFdfSxpLmZpbmRPckNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gb1t0LmF4aXNdW3QubmFtZV18fG5ldyBpKHQpfSxuLkdyb3VwPWl9KCksZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KHQpe3RoaXMuJGVsZW1lbnQ9ZSh0KX12YXIgZT13aW5kb3cualF1ZXJ5LGk9d2luZG93LldheXBvaW50O2UuZWFjaChbXCJpbm5lckhlaWdodFwiLFwiaW5uZXJXaWR0aFwiLFwib2ZmXCIsXCJvZmZzZXRcIixcIm9uXCIsXCJvdXRlckhlaWdodFwiLFwib3V0ZXJXaWR0aFwiLFwic2Nyb2xsTGVmdFwiLFwic2Nyb2xsVG9wXCJdLGZ1bmN0aW9uKGUsaSl7dC5wcm90b3R5cGVbaV09ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3JldHVybiB0aGlzLiRlbGVtZW50W2ldLmFwcGx5KHRoaXMuJGVsZW1lbnQsdCl9fSksZS5lYWNoKFtcImV4dGVuZFwiLFwiaW5BcnJheVwiLFwiaXNFbXB0eU9iamVjdFwiXSxmdW5jdGlvbihpLG8pe3Rbb109ZVtvXX0pLGkuYWRhcHRlcnMucHVzaCh7bmFtZTpcImpxdWVyeVwiLEFkYXB0ZXI6dH0pLGkuQWRhcHRlcj10fSgpLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgaT1bXSxvPWFyZ3VtZW50c1swXTtyZXR1cm4gdC5pc0Z1bmN0aW9uKGFyZ3VtZW50c1swXSkmJihvPXQuZXh0ZW5kKHt9LGFyZ3VtZW50c1sxXSksby5oYW5kbGVyPWFyZ3VtZW50c1swXSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIG49dC5leHRlbmQoe30sbyx7ZWxlbWVudDp0aGlzfSk7XCJzdHJpbmdcIj09dHlwZW9mIG4uY29udGV4dCYmKG4uY29udGV4dD10KHRoaXMpLmNsb3Nlc3Qobi5jb250ZXh0KVswXSksaS5wdXNoKG5ldyBlKG4pKX0pLGl9fXZhciBlPXdpbmRvdy5XYXlwb2ludDt3aW5kb3cualF1ZXJ5JiYod2luZG93LmpRdWVyeS5mbi53YXlwb2ludD10KHdpbmRvdy5qUXVlcnkpKSx3aW5kb3cuWmVwdG8mJih3aW5kb3cuWmVwdG8uZm4ud2F5cG9pbnQ9dCh3aW5kb3cuWmVwdG8pKX0oKTsiLCIvKiEgV09XIHdvdy5qcyAtIHYxLjMuMCAtIDIwMTYtMTAtMDRcclxuKiBodHRwczovL3dvd2pzLnVrXHJcbiogQ29weXJpZ2h0IChjKSAyMDE2IFRob21hcyBHcmFpbmdlcjsgTGljZW5zZWQgTUlUICovIWZ1bmN0aW9uKGEsYil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXCJtb2R1bGVcIixcImV4cG9ydHNcIl0sYik7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZXhwb3J0cyliKG1vZHVsZSxleHBvcnRzKTtlbHNle3ZhciBjPXtleHBvcnRzOnt9fTtiKGMsYy5leHBvcnRzKSxhLldPVz1jLmV4cG9ydHN9fSh0aGlzLGZ1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYyhhLGIpe2lmKCEoYSBpbnN0YW5jZW9mIGIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gZChhLGIpe3JldHVybiBiLmluZGV4T2YoYSk+PTB9ZnVuY3Rpb24gZShhLGIpe2Zvcih2YXIgYyBpbiBiKWlmKG51bGw9PWFbY10pe3ZhciBkPWJbY107YVtjXT1kfXJldHVybiBhfWZ1bmN0aW9uIGYoYSl7cmV0dXJuL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KGEpfWZ1bmN0aW9uIGcoYSl7dmFyIGI9YXJndW1lbnRzLmxlbmd0aDw9MXx8dm9pZCAwPT09YXJndW1lbnRzWzFdPyExOmFyZ3VtZW50c1sxXSxjPWFyZ3VtZW50cy5sZW5ndGg8PTJ8fHZvaWQgMD09PWFyZ3VtZW50c1syXT8hMTphcmd1bWVudHNbMl0sZD1hcmd1bWVudHMubGVuZ3RoPD0zfHx2b2lkIDA9PT1hcmd1bWVudHNbM10/bnVsbDphcmd1bWVudHNbM10sZT12b2lkIDA7cmV0dXJuIG51bGwhPWRvY3VtZW50LmNyZWF0ZUV2ZW50PyhlPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIiksZS5pbml0Q3VzdG9tRXZlbnQoYSxiLGMsZCkpOm51bGwhPWRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0PyhlPWRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCksZS5ldmVudFR5cGU9YSk6ZS5ldmVudE5hbWU9YSxlfWZ1bmN0aW9uIGgoYSxiKXtudWxsIT1hLmRpc3BhdGNoRXZlbnQ/YS5kaXNwYXRjaEV2ZW50KGIpOmIgaW4obnVsbCE9YSk/YVtiXSgpOlwib25cIitiIGluKG51bGwhPWEpJiZhW1wib25cIitiXSgpfWZ1bmN0aW9uIGkoYSxiLGMpe251bGwhPWEuYWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKTpudWxsIT1hLmF0dGFjaEV2ZW50P2EuYXR0YWNoRXZlbnQoXCJvblwiK2IsYyk6YVtiXT1jfWZ1bmN0aW9uIGooYSxiLGMpe251bGwhPWEucmVtb3ZlRXZlbnRMaXN0ZW5lcj9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixjLCExKTpudWxsIT1hLmRldGFjaEV2ZW50P2EuZGV0YWNoRXZlbnQoXCJvblwiK2IsYyk6ZGVsZXRlIGFbYl19ZnVuY3Rpb24gaygpe3JldHVyblwiaW5uZXJIZWlnaHRcImluIHdpbmRvdz93aW5kb3cuaW5uZXJIZWlnaHQ6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodH1PYmplY3QuZGVmaW5lUHJvcGVydHkoYixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbCxtLG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYil7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWJbY107ZC5lbnVtZXJhYmxlPWQuZW51bWVyYWJsZXx8ITEsZC5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gZCYmKGQud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGQua2V5LGQpfX1yZXR1cm4gZnVuY3Rpb24oYixjLGQpe3JldHVybiBjJiZhKGIucHJvdG90eXBlLGMpLGQmJmEoYixkKSxifX0oKSxvPXdpbmRvdy5XZWFrTWFwfHx3aW5kb3cuTW96V2Vha01hcHx8ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7Yyh0aGlzLGEpLHRoaXMua2V5cz1bXSx0aGlzLnZhbHVlcz1bXX1yZXR1cm4gbihhLFt7a2V5OlwiZ2V0XCIsdmFsdWU6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7Yjx0aGlzLmtleXMubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5rZXlzW2JdO2lmKGM9PT1hKXJldHVybiB0aGlzLnZhbHVlc1tiXX19fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPHRoaXMua2V5cy5sZW5ndGg7YysrKXt2YXIgZD10aGlzLmtleXNbY107aWYoZD09PWEpcmV0dXJuIHRoaXMudmFsdWVzW2NdPWIsdGhpc31yZXR1cm4gdGhpcy5rZXlzLnB1c2goYSksdGhpcy52YWx1ZXMucHVzaChiKSx0aGlzfX1dKSxhfSgpLHA9d2luZG93Lk11dGF0aW9uT2JzZXJ2ZXJ8fHdpbmRvdy5XZWJraXRNdXRhdGlvbk9ic2VydmVyfHx3aW5kb3cuTW96TXV0YXRpb25PYnNlcnZlcnx8KG09bD1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXtjKHRoaXMsYSksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGNvbnNvbGUmJm51bGwhPT1jb25zb2xlJiYoY29uc29sZS53YXJuKFwiTXV0YXRpb25PYnNlcnZlciBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3Nlci5cIiksY29uc29sZS53YXJuKFwiV09XLmpzIGNhbm5vdCBkZXRlY3QgZG9tIG11dGF0aW9ucywgcGxlYXNlIGNhbGwgLnN5bmMoKSBhZnRlciBsb2FkaW5nIG5ldyBjb250ZW50LlwiKSl9cmV0dXJuIG4oYSxbe2tleTpcIm9ic2VydmVcIix2YWx1ZTpmdW5jdGlvbigpe319XSksYX0oKSxsLm5vdFN1cHBvcnRlZD0hMCxtKSxxPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlfHxmdW5jdGlvbihhKXt2YXIgYj0vKFxcLShbYS16XSl7MX0pL2c7cmV0dXJue2dldFByb3BlcnR5VmFsdWU6ZnVuY3Rpb24oYyl7XCJmbG9hdFwiPT09YyYmKGM9XCJzdHlsZUZsb2F0XCIpLGIudGVzdChjKSYmYy5yZXBsYWNlKGIsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50b1VwcGVyQ2FzZSgpfSk7dmFyIGQ9YS5jdXJyZW50U3R5bGU7cmV0dXJuKG51bGwhPWQ/ZFtjXTp2b2lkIDApfHxudWxsfX19LHI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7dmFyIGI9YXJndW1lbnRzLmxlbmd0aDw9MHx8dm9pZCAwPT09YXJndW1lbnRzWzBdP3t9OmFyZ3VtZW50c1swXTtjKHRoaXMsYSksdGhpcy5kZWZhdWx0cz17Ym94Q2xhc3M6XCJ3b3dcIixhbmltYXRlQ2xhc3M6XCJhbmltYXRlZFwiLG9mZnNldDowLG1vYmlsZTohMCxsaXZlOiEwLGNhbGxiYWNrOm51bGwsc2Nyb2xsQ29udGFpbmVyOm51bGwscmVzZXRBbmltYXRpb246ITB9LHRoaXMuYW5pbWF0ZT1mdW5jdGlvbigpe3JldHVyblwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJpbiB3aW5kb3c/ZnVuY3Rpb24oYSl7cmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYSl9OmZ1bmN0aW9uKGEpe3JldHVybiBhKCl9fSgpLHRoaXMudmVuZG9ycz1bXCJtb3pcIixcIndlYmtpdFwiXSx0aGlzLnN0YXJ0PXRoaXMuc3RhcnQuYmluZCh0aGlzKSx0aGlzLnJlc2V0QW5pbWF0aW9uPXRoaXMucmVzZXRBbmltYXRpb24uYmluZCh0aGlzKSx0aGlzLnNjcm9sbEhhbmRsZXI9dGhpcy5zY3JvbGxIYW5kbGVyLmJpbmQodGhpcyksdGhpcy5zY3JvbGxDYWxsYmFjaz10aGlzLnNjcm9sbENhbGxiYWNrLmJpbmQodGhpcyksdGhpcy5zY3JvbGxlZD0hMCx0aGlzLmNvbmZpZz1lKGIsdGhpcy5kZWZhdWx0cyksbnVsbCE9Yi5zY3JvbGxDb250YWluZXImJih0aGlzLmNvbmZpZy5zY3JvbGxDb250YWluZXI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihiLnNjcm9sbENvbnRhaW5lcikpLHRoaXMuYW5pbWF0aW9uTmFtZUNhY2hlPW5ldyBvLHRoaXMud293RXZlbnQ9Zyh0aGlzLmNvbmZpZy5ib3hDbGFzcyl9cmV0dXJuIG4oYSxbe2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZWxlbWVudD13aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGQoZG9jdW1lbnQucmVhZHlTdGF0ZSxbXCJpbnRlcmFjdGl2ZVwiLFwiY29tcGxldGVcIl0pP3RoaXMuc3RhcnQoKTppKGRvY3VtZW50LFwiRE9NQ29udGVudExvYWRlZFwiLHRoaXMuc3RhcnQpLHRoaXMuZmluaXNoZWQ9W119fSx7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBhPXRoaXM7aWYodGhpcy5zdG9wcGVkPSExLHRoaXMuYm94ZXM9W10uc2xpY2UuY2FsbCh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5cIit0aGlzLmNvbmZpZy5ib3hDbGFzcykpLHRoaXMuYWxsPXRoaXMuYm94ZXMuc2xpY2UoMCksdGhpcy5ib3hlcy5sZW5ndGgpaWYodGhpcy5kaXNhYmxlZCgpKXRoaXMucmVzZXRTdHlsZSgpO2Vsc2UgZm9yKHZhciBiPTA7Yjx0aGlzLmJveGVzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuYm94ZXNbYl07dGhpcy5hcHBseVN0eWxlKGMsITApfWlmKHRoaXMuZGlzYWJsZWQoKXx8KGkodGhpcy5jb25maWcuc2Nyb2xsQ29udGFpbmVyfHx3aW5kb3csXCJzY3JvbGxcIix0aGlzLnNjcm9sbEhhbmRsZXIpLGkod2luZG93LFwicmVzaXplXCIsdGhpcy5zY3JvbGxIYW5kbGVyKSx0aGlzLmludGVydmFsPXNldEludGVydmFsKHRoaXMuc2Nyb2xsQ2FsbGJhY2ssNTApKSx0aGlzLmNvbmZpZy5saXZlKXt2YXIgZD1uZXcgcChmdW5jdGlvbihiKXtmb3IodmFyIGM9MDtjPGIubGVuZ3RoO2MrKylmb3IodmFyIGQ9YltjXSxlPTA7ZTxkLmFkZGVkTm9kZXMubGVuZ3RoO2UrKyl7dmFyIGY9ZC5hZGRlZE5vZGVzW2VdO2EuZG9TeW5jKGYpfX0pO2Qub2JzZXJ2ZShkb2N1bWVudC5ib2R5LHtjaGlsZExpc3Q6ITAsc3VidHJlZTohMH0pfX19LHtrZXk6XCJzdG9wXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnN0b3BwZWQ9ITAsaih0aGlzLmNvbmZpZy5zY3JvbGxDb250YWluZXJ8fHdpbmRvdyxcInNjcm9sbFwiLHRoaXMuc2Nyb2xsSGFuZGxlciksaih3aW5kb3csXCJyZXNpemVcIix0aGlzLnNjcm9sbEhhbmRsZXIpLG51bGwhPXRoaXMuaW50ZXJ2YWwmJmNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCl9fSx7a2V5Olwic3luY1wiLHZhbHVlOmZ1bmN0aW9uKCl7cC5ub3RTdXBwb3J0ZWQmJnRoaXMuZG9TeW5jKHRoaXMuZWxlbWVudCl9fSx7a2V5OlwiZG9TeW5jXCIsdmFsdWU6ZnVuY3Rpb24oYSl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGEmJm51bGwhPT1hfHwoYT10aGlzLmVsZW1lbnQpLDE9PT1hLm5vZGVUeXBlKXthPWEucGFyZW50Tm9kZXx8YTtmb3IodmFyIGI9YS5xdWVyeVNlbGVjdG9yQWxsKFwiLlwiK3RoaXMuY29uZmlnLmJveENsYXNzKSxjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBlPWJbY107ZChlLHRoaXMuYWxsKXx8KHRoaXMuYm94ZXMucHVzaChlKSx0aGlzLmFsbC5wdXNoKGUpLHRoaXMuc3RvcHBlZHx8dGhpcy5kaXNhYmxlZCgpP3RoaXMucmVzZXRTdHlsZSgpOnRoaXMuYXBwbHlTdHlsZShlLCEwKSx0aGlzLnNjcm9sbGVkPSEwKX19fX0se2tleTpcInNob3dcIix2YWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hcHBseVN0eWxlKGEpLGEuY2xhc3NOYW1lPWEuY2xhc3NOYW1lK1wiIFwiK3RoaXMuY29uZmlnLmFuaW1hdGVDbGFzcyxudWxsIT10aGlzLmNvbmZpZy5jYWxsYmFjayYmdGhpcy5jb25maWcuY2FsbGJhY2soYSksaChhLHRoaXMud293RXZlbnQpLHRoaXMuY29uZmlnLnJlc2V0QW5pbWF0aW9uJiYoaShhLFwiYW5pbWF0aW9uZW5kXCIsdGhpcy5yZXNldEFuaW1hdGlvbiksaShhLFwib2FuaW1hdGlvbmVuZFwiLHRoaXMucmVzZXRBbmltYXRpb24pLGkoYSxcIndlYmtpdEFuaW1hdGlvbkVuZFwiLHRoaXMucmVzZXRBbmltYXRpb24pLGkoYSxcIk1TQW5pbWF0aW9uRW5kXCIsdGhpcy5yZXNldEFuaW1hdGlvbikpLGF9fSx7a2V5OlwiYXBwbHlTdHlsZVwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPWEuZ2V0QXR0cmlidXRlKFwiZGF0YS13b3ctZHVyYXRpb25cIiksZT1hLmdldEF0dHJpYnV0ZShcImRhdGEtd293LWRlbGF5XCIpLGY9YS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdvdy1pdGVyYXRpb25cIik7cmV0dXJuIHRoaXMuYW5pbWF0ZShmdW5jdGlvbigpe3JldHVybiBjLmN1c3RvbVN0eWxlKGEsYixkLGUsZil9KX19LHtrZXk6XCJyZXNldFN0eWxlXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMuYm94ZXMubGVuZ3RoO2ErKyl7dmFyIGI9dGhpcy5ib3hlc1thXTtiLnN0eWxlLnZpc2liaWxpdHk9XCJ2aXNpYmxlXCJ9fX0se2tleTpcInJlc2V0QW5pbWF0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oYSl7aWYoYS50eXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFuaW1hdGlvbmVuZFwiKT49MCl7dmFyIGI9YS50YXJnZXR8fGEuc3JjRWxlbWVudDtiLmNsYXNzTmFtZT1iLmNsYXNzTmFtZS5yZXBsYWNlKHRoaXMuY29uZmlnLmFuaW1hdGVDbGFzcyxcIlwiKS50cmltKCl9fX0se2tleTpcImN1c3RvbVN0eWxlXCIsdmFsdWU6ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gYiYmdGhpcy5jYWNoZUFuaW1hdGlvbk5hbWUoYSksYS5zdHlsZS52aXNpYmlsaXR5PWI/XCJoaWRkZW5cIjpcInZpc2libGVcIixjJiZ0aGlzLnZlbmRvclNldChhLnN0eWxlLHthbmltYXRpb25EdXJhdGlvbjpjfSksZCYmdGhpcy52ZW5kb3JTZXQoYS5zdHlsZSx7YW5pbWF0aW9uRGVsYXk6ZH0pLGUmJnRoaXMudmVuZG9yU2V0KGEuc3R5bGUse2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OmV9KSx0aGlzLnZlbmRvclNldChhLnN0eWxlLHthbmltYXRpb25OYW1lOmI/XCJub25lXCI6dGhpcy5jYWNoZWRBbmltYXRpb25OYW1lKGEpfSksYX19LHtrZXk6XCJ2ZW5kb3JTZXRcIix2YWx1ZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykpe3ZhciBkPWJbY107YVtcIlwiK2NdPWQ7Zm9yKHZhciBlPTA7ZTx0aGlzLnZlbmRvcnMubGVuZ3RoO2UrKyl7dmFyIGY9dGhpcy52ZW5kb3JzW2VdO2FbXCJcIitmK2MuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYy5zdWJzdHIoMSldPWR9fX19LHtrZXk6XCJ2ZW5kb3JDU1NcIix2YWx1ZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1xKGEpLGQ9Yy5nZXRQcm9wZXJ0eUNTU1ZhbHVlKGIpLGU9MDtlPHRoaXMudmVuZG9ycy5sZW5ndGg7ZSsrKXt2YXIgZj10aGlzLnZlbmRvcnNbZV07ZD1kfHxjLmdldFByb3BlcnR5Q1NTVmFsdWUoXCItXCIrZitcIi1cIitiKX1yZXR1cm4gZH19LHtrZXk6XCJhbmltYXRpb25OYW1lXCIsdmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9dm9pZCAwO3RyeXtiPXRoaXMudmVuZG9yQ1NTKGEsXCJhbmltYXRpb24tbmFtZVwiKS5jc3NUZXh0fWNhdGNoKGMpe2I9cShhKS5nZXRQcm9wZXJ0eVZhbHVlKFwiYW5pbWF0aW9uLW5hbWVcIil9cmV0dXJuXCJub25lXCI9PT1iP1wiXCI6Yn19LHtrZXk6XCJjYWNoZUFuaW1hdGlvbk5hbWVcIix2YWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hbmltYXRpb25OYW1lQ2FjaGUuc2V0KGEsdGhpcy5hbmltYXRpb25OYW1lKGEpKX19LHtrZXk6XCJjYWNoZWRBbmltYXRpb25OYW1lXCIsdmFsdWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYW5pbWF0aW9uTmFtZUNhY2hlLmdldChhKX19LHtrZXk6XCJzY3JvbGxIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnNjcm9sbGVkPSEwfX0se2tleTpcInNjcm9sbENhbGxiYWNrXCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLnNjcm9sbGVkKXt0aGlzLnNjcm9sbGVkPSExO2Zvcih2YXIgYT1bXSxiPTA7Yjx0aGlzLmJveGVzLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuYm94ZXNbYl07aWYoYyl7aWYodGhpcy5pc1Zpc2libGUoYykpe3RoaXMuc2hvdyhjKTtjb250aW51ZX1hLnB1c2goYyl9fXRoaXMuYm94ZXM9YSx0aGlzLmJveGVzLmxlbmd0aHx8dGhpcy5jb25maWcubGl2ZXx8dGhpcy5zdG9wKCl9fX0se2tleTpcIm9mZnNldFRvcFwiLHZhbHVlOmZ1bmN0aW9uKGEpe2Zvcig7dm9pZCAwPT09YS5vZmZzZXRUb3A7KWE9YS5wYXJlbnROb2RlO2Zvcih2YXIgYj1hLm9mZnNldFRvcDthLm9mZnNldFBhcmVudDspYT1hLm9mZnNldFBhcmVudCxiKz1hLm9mZnNldFRvcDtyZXR1cm4gYn19LHtrZXk6XCJpc1Zpc2libGVcIix2YWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1hLmdldEF0dHJpYnV0ZShcImRhdGEtd293LW9mZnNldFwiKXx8dGhpcy5jb25maWcub2Zmc2V0LGM9dGhpcy5jb25maWcuc2Nyb2xsQ29udGFpbmVyJiZ0aGlzLmNvbmZpZy5zY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wfHx3aW5kb3cucGFnZVlPZmZzZXQsZD1jK01hdGgubWluKHRoaXMuZWxlbWVudC5jbGllbnRIZWlnaHQsaygpKS1iLGU9dGhpcy5vZmZzZXRUb3AoYSksZj1lK2EuY2xpZW50SGVpZ2h0O3JldHVybiBkPj1lJiZmPj1jfX0se2tleTpcImRpc2FibGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5jb25maWcubW9iaWxlJiZmKG5hdmlnYXRvci51c2VyQWdlbnQpfX1dKSxhfSgpO2JbXCJkZWZhdWx0XCJdPXIsYS5leHBvcnRzPWJbXCJkZWZhdWx0XCJdfSk7XHJcbiIsImltcG9ydCBXT1cgZnJvbSAnLi9saWIvd293L3dvdy5taW4nO1xyXG5cclxuKGZ1bmN0aW9uICgkKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAvLyBQcmVsb2FkZXJcclxuICAgICQod2luZG93KS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoJCgnI3ByZWxvYWRlcicpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAkKCcjcHJlbG9hZGVyJykuZGVsYXkoMTAwKS5mYWRlT3V0KCdzbG93JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQmFjayB0byB0b3AgYnV0dG9uXHJcbiAgICAkKHdpbmRvdykuc2Nyb2xsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoJCh0aGlzKS5zY3JvbGxUb3AoKSA+IDEwMCkge1xyXG4gICAgICAgICAgICAkKCcuYmFjay10by10b3AnKS5mYWRlSW4oJ3Nsb3cnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkKCcuYmFjay10by10b3AnKS5mYWRlT3V0KCdzbG93Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAkKCcuYmFjay10by10b3AnKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe3Njcm9sbFRvcDogMH0sIDE1MDAsICdlYXNlSW5PdXRFeHBvJyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSW5pdGlhdGUgdGhlIHdvd2pzIGFuaW1hdGlvbiBsaWJyYXJ5XHJcbiAgICBjb25zdCB3b3cgPSBuZXcgV09XKCkuaW5pdCgpO1xyXG5cclxuICAgIC8vIEluaXRpYXRlIHN1cGVyZmlzaCBvbiBuYXYgbWVudVxyXG4gICAgJCgnLm5hdi1tZW51Jykuc3VwZXJmaXNoKHtcclxuICAgICAgICBhbmltYXRpb246IHtcclxuICAgICAgICAgICAgb3BhY2l0eTogJ3Nob3cnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzcGVlZCAgICA6IDQwMFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTW9iaWxlIE5hdmlnYXRpb25cclxuICAgIGlmICgkKCcjbmF2LW1lbnUtY29udGFpbmVyJykubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyICRtb2JpbGVfbmF2ID0gJCgnI25hdi1tZW51LWNvbnRhaW5lcicpLmNsb25lKCkucHJvcCh7XHJcbiAgICAgICAgICAgIGlkOiAnbW9iaWxlLW5hdidcclxuICAgICAgICB9KTtcclxuICAgICAgICAkbW9iaWxlX25hdi5maW5kKCc+IHVsJykuYXR0cih7XHJcbiAgICAgICAgICAgICdjbGFzcyc6ICcnLFxyXG4gICAgICAgICAgICAnaWQnICAgOiAnJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICQoJ2JvZHknKS5hcHBlbmQoJG1vYmlsZV9uYXYpO1xyXG4gICAgICAgICQoJ2JvZHknKS5wcmVwZW5kKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZD1cIm1vYmlsZS1uYXYtdG9nZ2xlXCI+PGkgY2xhc3M9XCJmYSBmYS1iYXJzXCI+PC9pPjwvYnV0dG9uPicpO1xyXG4gICAgICAgICQoJ2JvZHknKS5hcHBlbmQoJzxkaXYgaWQ9XCJtb2JpbGUtYm9keS1vdmVybHlcIj48L2Rpdj4nKTtcclxuICAgICAgICAkKCcjbW9iaWxlLW5hdicpLmZpbmQoJy5tZW51LWhhcy1jaGlsZHJlbicpLnByZXBlbmQoJzxpIGNsYXNzPVwiZmEgZmEtY2hldnJvbi1kb3duXCI+PC9pPicpO1xyXG5cclxuICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnLm1lbnUtaGFzLWNoaWxkcmVuIGknLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAkKHRoaXMpLm5leHQoKS50b2dnbGVDbGFzcygnbWVudS1pdGVtLWFjdGl2ZScpO1xyXG4gICAgICAgICAgICAkKHRoaXMpLm5leHRBbGwoJ3VsJykuZXEoMCkuc2xpZGVUb2dnbGUoKTtcclxuICAgICAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcyhcImZhLWNoZXZyb24tdXAgZmEtY2hldnJvbi1kb3duXCIpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnI21vYmlsZS1uYXYtdG9nZ2xlJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgJCgnYm9keScpLnRvZ2dsZUNsYXNzKCdtb2JpbGUtbmF2LWFjdGl2ZScpO1xyXG4gICAgICAgICAgICAkKCcjbW9iaWxlLW5hdi10b2dnbGUgaScpLnRvZ2dsZUNsYXNzKCdmYS10aW1lcyBmYS1iYXJzJyk7XHJcbiAgICAgICAgICAgICQoJyNtb2JpbGUtYm9keS1vdmVybHknKS50b2dnbGUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgJChkb2N1bWVudCkuY2xpY2soZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9ICQoXCIjbW9iaWxlLW5hdiwgI21vYmlsZS1uYXYtdG9nZ2xlXCIpO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5pcyhlLnRhcmdldCkgJiYgY29udGFpbmVyLmhhcyhlLnRhcmdldCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJCgnYm9keScpLmhhc0NsYXNzKCdtb2JpbGUtbmF2LWFjdGl2ZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdtb2JpbGUtbmF2LWFjdGl2ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICQoJyNtb2JpbGUtbmF2LXRvZ2dsZSBpJykudG9nZ2xlQ2xhc3MoJ2ZhLXRpbWVzIGZhLWJhcnMnKTtcclxuICAgICAgICAgICAgICAgICAgICAkKCcjbW9iaWxlLWJvZHktb3Zlcmx5JykuZmFkZU91dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKCQoXCIjbW9iaWxlLW5hdiwgI21vYmlsZS1uYXYtdG9nZ2xlXCIpLmxlbmd0aCkge1xyXG4gICAgICAgICQoXCIjbW9iaWxlLW5hdiwgI21vYmlsZS1uYXYtdG9nZ2xlXCIpLmhpZGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTbW9vdGggc2Nyb2xsIGZvciB0aGUgbWVudSBhbmQgbGlua3Mgd2l0aCAuc2Nyb2xsdG8gY2xhc3Nlc1xyXG4gICAgJCgnLm5hdi1tZW51IGEsICNtb2JpbGUtbmF2IGEsIC5zY3JvbGx0bycpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXlxcLy8sICcnKSA9PSB0aGlzLnBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCAnJykgJiYgbG9jYXRpb24uaG9zdG5hbWUgPT0gdGhpcy5ob3N0bmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gJCh0aGlzLmhhc2gpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvcF9zcGFjZSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCQoJyNoZWFkZXInKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3Bfc3BhY2UgPSAkKCcjaGVhZGVyJykub3V0ZXJIZWlnaHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkKCcjaGVhZGVyJykuaGFzQ2xhc3MoJ2hlYWRlci1zY3JvbGxlZCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcF9zcGFjZSA9IHRvcF9zcGFjZSAtIDIwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wOiB0YXJnZXQub2Zmc2V0KCkudG9wIC0gdG9wX3NwYWNlXHJcbiAgICAgICAgICAgICAgICB9LCAxNTAwLCAnZWFzZUluT3V0RXhwbycpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLnBhcmVudHMoJy5uYXYtbWVudScpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICQoJy5uYXYtbWVudSAubWVudS1hY3RpdmUnKS5yZW1vdmVDbGFzcygnbWVudS1hY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2xpJykuYWRkQ2xhc3MoJ21lbnUtYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCQoJ2JvZHknKS5oYXNDbGFzcygnbW9iaWxlLW5hdi1hY3RpdmUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICQoJ2JvZHknKS5yZW1vdmVDbGFzcygnbW9iaWxlLW5hdi1hY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgICAgICAkKCcjbW9iaWxlLW5hdi10b2dnbGUgaScpLnRvZ2dsZUNsYXNzKCdmYS10aW1lcyBmYS1iYXJzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnI21vYmlsZS1ib2R5LW92ZXJseScpLmZhZGVPdXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGpRdWVyeSBjb3VudGVyVXAgKHVzZWQgaW4gRmFjdHMgc2VjdGlvbilcclxuICAgICQoJ1tkYXRhLXRvZ2dsZT1cImNvdW50ZXItdXBcIl0nKS5jb3VudGVyVXAoe1xyXG4gICAgICAgIGRlbGF5OiAxMCxcclxuICAgICAgICB0aW1lIDogMTAwMFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUG9yZm9saW8gaXNvdG9wZSBhbmQgZmlsdGVyXHJcbiAgICAvLyB2YXIgcG9ydGZvbGlvSXNvdG9wZSA9ICQoJy5nYWxsZXJ5LWNvbnRhaW5lcicpLmlzb3RvcGUoe1xyXG4gICAgLy8gICAgIGl0ZW1TZWxlY3RvcjogJy5nYWxsZXJ5LWl0ZW0nLFxyXG4gICAgLy8gICAgIGxheW91dE1vZGUgIDogJ2ZpdFJvd3MnXHJcbiAgICAvLyB9KTtcclxuXHJcbiAgICAvLyAkKCcjZ2FsbGVyeS1maWx0ZXJzIGxpJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gICAgICQoXCIjZ2FsbGVyeS1maWx0ZXJzIGxpXCIpLnJlbW92ZUNsYXNzKCdmaWx0ZXItYWN0aXZlJyk7XHJcbiAgICAvLyAgICAgJCh0aGlzKS5hZGRDbGFzcygnZmlsdGVyLWFjdGl2ZScpO1xyXG4gICAgLy9cclxuICAgIC8vICAgICBwb3J0Zm9saW9Jc290b3BlLmlzb3RvcGUoe2ZpbHRlcjogJCh0aGlzKS5kYXRhKCdmaWx0ZXInKX0pO1xyXG4gICAgLy8gfSk7XHJcblxyXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5jb2xsYXBzZS10ZXh0LWRvd24nLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICQodGhpcykucGFyZW50KCkucGFyZW50KCkuZmluZCgnIycgKyAkKHRoaXMpLmRhdGEoJ3RhcmdldC1pZCcpKS5zaG93KCk7XHJcbiAgICAgICAgJCh0aGlzKS5oaWRlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnLmNvbGxhcHNlLXRleHQtdXAnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICQoJyMnICsgJCh0aGlzKS5kYXRhKCd0YXJnZXQtaWQnKSkuaGlkZSgpO1xyXG4gICAgICAgICQodGhpcykucGFyZW50KCkucGFyZW50KCkucGFyZW50KCkuZmluZCgnLmNvbGxhcHNlLXRleHQtZG93bicpLnNob3coKTtcclxuICAgIH0pO1xyXG59KShqUXVlcnkpO1xyXG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNC4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOS0wNS0wMVQyMTowNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy40LjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9ICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjRcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMTktMDQtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQobm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbmFtZXNwYWNlID0gZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0ZG9jRWxlbSA9IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG5cdFx0XHRcdGFyZ3VtZW50ICsgbGVuZ3RoIDpcblx0XHRcdFx0YXJndW1lbnQgPiBsZW5ndGggP1xuXHRcdFx0XHRcdGxlbmd0aCA6XG5cdFx0XHRcdFx0YXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmNvbnRlbnREb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlXG5cdC8vIFdlIHVzZSBnZXRDbGllbnRSZWN0cygpIHRvIGNoZWNrIGZvciBoaWRkZW4vZGlzY29ubmVjdGVkLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3hcblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE1LjBcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbnZhciB0aW1lb3V0RHVyYXRpb24gPSAwO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgdGltZW91dER1cmF0aW9uID0gMTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdIVE1MJzpcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggd2FudCB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuXG4gIHZhciBfZ2V0U3R5bGVDb21wdXRlZFByb3AgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dZO1xuXG4gIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxudmFyIGlzSUUxMSA9IGlzQnJvd3NlciAmJiAhISh3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbnZhciBpc0lFMTAgPSBpc0Jyb3dzZXIgJiYgL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFXG4gKi9cbmZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMTEpIHtcbiAgICByZXR1cm4gaXNJRTExO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAxMCkge1xuICAgIHJldHVybiBpc0lFMTA7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMSB8fCBpc0lFMTA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIG5vT2Zmc2V0UGFyZW50ID0gaXNJRSgxMCkgPyBkb2N1bWVudC5ib2R5IDogbnVsbDtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1RIJywgJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICB2YXIgb3JkZXIgPSBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICB2YXIgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcblxuICBpZiAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICB2YXIgc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3RvcCc7XG5cbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCkge1xuICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXSwgMTApICsgcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUoMTApID8gcGFyc2VJbnQoaHRtbFsnb2Zmc2V0JyArIGF4aXNdKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSkgOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKGVsZW1lbnQub3duZXJEb2N1bWVudCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQucmlnaHQgLSByZXN1bHQubGVmdDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuYm90dG9tIC0gcmVzdWx0LnRvcDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCwgMTApO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIGlzSFRNTCkge1xuICAgIHBhcmVudFJlY3QudG9wID0gTWF0aC5tYXgocGFyZW50UmVjdC50b3AsIDApO1xuICAgIHBhcmVudFJlY3QubGVmdCA9IE1hdGgubWF4KHBhcmVudFJlY3QubGVmdCwgMCk7XG4gIH1cbiAgdmFyIG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0XG4gIH0pO1xuICBvZmZzZXRzLm1hcmdpblRvcCA9IDA7XG4gIG9mZnNldHMubWFyZ2luTGVmdCA9IDA7XG5cbiAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAvLyBkaWZmZXJlbnRseSB3aGVuIG1hcmdpbnMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoZSBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpblxuICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gIGlmICghaXNJRTEwICYmIGlzSFRNTCkge1xuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AsIDEwKTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQsIDEwKTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwICYmICFmaXhlZFBvc2l0aW9uID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGV4Y2x1ZGVTY3JvbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgdmFyIHNjcm9sbExlZnQgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sLCAnbGVmdCcpIDogMDtcblxuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKHBhcmVudE5vZGUpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBwYXJlbnQgb2YgYW4gZWxlbWVudCB0aGF0IGhhcyBhIHRyYW5zZm9ybWVkIHByb3BlcnR5IGRlZmluZWRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IGZpcnN0IHRyYW5zZm9ybWVkIHBhcmVudCBvciBkb2N1bWVudEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGlzSUUoKSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgdmFyIGVsID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAoZWwgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsLCAndHJhbnNmb3JtJykgPT09ICdub25lJykge1xuICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWwgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuXG4vKipcbiAqIENvbXB1dGVkIHRoZSBib3VuZGFyaWVzIGxpbWl0cyBhbmQgcmV0dXJuIHRoZW1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZpeGVkUG9zaXRpb24gLSBJcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICovXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcblxuICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIHJlZmVyZW5jZSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcblxuICAgIC8vIEluIGNhc2Ugb2YgSFRNTCwgd2UgbmVlZCBhIGRpZmZlcmVudCBjb21wdXRhdGlvblxuICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmICFpc0ZpeGVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBwYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuICB2YXIgaXNQYWRkaW5nTnVtYmVyID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInO1xuICBib3VuZGFyaWVzLmxlZnQgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcubGVmdCB8fCAwO1xuICBib3VuZGFyaWVzLnRvcCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy50b3AgfHwgMDtcbiAgYm91bmRhcmllcy5yaWdodCAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCB8fCAwO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20gfHwgMDtcblxuICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQocGxhY2VtZW50LCByZWZSZWN0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMucmlnaHQgLSByZWZSZWN0LnJpZ2h0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG5cbiAgdmFyIGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICByZXR1cm4gd2lkdGggPj0gcG9wcGVyLmNsaWVudFdpZHRoICYmIGhlaWdodCA+PSBwb3BwZXIuY2xpZW50SGVpZ2h0O1xuICB9KTtcblxuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIHJlZmVyZW5jZSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wIHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tIHx8IDApO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoZnVuY3Rpb24gKGN1cikge1xuICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICB2YXIgbWF0Y2ggPSBmaW5kKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgfVxuICAgIHZhciBmbiA9IG1vZGlmaWVyWydmdW5jdGlvbiddIHx8IG1vZGlmaWVyLmZuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIGlmIChtb2RpZmllci5lbmFibGVkICYmIGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAvLyBBZGQgcHJvcGVydGllcyB0byBvZmZzZXRzIHRvIG1ha2UgdGhlbSBhIGNvbXBsZXRlIGNsaWVudFJlY3Qgb2JqZWN0XG4gICAgICAvLyB3ZSBkbyB0aGlzIGJlZm9yZSBlYWNoIG1vZGlmaWVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgb25lIGRvZXNuJ3RcbiAgICAgIC8vIG1lc3Mgd2l0aCB0aGVzZSB2YWx1ZXNcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuICAgICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSk7XG5cbiAgICAgIGRhdGEgPSBmbihkYXRhLCBtb2RpZmllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge31cbiAgfTtcblxuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICBkYXRhLnBvc2l0aW9uRml4ZWQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnO1xuXG4gIC8vIHJ1biB0aGUgbW9kaWZpZXJzXG4gIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gIC8vIHRoZSBmaXJzdCBgdXBkYXRlYCB3aWxsIGNhbGwgYG9uQ3JlYXRlYCBjYWxsYmFja1xuICAvLyB0aGUgb3RoZXIgb25lcyB3aWxsIGNhbGwgYG9uVXBkYXRlYCBjYWxsYmFja1xuICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBlbmFibGVkID0gX3JlZi5lbmFibGVkO1xuICAgIHJldHVybiBlbmFibGVkICYmIG5hbWUgPT09IG1vZGlmaWVyTmFtZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXR5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIGBvblVwZGF0ZWAgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAqIGNvcnJlY3QgcG9wcGVyIG9mZnNldHMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtCb29sZWFufSBzaG91bGRSb3VuZCAtIElmIHRoZSBvZmZzZXRzIHNob3VsZCBiZSByb3VuZGVkIGF0IGFsbFxuICogQHJldHVybnMge09iamVjdH0gVGhlIHBvcHBlcidzIHBvc2l0aW9uIG9mZnNldHMgcm91bmRlZFxuICpcbiAqIFRoZSB0YWxlIG9mIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmcuIEl0J3Mgc3RpbGwgbm90IDEwMCUgcGVyZmVjdCwgYnV0IGFzXG4gKiBnb29kIGFzIGl0IGNhbiBiZSB3aXRoaW4gcmVhc29uLlxuICogRGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9wdWxsLzcxNVxuICpcbiAqIExvdyBEUEkgc2NyZWVucyBjYXVzZSBhIHBvcHBlciB0byBiZSBibHVycnkgaWYgbm90IHVzaW5nIGZ1bGwgcGl4ZWxzIChTYWZhcmlcbiAqIGFzIHdlbGwgb24gSGlnaCBEUEkgc2NyZWVucykuXG4gKlxuICogRmlyZWZveCBwcmVmZXJzIG5vIHJvdW5kaW5nIGZvciBwb3NpdGlvbmluZyBhbmQgZG9lcyBub3QgaGF2ZSBibHVycmluZXNzIG9uXG4gKiBoaWdoIERQSSBzY3JlZW5zLlxuICpcbiAqIE9ubHkgaG9yaXpvbnRhbCBwbGFjZW1lbnQgYW5kIGxlZnQvcmlnaHQgdmFsdWVzIG5lZWQgdG8gYmUgY29uc2lkZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgc2hvdWxkUm91bmQpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4gIHZhciBub1JvdW5kID0gZnVuY3Rpb24gbm9Sb3VuZCh2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgdmFyIHJlZmVyZW5jZVdpZHRoID0gcm91bmQocmVmZXJlbmNlLndpZHRoKTtcbiAgdmFyIHBvcHBlcldpZHRoID0gcm91bmQocG9wcGVyLndpZHRoKTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZGF0YS5wbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIGlzVmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuaW5kZXhPZignLScpICE9PSAtMTtcbiAgdmFyIHNhbWVXaWR0aFBhcml0eSA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gcG9wcGVyV2lkdGggJSAyO1xuICB2YXIgYm90aE9kZFdpZHRoID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSAxICYmIHBvcHBlcldpZHRoICUgMiA9PT0gMTtcblxuICB2YXIgaG9yaXpvbnRhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiBpc1ZlcnRpY2FsIHx8IGlzVmFyaWF0aW9uIHx8IHNhbWVXaWR0aFBhcml0eSA/IHJvdW5kIDogZmxvb3I7XG4gIHZhciB2ZXJ0aWNhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiByb3VuZDtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGhvcml6b250YWxUb0ludGVnZXIoYm90aE9kZFdpZHRoICYmICFpc1ZhcmlhdGlvbiAmJiBzaG91bGRSb3VuZCA/IHBvcHBlci5sZWZ0IC0gMSA6IHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLmJvdHRvbSksXG4gICAgcmlnaHQ6IGhvcml6b250YWxUb0ludGVnZXIocG9wcGVyLnJpZ2h0KVxuICB9O1xufVxuXG52YXIgaXNGaXJlZm94ID0gaXNCcm93c2VyICYmIC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIHZhciBvZmZzZXRzID0gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPCAyIHx8ICFpc0ZpcmVmb3gpO1xuXG4gIHZhciBzaWRlQSA9IHggPT09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byBgdHJ1ZWAgYW5kIHRyYW5zZm9ybSBpcyBzdXBwb3J0ZWQsXG4gIC8vICB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlciB3ZVxuICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcblxuICAvLyBub3csIGxldCdzIG1ha2UgYSBzdGVwIGJhY2sgYW5kIGxvb2sgYXQgdGhpcyBjb2RlIGNsb3NlbHkgKHd0Zj8pXG4gIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgLy8gbWF5IGhhcHBlbiB0aGF0IHRoZSBwb3BwZXIgZ2V0cyBtaXNwbGFjZWQgYmVjYXVzZSBvZiB0aGUgbmV3IGNvbnRlbnRcbiAgLy8gb3ZlcmZsb3dpbmcgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gIC8vIHRoZSBjb25zdW1lciB0byBkZWZpbmUgdGhlIG9mZnNldCBvcmlnaW4uXG4gIC8vIElmIHdlIHBvc2l0aW9uIGEgcG9wcGVyIG9uIHRvcCBvZiBhIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSBjYW4gc2V0XG4gIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAvLyBpdHMgYm90dG9tLlxuICB2YXIgbGVmdCA9IHZvaWQgMCxcbiAgICAgIHRvcCA9IHZvaWQgMDtcbiAgaWYgKHNpZGVBID09PSAnYm90dG9tJykge1xuICAgIC8vIHdoZW4gb2Zmc2V0UGFyZW50IGlzIDxodG1sPiB0aGUgcG9zaXRpb25pbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIChleGNsdWRpbmcgdGhlIHNjcm9sbGJhcilcbiAgICAvLyBhbmQgbm90IHRoZSBib3R0b20gb2YgdGhlIGh0bWwgZWxlbWVudFxuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRvcCA9IG9mZnNldHMudG9wO1xuICB9XG4gIGlmIChzaWRlQiA9PT0gJ3JpZ2h0Jykge1xuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1bmN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgLy8gY29tcHV0ZSBjZW50ZXIgb2YgdGhlIHBvcHBlclxuICB2YXIgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2lkZVZhbHVlIHVzaW5nIHRoZSB1cGRhdGVkIHBvcHBlciBvZmZzZXRzXG4gIC8vIHRha2UgcG9wcGVyIG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gIHZhciBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgcG9wcGVyTWFyZ2luU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydtYXJnaW4nICsgc2lkZUNhcGl0YWxpemVkXSwgMTApO1xuICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10sIDEwKTtcbiAgdmFyIHNpZGVWYWx1ZSA9IGNlbnRlciAtIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLSBwb3BwZXJNYXJnaW5TaWRlIC0gcG9wcGVyQm9yZGVyU2lkZTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0gKF9kYXRhJG9mZnNldHMkYXJyb3cgPSB7fSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgc2lkZSwgTWF0aC5yb3VuZChzaWRlVmFsdWUpKSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgYWx0U2lkZSwgJycpLCBfZGF0YSRvZmZzZXRzJGFycm93KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIGFjY2VwdGVkIHBsYWNlbWVudHMgdG8gdXNlIGFzIHZhbHVlcyBvZiB0aGUgYHBsYWNlbWVudGAgb3B0aW9uLjxiciAvPlxuICogVmFsaWQgcGxhY2VtZW50cyBhcmU6XG4gKiAtIGBhdXRvYFxuICogLSBgdG9wYFxuICogLSBgcmlnaHRgXG4gKiAtIGBib3R0b21gXG4gKiAtIGBsZWZ0YFxuICpcbiAqIEVhY2ggcGxhY2VtZW50IGNhbiBoYXZlIGEgdmFyaWF0aW9uIGZyb20gdGhpcyBsaXN0OlxuICogLSBgLXN0YXJ0YFxuICogLSBgLWVuZGBcbiAqXG4gKiBWYXJpYXRpb25zIGFyZSBpbnRlcnByZXRlZCBlYXNpbHkgaWYgeW91IHRoaW5rIG9mIHRoZW0gYXMgdGhlIGxlZnQgdG8gcmlnaHRcbiAqIHdyaXR0ZW4gbGFuZ3VhZ2VzLiBIb3Jpem9udGFsbHkgKGB0b3BgIGFuZCBgYm90dG9tYCksIGBzdGFydGAgaXMgbGVmdCBhbmQgYGVuZGBcbiAqIGlzIHJpZ2h0LjxiciAvPlxuICogVmVydGljYWxseSAoYGxlZnRgIGFuZCBgcmlnaHRgKSwgYHN0YXJ0YCBpcyB0b3AgYW5kIGBlbmRgIGlzIGJvdHRvbS5cbiAqXG4gKiBTb21lIHZhbGlkIGV4YW1wbGVzIGFyZTpcbiAqIC0gYHRvcC1lbmRgIChvbiB0b3Agb2YgcmVmZXJlbmNlLCByaWdodCBhbGlnbmVkKVxuICogLSBgcmlnaHQtc3RhcnRgIChvbiByaWdodCBvZiByZWZlcmVuY2UsIHRvcCBhbGlnbmVkKVxuICogLSBgYm90dG9tYCAob24gYm90dG9tLCBjZW50ZXJlZClcbiAqIC0gYGF1dG8tZW5kYCAob24gdGhlIHNpZGUgd2l0aCBtb3JlIHNwYWNlIGF2YWlsYWJsZSwgYWxpZ25tZW50IGRlcGVuZHMgYnkgcGxhY2VtZW50KVxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqIEBtZXRob2QgcGxhY2VtZW50c1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgcGxhY2VtZW50cyA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddO1xuXG4vLyBHZXQgcmlkIG9mIGBhdXRvYCBgYXV0by1zdGFydGAgYW5kIGBhdXRvLWVuZGBcbnZhciB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQpIHtcbiAgdmFyIGNvdW50ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIHZhciBhcnIgPSB2YWxpZFBsYWNlbWVudHMuc2xpY2UoaW5kZXggKyAxKS5jb25jYXQodmFsaWRQbGFjZW1lbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gIHJldHVybiBjb3VudGVyID8gYXJyLnJldmVyc2UoKSA6IGFycjtcbn1cblxudmFyIEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZSdcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgdmFyIGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuICAgIHZhciByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG92ZXJsYXBzUmVmID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpIHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0JvdW5kYXJpZXMgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiByZWZlcmVuY2UgZWxlbWVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlSZWYgPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHBvcHBlciBjb250ZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQgPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NMZWZ0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NCb3R0b20gfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NUb3ApO1xuXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSBmbGlwcGVkVmFyaWF0aW9uQnlSZWYgfHwgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudDtcblxuICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzIHx8IGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgIC8vIHRoaXMgYm9vbGVhbiB0byBkZXRlY3QgYW55IGZsaXAgbG9vcFxuICAgICAgZGF0YS5mbGlwcGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMpIHtcbiAgICAgICAgcGxhY2VtZW50ID0gZmxpcE9yZGVyW2luZGV4ICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAgIHZhcmlhdGlvbiA9IGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRhdGEucGxhY2VtZW50ID0gcGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcblxuICAgICAgLy8gdGhpcyBvYmplY3QgY29udGFpbnMgYHBvc2l0aW9uYCwgd2Ugd2FudCB0byBwcmVzZXJ2ZSBpdCBhbG9uZyB3aXRoXG4gICAgICAvLyBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0eSB3ZSBtYXkgYWRkIGluIHRoZSBmdXR1cmVcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLnBvcHBlciwgZ2V0UG9wcGVyT2Zmc2V0cyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpKTtcblxuICAgICAgZGF0YSA9IHJ1bk1vZGlmaWVycyhkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZGF0YSwgJ2ZsaXAnKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGtlZXBUb2dldGhlcihkYXRhKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAncmlnaHQnIDogJ2JvdHRvbSc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgaWYgKHBvcHBlcltzaWRlXSA8IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSAtIHBvcHBlclttZWFzdXJlbWVudF07XG4gIH1cbiAgaWYgKHBvcHBlcltvcFNpZGVdID4gZmxvb3IocmVmZXJlbmNlW3NpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtzaWRlXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBjb250YWluaW5nIHZhbHVlICsgdW5pdCBpbnRvIGEgcHggdmFsdWUgbnVtYmVyXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gc3RyIC0gVmFsdWUgKyB1bml0IHN0cmluZ1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IG1lYXN1cmVtZW50IC0gYGhlaWdodGAgb3IgYHdpZHRoYFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ31cbiAqIFZhbHVlIGluIHBpeGVscywgb3Igb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHZhbHVlcyB3ZXJlIGV4dHJhY3RlZFxuICovXG5mdW5jdGlvbiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpIHtcbiAgLy8gc2VwYXJhdGUgdmFsdWUgZnJvbSB1bml0XG4gIHZhciBzcGxpdCA9IHN0ci5tYXRjaCgvKCg/OlxcLXxcXCspP1xcZCpcXC4/XFxkKikoLiopLyk7XG4gIHZhciB2YWx1ZSA9ICtzcGxpdFsxXTtcbiAgdmFyIHVuaXQgPSBzcGxpdFsyXTtcblxuICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciBpdCdzIGFuIG9wZXJhdG9yLCBJIGd1ZXNzXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKHVuaXQuaW5kZXhPZignJScpID09PSAwKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICclcCc6XG4gICAgICAgIGVsZW1lbnQgPSBwb3BwZXJPZmZzZXRzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgY2FzZSAnJXInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudCA9IHJlZmVyZW5jZU9mZnNldHM7XG4gICAgfVxuXG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgIHJldHVybiByZWN0W21lYXN1cmVtZW50XSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2UgaWYgKHVuaXQgPT09ICd2aCcgfHwgdW5pdCA9PT0gJ3Z3Jykge1xuICAgIC8vIGlmIGlzIGEgdmggb3IgdncsIHdlIGNhbGN1bGF0ZSB0aGUgc2l6ZSBiYXNlZCBvbiB0aGUgdmlld3BvcnRcbiAgICB2YXIgc2l6ZSA9IHZvaWQgMDtcbiAgICBpZiAodW5pdCA9PT0gJ3ZoJykge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzaXplIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgaXMgYW4gZXhwbGljaXQgcGl4ZWwgdW5pdCwgd2UgZ2V0IHJpZCBvZiB0aGUgdW5pdCBhbmQga2VlcCB0aGUgdmFsdWVcbiAgICAvLyBpZiBpcyBhbiBpbXBsaWNpdCB1bml0LCBpdCdzIHB4LCBhbmQgd2UgcmV0dXJuIGp1c3QgdGhlIHZhbHVlXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gYG9mZnNldGAgc3RyaW5nIHRvIGV4dHJhcG9sYXRlIGB4YCBhbmQgYHlgIG51bWVyaWMgb2Zmc2V0cy5cbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBvZmZzZXRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IGJhc2VQbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtBcnJheX0gYSB0d28gY2VsbHMgYXJyYXkgd2l0aCB4IGFuZCB5IG9mZnNldHMgaW4gbnVtYmVyc1xuICovXG5mdW5jdGlvbiBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMsIGJhc2VQbGFjZW1lbnQpIHtcbiAgdmFyIG9mZnNldHMgPSBbMCwgMF07XG5cbiAgLy8gVXNlIGhlaWdodCBpZiBwbGFjZW1lbnQgaXMgbGVmdCBvciByaWdodCBhbmQgaW5kZXggaXMgMCBvdGhlcndpc2UgdXNlIHdpZHRoXG4gIC8vIGluIHRoaXMgd2F5IHRoZSBmaXJzdCBvZmZzZXQgd2lsbCB1c2UgYW4gYXhpcyBhbmQgdGhlIHNlY29uZCBvbmVcbiAgLy8gd2lsbCB1c2UgdGhlIG90aGVyIG9uZVxuICB2YXIgdXNlSGVpZ2h0ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgLy8gU3BsaXQgdGhlIG9mZnNldCBzdHJpbmcgdG8gb2J0YWluIGEgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzXG4gIC8vIFRoZSByZWdleCBhZGRyZXNzZXMgdmFsdWVzIHdpdGggdGhlIHBsdXMgb3IgbWludXMgc2lnbiBpbiBmcm9udCAoKzEwLCAtMjAsIGV0YylcbiAgdmFyIGZyYWdtZW50cyA9IG9mZnNldC5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcudHJpbSgpO1xuICB9KTtcblxuICAvLyBEZXRlY3QgaWYgdGhlIG9mZnNldCBzdHJpbmcgY29udGFpbnMgYSBwYWlyIG9mIHZhbHVlcyBvciBhIHNpbmdsZSBvbmVcbiAgLy8gdGhleSBjb3VsZCBiZSBzZXBhcmF0ZWQgYnkgY29tbWEgb3Igc3BhY2VcbiAgdmFyIGRpdmlkZXIgPSBmcmFnbWVudHMuaW5kZXhPZihmaW5kKGZyYWdtZW50cywgZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy5zZWFyY2goLyx8XFxzLykgIT09IC0xO1xuICB9KSk7XG5cbiAgaWYgKGZyYWdtZW50c1tkaXZpZGVyXSAmJiBmcmFnbWVudHNbZGl2aWRlcl0uaW5kZXhPZignLCcpID09PSAtMSkge1xuICAgIGNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgLy8gSWYgZGl2aWRlciBpcyBmb3VuZCwgd2UgZGl2aWRlIHRoZSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHMgdG8gZGl2aWRlXG4gIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgdmFyIHNwbGl0UmVnZXggPSAvXFxzKixcXHMqfFxccysvO1xuICB2YXIgb3BzID0gZGl2aWRlciAhPT0gLTEgPyBbZnJhZ21lbnRzLnNsaWNlKDAsIGRpdmlkZXIpLmNvbmNhdChbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzBdXSksIFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMV1dLmNvbmNhdChmcmFnbWVudHMuc2xpY2UoZGl2aWRlciArIDEpKV0gOiBbZnJhZ21lbnRzXTtcblxuICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgd2l0aCB1bml0cyB0byBhYnNvbHV0ZSBwaXhlbHMgdG8gYWxsb3cgb3VyIGNvbXB1dGF0aW9uc1xuICBvcHMgPSBvcHMubWFwKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICAvLyBNb3N0IG9mIHRoZSB1bml0cyByZWx5IG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcG9wcGVyXG4gICAgdmFyIG1lYXN1cmVtZW50ID0gKGluZGV4ID09PSAxID8gIXVzZUhlaWdodCA6IHVzZUhlaWdodCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgcmV0dXJuIG9wXG4gICAgLy8gVGhpcyBhZ2dyZWdhdGVzIGFueSBgK2Agb3IgYC1gIHNpZ24gdGhhdCBhcmVuJ3QgY29uc2lkZXJlZCBvcGVyYXRvcnNcbiAgICAvLyBlLmcuOiAxMCArICs1ID0+IFsxMCwgKywgKzVdXG4gICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGFbYS5sZW5ndGggLSAxXSA9PT0gJycgJiYgWycrJywgJy0nXS5pbmRleE9mKGIpICE9PSAtMSkge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IHRydWU7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIGlmIChtZXJnZVdpdGhQcmV2aW91cykge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gKz0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9XG4gICAgfSwgW10pXG4gICAgLy8gSGVyZSB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdmFsdWVzIGludG8gbnVtYmVyIHZhbHVlcyAoaW4gcHgpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gTG9vcCB0cm91Z2ggdGhlIG9mZnNldHMgYXJyYXlzIGFuZCBleGVjdXRlIHRoZSBvcGVyYXRpb25zXG4gIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICBvcC5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnLCBpbmRleDIpIHtcbiAgICAgIGlmIChpc051bWVyaWMoZnJhZykpIHtcbiAgICAgICAgb2Zmc2V0c1tpbmRleF0gKz0gZnJhZyAqIChvcFtpbmRleDIgLSAxXSA9PT0gJy0nID8gLTEgOiAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEBhcmd1bWVudCB7TnVtYmVyfFN0cmluZ30gb3B0aW9ucy5vZmZzZXQ9MFxuICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIG9mZnNldChkYXRhLCBfcmVmKSB7XG4gIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldDtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LFxuICAgICAgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICB2YXIgb2Zmc2V0cyA9IHZvaWQgMDtcbiAgaWYgKGlzTnVtZXJpYygrb2Zmc2V0KSkge1xuICAgIG9mZnNldHMgPSBbK29mZnNldCwgMF07XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0cyA9IHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyLCByZWZlcmVuY2UsIGJhc2VQbGFjZW1lbnQpO1xuICB9XG5cbiAgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAndG9wJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMV07XG4gIH1cblxuICBkYXRhLnBvcHBlciA9IHBvcHBlcjtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBib3VuZGFyaWVzRWxlbWVudCA9IG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQgfHwgZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcblxuICAvLyBJZiBvZmZzZXRQYXJlbnQgaXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSByZWFsbHkgd2FudCB0b1xuICAvLyBnbyBvbmUgc3RlcCB1cCBhbmQgdXNlIHRoZSBuZXh0IG9mZnNldFBhcmVudCBhcyByZWZlcmVuY2UgdG9cbiAgLy8gYXZvaWQgdG8gbWFrZSB0aGlzIG1vZGlmaWVyIGNvbXBsZXRlbHkgdXNlbGVzcyBhbmQgbG9vayBsaWtlIGJyb2tlblxuICBpZiAoZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UgPT09IGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgYm91bmRhcmllc0VsZW1lbnQgPSBnZXRPZmZzZXRQYXJlbnQoYm91bmRhcmllc0VsZW1lbnQpO1xuICB9XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc2V0cyB0aGUgcG9wcGVyJ3MgcG9zaXRpb24gc28gdGhhdCB0aGUgZG9jdW1lbnQgc2l6ZSBjYW4gYmUgY2FsY3VsYXRlZCBleGNsdWRpbmdcbiAgLy8gdGhlIHNpemUgb2YgdGhlIHBvcHBlciBlbGVtZW50IGl0c2VsZlxuICB2YXIgdHJhbnNmb3JtUHJvcCA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG4gIHZhciBwb3BwZXJTdHlsZXMgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5zdHlsZTsgLy8gYXNzaWdubWVudCB0byBoZWxwIG1pbmlmaWNhdGlvblxuICB2YXIgdG9wID0gcG9wcGVyU3R5bGVzLnRvcCxcbiAgICAgIGxlZnQgPSBwb3BwZXJTdHlsZXMubGVmdCxcbiAgICAgIHRyYW5zZm9ybSA9IHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXTtcblxuICBwb3BwZXJTdHlsZXMudG9wID0gJyc7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gJyc7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9ICcnO1xuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBzdHlsZSBwcm9wZXJ0aWVzIGFmdGVyIHRoZSBvZmZzZXRzIGhhdmUgYmVlbiBjb21wdXRlZFxuICBwb3BwZXJTdHlsZXMudG9wID0gdG9wO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9IGxlZnQ7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblxuICBvcHRpb25zLmJvdW5kYXJpZXMgPSBib3VuZGFyaWVzO1xuXG4gIHZhciBvcmRlciA9IG9wdGlvbnMucHJpb3JpdHk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIHZhciBjaGVjayA9IHtcbiAgICBwcmltYXJ5OiBmdW5jdGlvbiBwcmltYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW3BsYWNlbWVudF07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPCBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHBvcHBlcltwbGFjZW1lbnRdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBwbGFjZW1lbnQsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNlY29uZGFyeTogZnVuY3Rpb24gc2Vjb25kYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIG1haW5TaWRlID0gcGxhY2VtZW50ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbbWFpblNpZGVdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdID4gYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihwb3BwZXJbbWFpblNpZGVdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0gLSAocGxhY2VtZW50ID09PSAncmlnaHQnID8gcG9wcGVyLndpZHRoIDogcG9wcGVyLmhlaWdodCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBtYWluU2lkZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICB2YXIgc2lkZSA9IFsnbGVmdCcsICd0b3AnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSc7XG4gICAgcG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgY2hlY2tbc2lkZV0ocGxhY2VtZW50KSk7XG4gIH0pO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBwb3BwZXI7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0KGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgc2hpZnR2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICAvLyBpZiBzaGlmdCBzaGlmdHZhcmlhdGlvbiBpcyBzcGVjaWZpZWQsIHJ1biB0aGUgbW9kaWZpZXJcbiAgaWYgKHNoaWZ0dmFyaWF0aW9uKSB7XG4gICAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcjtcblxuICAgIHZhciBpc1ZlcnRpY2FsID0gWydib3R0b20nLCAndG9wJ10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIHZhciBzaGlmdE9mZnNldHMgPSB7XG4gICAgICBzdGFydDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSksXG4gICAgICBlbmQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbWVhc3VyZW1lbnRdIC0gcG9wcGVyW21lYXN1cmVtZW50XSlcbiAgICB9O1xuXG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIHNoaWZ0T2Zmc2V0c1tzaGlmdHZhcmlhdGlvbl0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBoaWRlKGRhdGEpIHtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdoaWRlJywgJ3ByZXZlbnRPdmVyZmxvdycpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcmVmUmVjdCA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciBib3VuZCA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAncHJldmVudE92ZXJmbG93JztcbiAgfSkuYm91bmRhcmllcztcblxuICBpZiAocmVmUmVjdC5ib3R0b20gPCBib3VuZC50b3AgfHwgcmVmUmVjdC5sZWZ0ID4gYm91bmQucmlnaHQgfHwgcmVmUmVjdC50b3AgPiBib3VuZC5ib3R0b20gfHwgcmVmUmVjdC5yaWdodCA8IGJvdW5kLmxlZnQpIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSB0cnVlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IGZhbHNlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaW5uZXIoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNIb3JpeiA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBzdWJ0cmFjdExlbmd0aCA9IFsndG9wJywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID09PSAtMTtcblxuICBwb3BwZXJbaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnXSA9IHJlZmVyZW5jZVtiYXNlUGxhY2VtZW50XSAtIChzdWJ0cmFjdExlbmd0aCA/IHBvcHBlcltpc0hvcml6ID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA6IDApO1xuXG4gIGRhdGEucGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QocG9wcGVyKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBNb2RpZmllciBmdW5jdGlvbiwgZWFjaCBtb2RpZmllciBjYW4gaGF2ZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSBhc3NpZ25lZFxuICogdG8gaXRzIGBmbmAgcHJvcGVydHkuPGJyIC8+XG4gKiBUaGVzZSBmdW5jdGlvbnMgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCB1cGRhdGUsIHRoaXMgbWVhbnMgdGhhdCB5b3UgbXVzdFxuICogbWFrZSBzdXJlIHRoZXkgYXJlIHBlcmZvcm1hbnQgZW5vdWdoIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzLlxuICpcbiAqIEBmdW5jdGlvbiBNb2RpZmllckZuXG4gKiBAYXJndW1lbnQge2RhdGFPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge2RhdGFPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuXG4vKipcbiAqIE1vZGlmaWVycyBhcmUgcGx1Z2lucyB1c2VkIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB5b3VyIHBvcHBlcnMuPGJyIC8+XG4gKiBQb3BwZXIuanMgdXNlcyBhIHNldCBvZiA5IG1vZGlmaWVycyB0byBwcm92aWRlIGFsbCB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzXG4gKiBuZWVkZWQgYnkgdGhlIGxpYnJhcnkuXG4gKlxuICogVXN1YWxseSB5b3UgZG9uJ3Qgd2FudCB0byBvdmVycmlkZSB0aGUgYG9yZGVyYCwgYGZuYCBhbmQgYG9uTG9hZGAgcHJvcHMuXG4gKiBBbGwgdGhlIG90aGVyIHByb3BlcnRpZXMgYXJlIGNvbmZpZ3VyYXRpb25zIHRoYXQgY291bGQgYmUgdHdlYWtlZC5cbiAqIEBuYW1lc3BhY2UgbW9kaWZpZXJzXG4gKi9cbnZhciBtb2RpZmllcnMgPSB7XG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHNoaWZ0IHRoZSBwb3BwZXIgb24gdGhlIHN0YXJ0IG9yIGVuZCBvZiBpdHMgcmVmZXJlbmNlXG4gICAqIGVsZW1lbnQuPGJyIC8+XG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgdmFyaWF0aW9uIG9mIHRoZSBgcGxhY2VtZW50YCBwcm9wZXJ0eS48YnIgLz5cbiAgICogSXQgY2FuIGJlIG9uZSBlaXRoZXIgYC1lbmRgIG9yIGAtc3RhcnRgLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgc2hpZnQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAxMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBzaGlmdFxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgYG9mZnNldGAgbW9kaWZpZXIgY2FuIHNoaWZ0IHlvdXIgcG9wcGVyIG9uIGJvdGggaXRzIGF4aXMuXG4gICAqXG4gICAqIEl0IGFjY2VwdHMgdGhlIGZvbGxvd2luZyB1bml0czpcbiAgICogLSBgcHhgIG9yIHVuaXQtbGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAqIC0gYCVgIG9yIGAlcmAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogLSBgJXBgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICogLSBgdmhgLCBDU1Mgdmlld3BvcnQgaGVpZ2h0IHVuaXRcbiAgICpcbiAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBwbGFjZW1lbnQgaXMgYHRvcGAgb3IgYGJvdHRvbWAsIHRoZSBsZW5ndGggd2lsbCBiZSB0aGVcbiAgICogYHdpZHRoYC4gSW4gY2FzZSBvZiBgbGVmdGAgb3IgYHJpZ2h0YCwgaXQgd2lsbCBiZSB0aGUgYGhlaWdodGAuXG4gICAqXG4gICAqIFlvdSBjYW4gcHJvdmlkZSBhIHNpbmdsZSB2YWx1ZSAoYXMgYE51bWJlcmAgb3IgYFN0cmluZ2ApLCBvciBhIHBhaXIgb2YgdmFsdWVzXG4gICAqIGFzIGBTdHJpbmdgIGRpdmlkZWQgYnkgYSBjb21tYSBvciBvbmUgKG9yIG1vcmUpIHdoaXRlIHNwYWNlcy48YnIgLz5cbiAgICogVGhlIGxhdHRlciBpcyBhIGRlcHJlY2F0ZWQgbWV0aG9kIGJlY2F1c2UgaXQgbGVhZHMgdG8gY29uZnVzaW9uIGFuZCB3aWxsIGJlXG4gICAqIHJlbW92ZWQgaW4gdjIuPGJyIC8+XG4gICAqIEFkZGl0aW9uYWxseSwgaXQgYWNjZXB0cyBhZGRpdGlvbnMgYW5kIHN1YnRyYWN0aW9ucyBiZXR3ZWVuIGRpZmZlcmVudCB1bml0cy5cbiAgICogTm90ZSB0aGF0IG11bHRpcGxpY2F0aW9ucyBhbmQgZGl2aXNpb25zIGFyZW4ndCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIFZhbGlkIGV4YW1wbGVzIGFyZTpcbiAgICogYGBgXG4gICAqIDEwXG4gICAqICcxMCUnXG4gICAqICcxMCwgMTAnXG4gICAqICcxMCUsIDEwJ1xuICAgKiAnMTAgKyAxMCUnXG4gICAqICcxMCAtIDV2aCArIDMlJ1xuICAgKiAnLTEwcHggKyA1dmgsIDVweCAtIDYlJ1xuICAgKiBgYGBcbiAgICogPiAqKk5CKio6IElmIHlvdSBkZXNpcmUgdG8gYXBwbHkgb2Zmc2V0cyB0byB5b3VyIHBvcHBlcnMgaW4gYSB3YXkgdGhhdCBtYXkgbWFrZSB0aGVtIG92ZXJsYXBcbiAgICogPiB3aXRoIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50LCB1bmZvcnR1bmF0ZWx5LCB5b3Ugd2lsbCBoYXZlIHRvIGRpc2FibGUgdGhlIGBmbGlwYCBtb2RpZmllci5cbiAgICogPiBZb3UgY2FuIHJlYWQgbW9yZSBvbiB0aGlzIGF0IHRoaXMgW2lzc3VlXShodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9pc3N1ZXMvMzczKS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIG9mZnNldDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0yMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDIwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IG9mZnNldCxcbiAgICAvKiogQHByb3Age051bWJlcnxTdHJpbmd9IG9mZnNldD0wXG4gICAgICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgb2Zmc2V0OiAwXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gcHJldmVudCB0aGUgcG9wcGVyIGZyb20gYmVpbmcgcG9zaXRpb25lZCBvdXRzaWRlIHRoZSBib3VuZGFyeS5cbiAgICpcbiAgICogQSBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyLiBUaGlzIG1ha2VzIHN1cmUgdGhlIHBvcHBlciBhbHdheXMgaGFzIGEgbGl0dGxlIHBhZGRpbmdcbiAgICAgKiBiZXR3ZWVuIHRoZSBlZGdlcyBvZiBpdHMgY29udGFpbmVyXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0nc2Nyb2xsUGFyZW50J1xuICAgICAqIEJvdW5kYXJpZXMgdXNlZCBieSB0aGUgbW9kaWZpZXIuIENhbiBiZSBgc2Nyb2xsUGFyZW50YCwgYHdpbmRvd2AsXG4gICAgICogYHZpZXdwb3J0YCBvciBhbnkgRE9NIGVsZW1lbnQuXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICdzY3JvbGxQYXJlbnQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSByZWZlcmVuY2UgYW5kIGl0cyBwb3BwZXIgc3RheSBuZWFyIGVhY2ggb3RoZXJcbiAgICogd2l0aG91dCBsZWF2aW5nIGFueSBnYXAgYmV0d2VlbiB0aGUgdHdvLiBFc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHRoZSBhcnJvdyBpc1xuICAgKiBlbmFibGVkIGFuZCB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCBpdCBwb2ludHMgdG8gaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBJdCBjYXJlcyBvbmx5IGFib3V0IHRoZSBmaXJzdCBheGlzLiBZb3UgY2FuIHN0aWxsIGhhdmUgcG9wcGVycyB3aXRoIG1hcmdpblxuICAgKiBiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGtlZXBUb2dldGhlcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj00MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDQwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGtlZXBUb2dldGhlclxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1vZGlmaWVyIGlzIHVzZWQgdG8gbW92ZSB0aGUgYGFycm93RWxlbWVudGAgb2YgdGhlIHBvcHBlciB0byBtYWtlXG4gICAqIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBiZXR3ZWVuIHRoZSByZWZlcmVuY2UgZWxlbWVudCBhbmQgaXRzIHBvcHBlciBlbGVtZW50LlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIG91dGVyIHNpemUgb2YgdGhlIGBhcnJvd0VsZW1lbnRgIG5vZGUgdG8gZGV0ZWN0IGhvdyBtYW55XG4gICAqIHBpeGVscyBvZiBjb25qdW5jdGlvbiBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXJyb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA1MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcnJvdyxcbiAgICAvKiogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gZWxlbWVudD0nW3gtYXJyb3ddJyAtIFNlbGVjdG9yIG9yIG5vZGUgdXNlZCBhcyBhcnJvdyAqL1xuICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqXG4gICAqICoqTk9URToqKiB0aGlzIG1vZGlmaWVyIHdpbGwgaW50ZXJydXB0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZSBhbmQgd2lsbFxuICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgZmxpcDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj02MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDYwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGZsaXAsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICogVGhlIGJlaGF2aW9yIHVzZWQgdG8gY2hhbmdlIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAgICAgKiBgZmxpcGAsIGBjbG9ja3dpc2VgLCBgY291bnRlcmNsb2Nrd2lzZWAgb3IgYW4gYXJyYXkgd2l0aCBhIGxpc3Qgb2YgdmFsaWRcbiAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpXG4gICAgICovXG4gICAgYmVoYXZpb3I6ICdmbGlwJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgZmxpcCBpZiBpdCBoaXRzIHRoZSBlZGdlcyBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3ZpZXdwb3J0J1xuICAgICAqIFRoZSBlbGVtZW50IHdoaWNoIHdpbGwgZGVmaW5lIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBwb3BwZXIgcG9zaXRpb24uXG4gICAgICogVGhlIHBvcHBlciB3aWxsIG5ldmVyIGJlIHBsYWNlZCBvdXRzaWRlIG9mIHRoZSBkZWZpbmVkIGJvdW5kYXJpZXNcbiAgICAgKiAoZXhjZXB0IGlmIGBrZWVwVG9nZXRoZXJgIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zPWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJsYXBzIGl0cyBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9uc0J5Q29udGVudD1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSBwb3BwZXIgZWxlbWVudCBvdmVybGFwcyBpdHMgcmVmZXJlbmNlIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uc0J5Q29udGVudDogZmFsc2VcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdib3R0b20nXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWCBheGlzIChgYm90dG9tYCBvciBgdG9wYCkuIEFLQSBYIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgKi9cbiAgICB4OiAnYm90dG9tJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nbGVmdCddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBZIGF4aXMgKGBsZWZ0YCBvciBgcmlnaHRgKS4gQUtBIFkgb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICovXG4gICAgeTogJ3JpZ2h0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdXIgb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkXG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGBkYXRhT2JqZWN0YCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGluZm9ybWF0aW9uIHVzZWQgYnkgUG9wcGVyLmpzLlxuICogVGhpcyBvYmplY3QgaXMgcGFzc2VkIHRvIG1vZGlmaWVycyBhbmQgdG8gdGhlIGBvbkNyZWF0ZWAgYW5kIGBvblVwZGF0ZWAgY2FsbGJhY2tzLlxuICogQG5hbWUgZGF0YU9iamVjdFxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuaW5zdGFuY2UgVGhlIFBvcHBlci5qcyBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEucGxhY2VtZW50IFBsYWNlbWVudCBhcHBsaWVkIHRvIHBvcHBlclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgUGxhY2VtZW50IG9yaWdpbmFsbHkgZGVmaW5lZCBvbiBpbml0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuZmxpcHBlZCBUcnVlIGlmIHBvcHBlciBoYXMgYmVlbiBmbGlwcGVkIGJ5IGZsaXAgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5oaWRlIFRydWUgaWYgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dCBvZiBib3VuZGFyaWVzLCB1c2VmdWwgdG8ga25vdyB3aGVuIHRvIGhpZGUgdGhlIHBvcHBlclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdy4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucG9wcGVyIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLmFycm93XSBgdG9wYCBhbmQgYGxlZnRgIG9mZnNldHMsIG9ubHkgb25lIG9mIHRoZW0gd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSAwXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgcHJvdmlkZWQgdG8gUG9wcGVyLmpzIGNvbnN0cnVjdG9yLjxiciAvPlxuICogVGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUgb2YgdGhlIGBvcHRpb25zYCBvYmplY3QsIGFzIHRoZSAzcmQgYXJndW1lbnQuIEZvciBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudC5cbiAgICogQHByb3Age1BvcHBlci5wbGFjZW1lbnRzfSBwbGFjZW1lbnQ9J2JvdHRvbSdcbiAgICovXG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG5cbiAgLyoqXG4gICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgcG9wcGVyIHRvIHBvc2l0aW9uIGl0IHNlbGYgaW4gJ2ZpeGVkJyBtb2RlXG4gICAqIEBwcm9wIHtCb29sZWFufSBwb3NpdGlvbkZpeGVkPWZhbHNlXG4gICAqL1xuICBwb3NpdGlvbkZpeGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciBldmVudHMgKHJlc2l6ZSwgc2Nyb2xsKSBhcmUgaW5pdGlhbGx5IGVuYWJsZWQuXG4gICAqIEBwcm9wIHtCb29sZWFufSBldmVudHNFbmFibGVkPXRydWVcbiAgICovXG4gIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBwb3BwZXIgd2hlblxuICAgKiB5b3UgY2FsbCB0aGUgYGRlc3Ryb3lgIG1ldGhvZC5cbiAgICogQHByb3Age0Jvb2xlYW59IHJlbW92ZU9uRGVzdHJveT1mYWxzZVxuICAgKi9cbiAgcmVtb3ZlT25EZXN0cm95OiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyBjcmVhdGVkLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvbkNyZWF0ZX1cbiAgICovXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIHVwZGF0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbm90IGNhbGxlZFxuICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgKiB1cGRhdGVzLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvblVwZGF0ZX1cbiAgICovXG4gIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG1vZGlmaWVycyB1c2VkIHRvIG1vZGlmeSB0aGUgb2Zmc2V0cyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLlxuICAgKiBUaGV5IHByb3ZpZGUgbW9zdCBvZiB0aGUgZnVuY3Rpb25hbGl0aWVzIG9mIFBvcHBlci5qcy5cbiAgICogQHByb3Age21vZGlmaWVyc31cbiAgICovXG4gIG1vZGlmaWVyczogbW9kaWZpZXJzXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8vIFV0aWxzXG4vLyBNZXRob2RzXG52YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBQb3BwZXIuanMgaW5zdGFuY2UuXG4gICAqIEBjbGFzcyBQb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fHJlZmVyZW5jZU9iamVjdH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIC8gWE1MIGVsZW1lbnQgdXNlZCBhcyB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gdXBkYXRlLiBJdCB3aWxsIHJ1biBvbiB0aGUgbmV4dCBVSSB1cGRhdGUgYXZhaWxhYmxlLlxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVVcGRhdGVcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY3VzdG9tIG1vZGlmaWVycy5cbiAgICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICAgKiBpbmNsdWRlIGBwb3BwZXItdXRpbHMuanNgIGJlZm9yZSBgcG9wcGVyLmpzYC5cbiAgICAgKlxuICAgICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICAgKiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyISBVc2UgdGhlIFBvcHBlclV0aWxzIG1vZHVsZSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqIER1ZSB0byB0aGUgaGlnaCBpbnN0YWJpbGl0eSBvZiB0aGUgbWV0aG9kcyBjb250YWluZWQgaW4gVXRpbHMsIHdlIGNhbid0XG4gICAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS44XG4gICAgICogQG1lbWJlciBVdGlsc1xuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuICB9XSk7XG4gIHJldHVybiBQb3BwZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gKiBhbmQgbGV0cyB5b3UgdXNlIGl0IGFzIHJlcGxhY2VtZW50IG9mIGEgcmVhbCBET00gbm9kZS48YnIgLz5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHBvc2l0aW9uIGEgcG9wcGVyIHJlbGF0aXZlbHkgdG8gYSBzZXQgb2YgY29vcmRpbmF0ZXNcbiAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICogYGBgXG4gKlxuICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IFBvcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9